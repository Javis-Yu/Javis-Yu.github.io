<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数学建模 | Javis's Blogs</title><meta name="keywords" content="主页"><meta name="author" content="于邦震"><meta name="copyright" content="于邦震"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数学建模的建模方法">
<meta property="og:type" content="article">
<meta property="og:title" content="数学建模">
<meta property="og:url" content="https://javis-yu.github.io/archives/a66872a2.html">
<meta property="og:site_name" content="Javis&#39;s Blogs">
<meta property="og:description" content="数学建模的建模方法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/bg3.png">
<meta property="article:published_time" content="2020-08-05T04:34:45.000Z">
<meta property="article:modified_time" content="2022-05-08T19:26:13.384Z">
<meta property="article:author" content="于邦震">
<meta property="article:tag" content="主页">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/bg3.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://javis-yu.github.io/archives/a66872a2"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="code-6F0sHObQQP"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?da270e768783141ff6a72798583e77b9";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数学建模',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-09 03:26:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Javis's Blogs" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/headimg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-solid fa-screwdriver-wrench"></i><span> 个人项目</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/project/"><i class="fa-fw fa-solid fa-virus-covid"></i><span> 疫情图鉴</span></a></li><li><a class="site-page child" href="/project2/"><i class="fa-fw fa-solid fa-square-parking"></i><span> 立体停车库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw fa-solid fa-head-side-cough"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa-solid fa-heart"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/money/"><i class="fa-fw fa-solid fa-sack-dollar"></i><span> 打赏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-star"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/bg3.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Javis's Blogs</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-solid fa-screwdriver-wrench"></i><span> 个人项目</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/project/"><i class="fa-fw fa-solid fa-virus-covid"></i><span> 疫情图鉴</span></a></li><li><a class="site-page child" href="/project2/"><i class="fa-fw fa-solid fa-square-parking"></i><span> 立体停车库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw fa-solid fa-head-side-cough"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa-solid fa-heart"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/money/"><i class="fa-fw fa-solid fa-sack-dollar"></i><span> 打赏</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-star"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数学建模</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-05T04:34:45.000Z" title="发表于 2020-08-05 12:34:45">2020-08-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-08T19:26:13.384Z" title="更新于 2022-05-09 03:26:13">2022-05-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>83分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h1><p>[toc]</p>
<h1 id="数学建模学习"><a href="#数学建模学习" class="headerlink" title="数学建模学习"></a>数学建模学习</h1><h3 id="建模方法："><a href="#建模方法：" class="headerlink" title="建模方法："></a>建模方法：</h3><p>模型假设-建模与求-模型评价-模型改进-模型检验</p>
<h3 id="微分方程建模方法"><a href="#微分方程建模方法" class="headerlink" title="微分方程建模方法"></a>微分方程建模方法</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p>1.要根据问题确定要研究的量，设好所有用到的变量（自变量、未知变量、必要参数），确定坐标系等方法。</p>
<p>2.找到量所满足的基本规律。</p>
<p>3.运用规律列出方程和确定解  使用到导数</p>
<h4 id="1-按规律直接列方程"><a href="#1-按规律直接列方程" class="headerlink" title="1.    按规律直接列方程"></a><strong>1.</strong>    <strong>按规律直接列方程</strong></h4><p>例题1：</p>
<p><img src="C:\Kuai8Games\Code\推文\图片\shumo.png" alt="shumo"></p>
<p>牛顿冷却定律：温度高于周围环境的物体向周围媒质传递热量逐渐冷却时所遵循的规律。当物体表面与周围存在温度差时，单位时间从单位面积散失的热量与温度差成正比，比例系数称为热传递系数。牛顿冷却定律是牛顿在1701年用实验确定的，在强制对流时与实际符合较好，在自然对流时只在温度差不太大时才成立。 是传热学的基本定律之一，用于计算对流热量的多少。<br>$$<br>设物体在t时刻温度为u&#x3D;u(t),牛顿冷却定律得:\frac{du}{dt}&#x3D;-\frac{u(t)-u(t_\infty )}{\tau }&#x3D;-k(u-\widetilde{u})   \ \ 其中\widetilde{u}为常温的温度 \ \ k&gt;0  \ 令\widetilde{u}&#x3D;24 \ \ 且(u-\widetilde{u})&gt;0<br>$$<br>则：<br>$$<br>\frac{du}{u-24}&#x3D;-k \ dt \ &#x3D;&#x3D;&gt; \frac{d(u-24)}{u-24}&#x3D;-k \ dt 这里用了积分的性质，积分号里面不变\<br>求微分：<br>\int_{150}^{u}\frac{d(u-24)}{u-24}&#x3D;\int_{0}^{t}-k \ dt \ \ \ \<br>得：ln(u-24)|<em>{150}^{u} &#x3D; -kt|</em>{t}^{0} \ \ \<br>u&#x3D;24+126e^{-kt}\ \ 带入t&#x3D;0，u_0&#x3D;150 \ \ 与 \ \ t&#x3D;10,u&#x3D;100 \<br>得k&#x3D;0.0506  \ \ \ \ 所以u&#x3D;24+126e^{-0.0506t}<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line">sp.var(<span class="string">&#x27;t,k&#x27;</span>)					<span class="comment">#设置变量t和k</span></span><br><span class="line">u=sp.var(<span class="string">&#x27;u&#x27;</span>,cls=sp.Function)   <span class="comment">#设置cls参数为Function表示它是数学函数的符号。</span></span><br><span class="line">eq=sp.diff(u(t),t)+k*(u(t)-<span class="number">24</span>)  <span class="comment">#建立等式 u(t)对t求积分=-k(u-24)</span></span><br><span class="line">uu=sp.dsolve(eq,ics=&#123;u(<span class="number">0</span>):<span class="number">150</span>&#125;)	<span class="comment">#求符号方程的解  这里相当于微分后u(0):150--&gt;u:150-u  t:0-t.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;微分方程的符号解为：&#x27;</span>,uu)	<span class="comment">#输出方程</span></span><br><span class="line"></span><br><span class="line">kk=sp.solve(uu,k) 				<span class="comment">#这里是求解k的所有符合的值</span></span><br><span class="line"><span class="built_in">print</span>(kk,<span class="string">&#x27;= 0&#x27;</span>)</span><br><span class="line">k0=kk[<span class="number">0</span>].subs(&#123;t:<span class="number">10.0</span>,u(t):<span class="number">100</span>&#125;)<span class="comment">#得到</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k0 =&#x27;</span>,k0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k的值为：&#x27;</span>,k0.evalf())    <span class="comment">#k0.evalf()表示转化为浮点数</span></span><br><span class="line">u1=uu.args[<span class="number">1</span>]                   <span class="comment">#提出符号表达式24 + 126*exp(-k*t)</span></span><br><span class="line"><span class="comment">#print(u1)</span></span><br><span class="line">u0=u1.subs(&#123;t:<span class="number">20</span>,k:k0&#125;)         <span class="comment">#代入具体值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;20分钟后的温度为：&#x27;</span>,u0)</span><br></pre></td></tr></table></figure>



<h4 id="2-微元分析法"><a href="#2-微元分析法" class="headerlink" title="2.    微元分析法"></a><strong>2.</strong>    <strong>微元分析法</strong></h4><p>例题2：</p>
<p><img src="C:\Kuai8Games\Code\推文\图片\shuxue0.png" alt="shuxue0"></p>
<img src="C:\Kuai8Games\Code\推文\图片\shumo1.png" alt="shumo1" style="zoom: 50%;" />

<p>设流量为Q  通过孔的水的体积V  时间t   g为重力加速度（9.8m&#x2F;s<sup>2</sup>）  0.62为流量系数  h为高cm  S为孔的面积cm<sup>2</sup></p>
<p>流量系数：是指单位时间内、在测试条件中管道保持恒定的压力，管道介质流经阀门的体积流量，或是质量流量。 即阀门的流通能力。 流量系数值越大说明流体流过阀门时的压力损失越小。</p>
<p>得到公式为：<br>$$<br>Q&#x3D;\frac{dV}{dt}&#x3D;0.62S\sqrt{2gh}<br>$$<br>同一单位后：<br>$$<br>dV&#x3D;0.000062S\sqrt{2gh}\ dt<br>$$<br>在微小的一段时间里面：[t , t+dt ] 内，高度变化 [ h , h+dh ] ( dh&lt;0 ) , 容器中水的体积的改变：<br>$$<br>dV &#x3D; - \pi r^2 \ dh \<br>r为液面的半径\ \ \ \ R为球的半径\ \ \ \ h 为液面的高度 \<br>r^2 &#x3D; [R^2-(R-h)^2]&#x3D;2h-h^2<br>$$</p>
<p>所以带入r<sup>2</sup>&#x3D;2h-h<sup>2</sup><br>$$<br>0.000062 \sqrt{2gh}\ dt &#x3D; -\pi (2h-h^2)\ dh<br>$$<br>回到题目求 高度h 与 时间t 的变化：<br>$$<br>\begin{equation}<br>\left{<br>             \begin{array}{lr}<br>              \frac{dt}{dh}&#x3D;\frac{-\pi (2h-h^2)}{0.000062 \sqrt{2gh}} \<br>              h(0)&#x3D;1<br>             \end{array}<br>\right.<br>\end{equation} \<br>$$</p>
<p>$$<br>{\color{Red}eq} &#x3D; \frac{dt}{dh}-\frac{-\pi (2h-h^2)}{0.000062 \sqrt{2gh}}&#x3D;\color{Red}\frac{dt}{dh}-\frac{1000000\pi (h^{\frac{3}{2}}-2h^{\frac{1}{2}})}{62 \sqrt{2g}}<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line">sp.var(<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">sp.var(<span class="string">&#x27;t&#x27;</span>,cls=sp.Function)</span><br><span class="line">g  = <span class="number">9.8</span></span><br><span class="line">eq=t(h).diff(h)-<span class="number">10000</span>*sp.pi/<span class="number">0.62</span>/sp.sqrt(<span class="number">2</span>*g)*(h**(<span class="number">3</span>/<span class="number">2</span>)-<span class="number">2</span>*h**(<span class="number">1</span>/<span class="number">2</span>)) <span class="comment">#求解等式</span></span><br><span class="line">t=sp.dslove(eq,ics=&#123;t(<span class="number">1</span>):<span class="number">0</span>&#125;)						  <span class="comment">#带入初始值求符号解</span></span><br><span class="line">t=sp.simplify(t)													</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;符号解为：&#x27;</span>,t)									<span class="comment">#输出符号解</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;方程的解为：&#x27;</span>,t.args[<span class="number">1</span>].evalf())				   <span class="comment">#将方程的解的系数用实数值表示 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以方程的解为：<br>$$<br>\color{Red}t(h)&#x3D;-15260.5042h^{\frac{3}{2}}+4578.1513h^{\frac{5}{2}}+10682.3530<br>$$</p>
<h4 id="3-模拟近似法"><a href="#3-模拟近似法" class="headerlink" title="3.    模拟近似法"></a><strong>3.</strong>    模拟近似法</h4><p><strong>例3</strong> （交通管理问题）在交通十字路口，都会设置红绿灯。为了让那些正行驶在交叉路口太近而无法停下的车辆通过路口，红绿灯转换中间还要亮起一段时间的黄灯。那么，黄灯应亮多长时间才最为合理？</p>
<p>首先考虑问的是黄灯亮多长时间，则要考虑：司机反应时间+刹车距离的时间+车通过交叉入口的时间。</p>
<p>首先设：v<sub>0</sub>是法定速度      I是交通路口长度     L是车长   </p>
<p>则：车通过路口的正常时间为：(I+L)&#x2F;v<sub>0</sub></p>
<p>求 开始刹车到速度为0 的距离。</p>
<p>设： W 为汽车的重量   μ为摩擦系数     所以摩擦力为f&#x3D;μW   方向与运动方向相反<br>$$<br>f&#x3D;μW  \ \ \ \ \ W&#x3D;mg \ \ \ \ \ f&#x3D;-ma&#x3D;-m\frac{dv}{dt}&#x3D;-\frac{W}{g}\frac{d^2 x}{dt^2} \<br>μmg&#x3D;-\frac{W}{g}\frac{d^2 x}{dt^2}\<br>{\color{Red}-μg&#x3D;\frac{d^2 x}{dt^2}}\<br>$$<br>所以得到：<br>$$<br>\begin{equation}<br>\left{<br>             \begin{array}{lr}<br>              -μg&#x3D;\frac{d^2 x}{dt^2} \<br>              x|<em>{t&#x3D;0}&#x3D;0, \ \frac{dx}{dt}|</em>{t&#x3D;0}&#x3D;v_0<br>             \end{array}<br>\right.<br>\end{equation} \<br>$$</p>
<p>化简并积分<br>$$<br>d^2 x&#x3D;-μgdt^2 \ \</p>
<p> \int_{0}^{x} d^2 x &#x3D; \int_{0}^{t}-μgdt^2<br>$$<br>得：<br>$$<br>\frac{dx}{dt}&#x3D;-μgt+v_0 \ \ \<br>$$<br>二次积分：<br>$$<br>\int_{0}^{x}dx  &#x3D;  \int_{0}^{t}(-μgt+v_0)dt\<br>$$<br>得：<br>$$<br>{\color{Red}x(t)&#x3D;-\frac{1}{2}μgt^2+v_0t}<br>$$</p>
<p>当利用前面的公式：<br>$$<br>\frac{dx}{dt}&#x3D;0 \ \ \ \ \ \ 和 \ \ \ \ \ \frac{dx}{dt}&#x3D;-μgt+v_0<br>$$<br>得到：<br>$$<br>-μgt+v_0&#x3D;0<br>$$<br>所以    刹车所用时间为：<br>$$<br>t_0&#x3D;\frac{v_0}{μg}<br>$$<br>然后将时间带入x(t)的公式：<br>$$<br>x(t_0)&#x3D;-\frac{1}{2}μgt^2 |_{t_0&#x3D;\frac{v_0}{μg}}<br>$$<br>所以刹车距离为：<br>$$<br>{\color{Red}x(t_0)&#x3D;}-\frac{1}{2}μg\frac{v_0^2}{μ^2g^2}&#x3D;\color{Red}-\frac{v_0^2}{2μg}<br>$$<br>计算黄灯的时间T：黄灯的时间<br>$$<br>T&#x3D;\frac{x(t_0)+I+L}{v_0}+T_0<br>$$<br>总路程为x(t<sub>0</sub>)+I+L   +  T<sub>0</sub> 反应时间   x（t<sub>0</sub>） 得：<br>$$<br>T&#x3D;\frac{I+L}{v_0}+T_0+\frac{v_0}{2μg}<br>$$<br>取<strong>μ&#x3D;0.7   T<sub>0</sub>&#x3D;1s   L&#x3D;4.5m  I&#x3D;9m    令：v<sub>0</sub> &#x3D;45km&#x2F;h     65km&#x2F;h      80km&#x2F;h</strong></p>
<table>
<thead>
<tr>
<th>v<sub>0</sub>  &#x2F;  (km&#x2F;h)</th>
<th>45</th>
<th>65</th>
<th>80</th>
</tr>
</thead>
<tbody><tr>
<td>T   &#x2F;   s</td>
<td>4.58</td>
<td>5.95</td>
<td>7.00</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line">v0 = array([<span class="number">45</span>,<span class="number">65</span>,<span class="number">80</span>])   	<span class="comment"># v0向量</span></span><br><span class="line">T0 = <span class="number">1</span>						<span class="comment"># T0反应时间</span></span><br><span class="line">L  = <span class="number">4.5</span>					<span class="comment"># L是车长4.5m</span></span><br><span class="line">I  = <span class="number">9</span>						<span class="comment"># 交通路口长度9m</span></span><br><span class="line">mu = <span class="number">0.7</span>					<span class="comment"># 摩擦系数0.7</span></span><br><span class="line">g  = <span class="number">9.8</span>					<span class="comment"># 重力加速度</span></span><br><span class="line">T = v0/(<span class="number">2</span>*mu*g)+(I+L)/v0+T0 <span class="comment"># 黄灯时间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当速度分别是45、65、80(km/s)时黄灯的时长为&#x27;</span>,T)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Lorenz模型的混沌效应"><a href="#Lorenz模型的混沌效应" class="headerlink" title="Lorenz模型的混沌效应"></a>Lorenz模型的混沌效应</h3><p>Lorenz模型是由美国气象学家Lorenz在研究大气运动时，通过简化对流模型，只保留3个变量提出的一个完全确定性的一阶自治常微分方程组（不显含时间变量），其方程为<br>$$<br>\begin{cases}<br> &amp; \overset{.}{x}&#x3D; \sigma(y-x)\<br> &amp; \overset{.}{y}&#x3D; \rho x-y-xz\<br> &amp; \overset{.}{z}&#x3D; xy-\beta z<br>\end{cases}<br>$$<br>其中，参数&amp;sigma; 为Prandtl数，&amp;rho;为Rayleigh数，&amp;beta;为方向比.</p>
<p>第一个混沌吸引子——Lorenz吸引子也是在这个系统中被发现的. 系统中三个参数的选择对系统会不会进入混沌状态其着重要的作用.</p>
<p>蝴蝶效应：  &amp;sigma; &#x3D; 10            &amp;rho; &#x3D; 28              &amp;beta; &#x3D; 8&#x2F;3</p>
<p>给出了系统从两个靠得很近的初值出发（相差仅0.0001）后，解的偏差演化曲线. 随着时间的增大，可以看到两个解的差异越来越大，这正是动力学系统对初值敏感性的直观表现，由此可断定此系统的这种状态为混沌态. 混沌运动是确定性系统中存在随机性，它的运动轨道对初始条件极端敏感.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> odeint</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lorenz</span>(<span class="params">w,t</span>):<span class="comment">#定义求解函数</span></span><br><span class="line">    sigma=<span class="number">10</span></span><br><span class="line">    rho=<span class="number">28</span></span><br><span class="line">    beta=<span class="number">8</span>/<span class="number">3</span></span><br><span class="line">    x,y,z=w</span><br><span class="line">    <span class="keyword">return</span> np.array([sigma*(y-x),rho*x-y-x*z,x*y-beta*z])</span><br><span class="line"></span><br><span class="line">t=np.arange(<span class="number">0</span>,<span class="number">50</span>,<span class="number">0.01</span>) <span class="comment">#创建时间点</span></span><br><span class="line">sol1=odeint(lorenz,[<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>],t) <span class="comment">#第一个初值问题求解</span></span><br><span class="line">sol2=odeint(lorenz,[<span class="number">0.0</span>,<span class="number">1.0001</span>,<span class="number">0.0</span>],t) <span class="comment">#第二个初值问题求解</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sol1:\n&#x27;</span>,sol1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sol2:\n&#x27;</span>,sol2)</span><br><span class="line"></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,family=<span class="string">&#x27;SimHei&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">plt.rc(<span class="string">&#x27;axes&#x27;</span>,unicode_minus=<span class="literal">False</span>) <span class="comment">#用来正常显示负号</span></span><br><span class="line"></span><br><span class="line">ax1=plt.subplot(<span class="number">121</span>,projection=<span class="string">&#x27;3d&#x27;</span>,title=<span class="string">&#x27;图a&#x27;</span>)</span><br><span class="line">ax2=plt.subplot(<span class="number">122</span>,projection=<span class="string">&#x27;3d&#x27;</span>,title=<span class="string">&#x27;图b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax1.plot(sol1[:,<span class="number">0</span>],sol1[:,<span class="number">1</span>],sol1[:,<span class="number">2</span>],<span class="string">&#x27;r&#x27;</span>) <span class="comment">#r表示红色</span></span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;$y$&#x27;</span>)</span><br><span class="line">ax1.set_zlabel(<span class="string">&#x27;$z$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(sol1[:,<span class="number">0</span>]-sol2[:,<span class="number">0</span>],sol1[:,<span class="number">1</span>]-sol2[:,<span class="number">1</span>],sol1[:,<span class="number">2</span>]-sol2[:,<span class="number">2</span>],<span class="string">&#x27;g&#x27;</span>) <span class="comment">#g表示绿色</span></span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;$y$&#x27;</span>)</span><br><span class="line">ax2.set_zlabel(<span class="string">&#x27;$z$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个初值问题的解sol1=&#x27;</span>,sol1)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个初值问题的解sol2=&#x27;</span>,sol2)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;解的偏差sol1-sol2=&#x27;</span>,sol1-sol2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Malthus模型"><a href="#Malthus模型" class="headerlink" title="Malthus模型"></a>Malthus<strong>模型</strong></h3><p>1789年，英国神父Malthus在分析了一百多年人口统计资料之后，提出了Malthus模型.</p>
<h4 id="1-模型假设"><a href="#1-模型假设" class="headerlink" title="1.模型假设"></a>1.模型假设</h4><ul>
<li>设x（t）表示t时刻的人口数，并且x（t）连续且可微</li>
<li>设人口的增长率r是常数（增长率 &#x3D; 出生率 - 死亡率）</li>
<li>人口的变化封闭，人口数量的增加与减少只取决于人口中个体的生育和死亡，且每一个体都具有同样的生育能力与死亡率。</li>
</ul>
<h4 id="2-建模与求解"><a href="#2-建模与求解" class="headerlink" title="2.建模与求解"></a><strong>2.建模与求解</strong></h4><p>设：t-&gt;t+&amp;Delta;t    人口的增量为：x(t+&amp;Delta;t) - x(t)  &#x3D;  r x(t) &amp;Delta;t<br>$$<br>\begin{cases}<br> &amp; \frac{dx}{dt}&#x3D;rx \ \ \ \ \ \ 增长的人数&#x3D;增长率*总人口\<br> &amp; x(0)&#x3D;x_0       \ \ \  初始人口为一定值<br>\end{cases}<br>$$<br>求解：<br>$$<br>\int_{0}^{x}\frac{1}{x}dx&#x3D;\int_{0}^{t}r\ dt<br>$$<br>所以：<br>$$<br>lnx|_0^x&#x3D;rt|^t_0<br>$$<br>解的：<br>$$<br>lnx-lnx_0&#x3D;ln\frac{x}{x0}&#x3D;rt<br>$$<br>所以：<br>$$<br>\frac{x}{x_0}&#x3D;e^{rt}<br>$$<br>方程的解为：<br>$$<br>x(t)&#x3D;x_0\ e^{rt}<br>$$</p>
<h4 id="3-模型评价"><a href="#3-模型评价" class="headerlink" title="3.模型评价"></a>3.模型评价</h4><p>考虑二百多年来人口增长的实际情况，1961年世界人口总数为3.06x10<sup>9</sup>,在1961~1970年这段时间内，每年平均人口自然增长率为2%，则带入上式有：<br>$$<br>x(t)&#x3D;3.06\times 10^9\cdot e^{0.02(t-1961)}<br>$$<br>因为在这期间地球人口大约每35年增加1倍，而(3) 式算出每34.6年增加1倍.短期内，计算结果相当符合事实。但当t&#x3D;2670年时，x(t)&#x3D;4.4x10<sup>15</sup>,即4400万亿，相当于地球没平方米容纳至少20人。显然是不对的， 误差的原因是增长率r的估计过高，由此，可以队r这个常数提出假设。</p>
<h4 id="4-模型改进"><a href="#4-模型改进" class="headerlink" title="4.模型改进"></a>4.模型改进</h4><p><strong>一、</strong> <strong>当增长率不是常数时的模型</strong>**</p>
<p>因为地球资源是有限的，他只提供一定量的生命生存所需的条件。人口增加，自然资源、环境资源等会对人口再增长的限制越来月显著。当人过少时，可以r看为常数，但一定量后，r随着人口的增加而减少，即增长率r表示为x(t)的函数r(x(t))，记为r(x)，且r(x)为x的减函数。</p>
<h5 id="模型再次假设"><a href="#模型再次假设" class="headerlink" title="模型再次假设"></a>模型再次假设</h5><ul>
<li>设r（x）为x的线性函数，r（x）&#x3D;  r - sx  (工程署原则，首先用线性)</li>
<li>自然资源与环境条件所能容纳的最大人口数为x<sub>m</sub>,当x&#x3D;x<sub>m</sub>时，增长率r（x<sub>m</sub>）&#x3D; 0</li>
</ul>
<h5 id="模型建立与求解"><a href="#模型建立与求解" class="headerlink" title="模型建立与求解"></a>模型建立与求解</h5><p>由公式这个：<br>$$<br>\frac{dx}{dt}&#x3D;rx<br>$$<br>可以想到斜率会是s型。那么：<br>$$<br>令r(x)&#x3D;r(1-\frac{x}{x_m}) \ 保证了x大于x_m时会负增长 \ x&#x3D;x_m时0增长 \<br>而且增长率虽人口增加而减少<br>$$<br>假设了一个增长率函数，然后求解：<br>$$<br>\begin{cases}<br> &amp; \frac{dx}{dt}&#x3D;r(1-\frac{x}{x_m})x \<br> &amp; x(t_0)&#x3D;x_0<br>\end{cases}<br>$$<br>对第一个求积分并化简<br>$$<br>\int_{0}^{x}\frac{1}{(1-\frac{x}{x_m})x}dx&#x3D;\int_{0}^{x}\frac{x_m}{xx_m-x^2}dx&#x3D;\int_{0}^{t}r\ dt  \ \ \ \ \ \ \  \ \ \ \ \   (x_m为定值)<br>$$<br>求解：<br>$$<br>x(t)&#x3D;\frac{x_m}{1+(\frac{x_m}{x_0}-1)e^{-r(t-t_0)}}<br>$$<br>这个就是<strong>Logistic模型</strong></p>
<h5 id="模型检验"><a href="#模型检验" class="headerlink" title="模型检验"></a>模型检验</h5><p>$$<br>\frac{dx}{dt}求导得：\frac{d^2x}{dt^2}&#x3D;r^2(1-\frac{x}{x^m})(1-\frac{2x}{x_m})x<br>$$</p>
<p>人口总数x(t)有如下规律：<br>$$<br>\lim_{t\rightarrow\infty}x(t)&#x3D;x_m \ \ \ \ \ \ \ \ \ \ \ \ 即无论人口初值  如何，人口总数以  为极限.<br>$$</p>
<p>$$<br>当0&lt;x_0&lt;x_m时，\frac{dx}{dt}&#x3D;r(1-\frac{x}{x_m})x &gt; 0 \ \ \ 说明x(t)是单调增加的；<br>$$</p>
<p>$$<br>当x&lt;\frac{x_m}{2}时，\frac{d^2x}{dt^2}&gt;0,x&#x3D;x(t)为凹函数<br>$$</p>
<p>$$<br>当x&gt;\frac{x_m}{2}时，\frac{d^2x}{dt^2}&lt;0,x&#x3D;x(t)为凸函数<br>$$</p>
<p>$$<br>人口变化率\frac{dx}{dt}在x&#x3D;\frac{x_m}{2}时取最大值 \即人口总数达到极限值一半以前是加速生长，过了这一点后，会逐渐减小，最终达到0。<br>$$</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>利用下表给出的近两个世纪的美国人口统计数据（以百万为单位），建立人口预测模型，最后用它估计2010年美国的人口。</p>
<center>数据</center>

<table>
<thead>
<tr>
<th>年份</th>
<th>1790</th>
<th>1800</th>
<th>1810</th>
<th>1820</th>
<th>1830</th>
</tr>
</thead>
<tbody><tr>
<td>人口</td>
<td>3.9</td>
<td>5.3</td>
<td>7.2</td>
<td>9.6</td>
<td>12.9</td>
</tr>
<tr>
<td>年份</td>
<td>1840</td>
<td>1850</td>
<td>1860</td>
<td>1870</td>
<td>1880</td>
</tr>
<tr>
<td>人口</td>
<td>17.1</td>
<td>23.2</td>
<td>31.4</td>
<td>38.6</td>
<td>50.2</td>
</tr>
<tr>
<td>年份</td>
<td>1890</td>
<td>1900</td>
<td>1910</td>
<td>1920</td>
<td>1930</td>
</tr>
<tr>
<td>人口</td>
<td>62.9</td>
<td>76.0</td>
<td>92.0</td>
<td>106.5</td>
<td>123.2</td>
</tr>
<tr>
<td>年份</td>
<td>1940</td>
<td>1950</td>
<td>1960</td>
<td>1970</td>
<td>1980</td>
</tr>
<tr>
<td>人口</td>
<td>131.7</td>
<td>150.7</td>
<td>179.3</td>
<td>204.0</td>
<td>226.5</td>
</tr>
<tr>
<td>年份</td>
<td>1990</td>
<td>2000</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>人口</td>
<td>251.4</td>
<td>281.4</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="建立模型与求解"><a href="#建立模型与求解" class="headerlink" title="建立模型与求解"></a>建立模型与求解</h5><p>记x（t）为第t年的人口数量，设人口年增长率r(x)为x的线性函数，r(x) &#x3D; r - sx , 自然资源与环境条件所容纳的最大人口数为x<sub>m</sub>，即当x &#x3D; x<sub>m</sub>时，增长率r(x<sub>m</sub>) &#x3D; 0 ，得<br>$$<br>r(x)&#x3D;r(1-\frac{x}{x_m})<br>$$<br>建立 Logistic 人口模型：<br>$$<br>\begin{cases}<br> &amp; \frac{dx}{dt}&#x3D;r(1-\frac{x}{x_m})x \<br> &amp; x(t_0)&#x3D;x_0<br>\end{cases}<br>$$<br>解的：<br>$$<br>x(t)&#x3D;\frac{x_m}{1+(\frac{x_m}{x_0}-1)e^{-r(t-t_0)}}<br>$$</p>
<h5 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h5><h6 id="非线性最小二乘法"><a href="#非线性最小二乘法" class="headerlink" title="非线性最小二乘法"></a>非线性最小二乘法</h6><p>将第一个数据为初始条件，用余下的数据来拟合 Logistic 函数的参数x<sub>m</sub>和r 。解的r&#x3D;0.0274，x<sub>m</sub>&#x3D;342.4419</p>
<p>带入公式得：<br>$$<br>x(t)&#x3D;\frac{342.4419}{1+(\frac{342.4419}{x_0}-1)e^{-0.0274(t-t_0)}}<br>$$<br>将数据2010年的数据带入预测值为：2010—-282.6798（百万）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#非线性最小二乘法</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"></span><br><span class="line">a=[]</span><br><span class="line">b=[]</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取文件，一行一行读取，偶数行为年份，奇数行为数量</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡14.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s=f.read().splitlines()  </span><br><span class="line"><span class="built_in">print</span>(s,<span class="string">&#x27;\n&#x27;</span>)    </span><br><span class="line"><span class="comment">#print(len(s))  s=6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取年份</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s),<span class="number">2</span>):</span><br><span class="line">    d1 = s[i].split(<span class="string">&#x27;\t&#x27;</span>) 		<span class="comment">#将年份数据按&#x27;\t&#x27;分割</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(d1)):   	<span class="comment">#将分割开的年份数据用append的方法放到列表</span></span><br><span class="line">        <span class="keyword">if</span> d1[j]!=<span class="string">&#x27;&#x27;</span>:			<span class="comment">#判断是否为空</span></span><br><span class="line">            a.append(<span class="built_in">eval</span>(d1[j]))</span><br><span class="line"><span class="built_in">print</span>(a,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s),<span class="number">2</span>):		<span class="comment">#同样的道理分割数量的数据</span></span><br><span class="line">    d2=s[i].split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(d2)):</span><br><span class="line">        <span class="keyword">if</span> d2[j]!=<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            b.append(<span class="built_in">eval</span>(d2[j]))</span><br><span class="line"><span class="built_in">print</span>(b,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c=np.vstack((a,b))</span><br><span class="line">np.savetxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡14_例1_数据.txt&#x27;</span>,c) </span><br><span class="line"></span><br><span class="line">x0=<span class="number">3.9</span></span><br><span class="line">t0=<span class="number">1790</span></span><br><span class="line">x=<span class="keyword">lambda</span> t,r,xm:xm/(<span class="number">1</span>+(xm/x0-<span class="number">1</span>)*np.exp(-r*(t-t0)))</span><br><span class="line">bd=((<span class="number">0</span>,<span class="number">200</span>),(<span class="number">0.1</span>,<span class="number">1000</span>))  <span class="comment">#约束两个参数的下界和上界</span></span><br><span class="line">popt,pcov=curve_fit(x,a[<span class="number">1</span>:],b[<span class="number">1</span>:],bounds=bd)</span><br><span class="line"><span class="comment"># 参数r与xm的估计值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;返回参数r与xm的值&#x27;</span>,popt,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2010年的预测值为：&#x27;</span>,x(<span class="number">2010</span>,*popt))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="线性最小二乘法"><a href="#线性最小二乘法" class="headerlink" title="线性最小二乘法"></a>线性最小二乘法</h6><p>简单的线性最小二乘估计这个模型的参数 x<sub>m</sub> 和 r ，把Logistic方程表示为：<br>$$<br>\frac{1}{x}\frac{dx}{dt}&#x3D;r-sx \ \ \ \ ,\ \  \ s&#x3D;\frac{r}{x_m}<br>$$<br>记1790,1800，…… ，2000年分别用 k &#x3D; 1，2，3，……，21  表示，利用向前差分，得到差分方程：<br>$$<br>\frac{1}{x(k)}\cdot \frac{x(k+1)-x(k)}{\Delta t}&#x3D;r-sx(k)\ \ \ \ \ ,\ \ \ \ \ \ k&#x3D;1,2,3,…,21<br>$$<br>其中步长&amp;Delta;t&#x3D;10。拟合数据，求得r&#x3D;0.0325，x(m)&#x3D;294.3860 ，再求得2010年人口预测值为277.9634百万。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#线性最小二乘法</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">d=np.loadtxt(<span class="string">&#x27;暑假打卡14_例1_数据.txt&#x27;</span>) <span class="comment">#加载文件中的数据</span></span><br><span class="line"><span class="built_in">print</span>(d)					<span class="comment"># 观察完数据可注释掉</span></span><br><span class="line">t0=d[<span class="number">0</span>] 					<span class="comment"># 提取年代数据</span></span><br><span class="line">x0=d[<span class="number">1</span>] 					<span class="comment"># 提取对应的人口数据</span></span><br><span class="line"><span class="built_in">print</span>(t0)</span><br><span class="line"><span class="built_in">print</span>(x0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(x0[:-<span class="number">1</span>]) 				<span class="comment"># 获取数据除去最后一位</span></span><br><span class="line">b=np.diff(x0)/<span class="number">10</span>/x0[:-<span class="number">1</span>]	<span class="comment"># 构造线性方程组的常数项列</span></span><br><span class="line">a=np.vstack([np.ones(<span class="built_in">len</span>(x0)-<span class="number">1</span>),-x0[:-<span class="number">1</span>]]).T <span class="comment">#构造线性方程组系数矩阵</span></span><br><span class="line">rs=np.linalg.pinv(a)@b </span><br><span class="line"><span class="comment">#pinv表示矩阵a的伪逆pinv(X) ，此处不懂可百度最小二乘法的公式以及伪逆。</span></span><br><span class="line"><span class="comment">#这里的@指矩阵的乘法</span></span><br><span class="line">r=rs[<span class="number">0</span>]</span><br><span class="line">xm=r/rs[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;人口增长率r和人口最大值xm的拟合值分别为&#x27;</span>,np.<span class="built_in">round</span>([r,xm],<span class="number">4</span>)) <span class="comment">#round函数表示四舍五入，此处4表示保留4位小数</span></span><br><span class="line">xhat=xm/(<span class="number">1</span>+(xm/<span class="number">3.9</span>-<span class="number">1</span>)*np.exp(-r*(<span class="number">2010</span>-<span class="number">1790</span>))) <span class="comment">#求预测值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2010年的预测值为：&#x27;</span>,<span class="built_in">round</span>(xhat,<span class="number">4</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="传染病模型"><a href="#传染病模型" class="headerlink" title="传染病模型"></a>传染病模型</h3><p> 传染病动力学是用数学模型研究某种传染病在某的一地区是否蔓延下去，成为当地的“地方病”，或最终该病将被消除. 下面以Kermack和Mckendrick 提出的阈值模型为例说明传染病动力学模型的建模过程。</p>
<h4 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h4><ol>
<li><p>被研究人群是封闭的，总人数为 n 。s(t) , i(t) , r(t) 分别代表：t 时刻  易感染着、已感染着、免疫者。  起始条件：s<sub>0</sub>个易感染者 ， i<sub>0</sub> 个感染者 ，n-s<sub>0 </sub>- i<sub>0</sub> 个</p>
</li>
<li><p>易感染人数的变化率与当时的易感染人数和感染人数之积成正比 ， 系数为  &amp;lambda;。</p>
</li>
<li><p>免疫者人数的变化率与当时的感染者人数成正比，比例系数为 &amp;mu; 。</p>
</li>
<li><p>三类人总的变化率代数和为零.</p>
</li>
</ol>
<h4 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h4><p>根据上述假设，可以建立如下模型：</p>
<p>$$<br>\begin{cases}<br> &amp; \frac{ds}{dt}&#x3D;  -\lambda si\<br> &amp; \frac{dr}{dt}&#x3D;  \mu i\<br> &amp; \frac{di}{dt}+\frac{ds}{dt}+\frac{dr}{dt}&#x3D;0  \<br> &amp; \frac{di}{dt}&#x3D;  \lambda si-\mu i\<br> &amp; s(t)+i(t)+r(t)&#x3D;n<br>\end{cases}<br>$$<br>模型又称Kermack-Mckendrick方程</p>
<h4 id="模型求解与分解"><a href="#模型求解与分解" class="headerlink" title="模型求解与分解"></a>模型求解与分解</h4><p>上面的方程无法求解出任何一个  s(t) , i(t) , r(t) 的解析解。转到平面 s-i 讨论解的性质。<br>$$<br>由 得：\begin{cases}<br>\frac{di}{ds}&#x3D;\frac{1}{\sigma s}-1\<br>\sigma&#x3D;\frac{\lambda}{\mu}\<br>i|_{s&#x3D;s_0}&#x3D;i_0 \<br>\end{cases}<br>$$</p>
<p>$$<br>\mu是易感人数的变化率系数、\lambda是免疫者人数的变化率系数、\sigma则为一个传染期内每个患者有效接触的平均人数<br>$$</p>
<p>则&amp;sigma;为接触数.</p>
<p>分离变量法求解：<br>$$<br>di&#x3D;(\frac{1}{\sigma s}-1)ds<br>$$<br>然后对两边积分：<br>$$<br>\int_{i_0}^{i}di&#x3D;\int_{s_0}^{s}(\frac{1}{\sigma s}-1)ds<br>$$<br>得：<br>$$<br>i|<em>{i_0}^{i}&#x3D;(\frac{1}{\sigma}lns-s)|</em>{s_0}^{s}<br>$$<br>所以：<br>$$<br>i-i_0 &#x3D;\frac{1}{\sigma}lns-s-\frac{1}{\sigma}lns_0+s_0<br>$$<br>化简：<br>$$<br>i&#x3D;i_0+s_0-s+\frac{1}{\sigma}(lns-lns_0)<br>$$<br>解的：<br>$$<br>i&#x3D;i_0+s_0-s+\frac{1}{\sigma}(ln\frac{s}{s_0})<br>$$<br>由公式得知：</p>
<p><img src="C:\Kuai8Games\Code\推文\图片\shumo3.png" alt="shumo3"></p>
<ul>
<li><p>当初始值s<sub>0</sub> &amp;le; 1&#x2F; &amp;sigma; 时，患者人数会增加，传染病开始蔓延，健康者的人数在减少。</p>
</li>
<li><p>当初始值s(t) 减少至 1&#x2F; &amp;sigma; 时,患者在人群中的比例达到最大值，然后患者数逐渐减少至零</p>
</li>
<li><p>1&#x2F; &amp;sigma; 是阈值，所以要想控制传染病的流行，应控制s<sub>0</sub> 使之小于阈值.</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>提高卫生和医疗水平，卫生水平越高，使传染性接触率 &amp;lambda; 就越小；医疗水平越高，恢复系数 &amp;mu;  就越大。</li>
</ol>
<p>这样子就提高了1&#x2F; &amp;sigma; 阈值 。提高卫生和医疗水平有助于控制传染病的蔓延</p>
<ol start="2">
<li>降低s<sub>0</sub>来控制传染病的蔓延. 由 s<sub>0 </sub>+ i<sub>0 </sub>+ r<sub>0</sub> &#x3D; n  可知道，减少s<sub>0</sub>可以通过提高r<sub>0</sub> 来实现。</li>
</ol>
<h4 id="参数估计-1"><a href="#参数估计-1" class="headerlink" title="参数估计"></a>参数估计</h4><p>参数&amp;sigma; 的值可由实际的数据估计得：<br>$$<br>令s_\infty 与 i_\infty 分别是传染病流行结束后的 健康者人数 和 患者人数。<br>$$<br>当流行结束后，患者都将转化为免疫者<br>$$<br>i_\infty &#x3D; 0 \ ;\ \therefore i_\infty&#x3D;i_0+s_0-s_\infty+\frac{1}{\sigma}(ln\frac{s_\infty}{s_0}),<br>$$<br>解的：<br>$$<br>\sigma&#x3D;-\frac{lns_0-lns_\infty}{s_\infty-i_0-s_0}<br>$$<br>于是，当已知某地区某种传染病流行结束后的 $s_\infty$ 时，则可以算出 $\sigma$ ， $\sigma$ 值可再今后同种传染病和同类地区的研究中使用。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>1950年上海市某全托幼儿所发生的一起水痘流行过程中各代病例数、易感染者数及间隔时间如下，应用K-M模型进行模拟，并对模拟结果进行讨论. 该所儿童总人数n 为196人；既往患过水痘而此次未感染者40人，查不出水痘患病史而本次流行期间感染水痘者96人，既往无明确水痘史，本次又未感染的幸免者60人. 全部流行期间79人，病例成代出现，每代间隔约15人. </p>
<center>表1 某全托幼儿所水痘流行过程中各代病例数


<table>
<thead>
<tr>
<th>代</th>
<th>病例数</th>
<th>易感染者</th>
<th>间隔时间&#x2F;天</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>155</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>153</td>
<td>15</td>
</tr>
<tr>
<td>3</td>
<td>14</td>
<td>139</td>
<td>32</td>
</tr>
<tr>
<td>4</td>
<td>38</td>
<td>101</td>
<td>46</td>
</tr>
<tr>
<td>5</td>
<td>34</td>
<td>67</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>33</td>
<td></td>
</tr>
<tr>
<td>合计</td>
<td>96</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>以初始值s<sub>0</sub>，$s_\infty$代入$\sigma&#x3D;-\frac{lns_0-lns_\infty}{s_\infty-i_0-s_0}$ 可得  $ \sigma&#x3D;0.0099 $ . </p>
<p>将代入$i&#x3D;i_0+s_0-s+\frac{1}{\sigma}(ln\frac{s}{s_0})$ 可得该流行过程的模拟结果如下表2.</p>
<center>表2 用K-M模型模拟水痘流行过程的数值解 


<table>
<thead>
<tr>
<th>易感染者</th>
<th>155</th>
<th>153</th>
<th>139</th>
<th>101</th>
</tr>
</thead>
<tbody><tr>
<td>病例数i</td>
<td>1</td>
<td>1.7</td>
<td>6.0</td>
<td>11.7</td>
</tr>
</tbody></table>
<h5 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s0=<span class="number">155</span></span><br><span class="line">i0=<span class="number">1.0</span></span><br><span class="line">s_inf=<span class="number">60.0</span></span><br><span class="line"></span><br><span class="line">sigma=(np.log(s0)-np.log(s_inf))/(s0+i0-s_inf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sigma=&#x27;</span>,sigma,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">S=np.array([<span class="number">155</span>,<span class="number">153</span>,<span class="number">139</span>,<span class="number">101</span>])</span><br><span class="line">I=(s0+i0)-S+<span class="number">1</span>/sigma * np.log(S/s0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;所求的解为：&#x27;</span>, I)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="插值与拟合"><a href="#插值与拟合" class="headerlink" title="插值与拟合"></a>插值与拟合</h3><p>​        在数学建模过程中，通常要处理由试验、测量得到的大量数据或一些过于复杂而不方便计算的函数表达式，针对此情况，很自然的想法就是，构造一个简单的函数作为要考察数据或复杂函数的近似. 插值和拟合就可以解决这样的问题</p>
<p>​        给定一组数据，需要确定满足特定要求的曲线（或曲面），如果所求曲线通过所给定的有限个数据点，这就是<strong>插值</strong>. 有时由于给定的数据存在测量误差，往往具有一定的随机性. 因而，通过所有数据点求曲线不现实也不必要. 如果不要求曲线通过所有数据点，而是要求它反映对象整体的变化态势，得到简单实用的近似函数，这就是<strong>拟合</strong>.</p>
<h4 id="拟合函数的选择"><a href="#拟合函数的选择" class="headerlink" title="拟合函数的选择"></a>拟合函数的选择</h4><p>数据拟合时，首要也是最关键的一步就是恰当的拟合函数. 如果能够根据问题的背景通过机理分析得到变量之间的函数关系，那么只需估计相应的参数即可. 但很多情况下，问题的机理并不清楚. 此时，一个较为自然的方法是先做出<strong>数据的散点图</strong>，从直观上判断应选用什么样的拟合函数.</p>
<ul>
<li><p>如果数据分布<strong>接近于直线</strong>，则拟合函数宜选用<strong>线性函数</strong> $f(x)&#x3D;a_1x+a_2$ ;</p>
</li>
<li><p>如果数据分布接近于<strong>抛物线</strong>，则拟合函数宜选用二次多项式  $f(x)&#x3D;a_1x^2+a_2x+a_3$ ;</p>
</li>
<li><p>如果数据分布特点是开始上升较快随后逐渐变缓，则宜选用双曲线型函数或指数型函数，即用 $f(x)&#x3D;\frac{x}{a_1x+a_2}$ 或  $ f(x)&#x3D;a_1e^{-\frac{a_2}{x}}$ ; </p>
</li>
<li><p>如果数据分布特点是开始下降较快随后逐渐变缓，则宜选用$f(x)&#x3D;\frac{1}{a_1x+a_2}$,$f(x)&#x3D;\frac{1}{a_1x^2+a_2}$ , $f(x)&#x3D;a_1e^{-a_2x}$</p>
</li>
<li><p>常被选用的非线性拟合函数有$y&#x3D;a_1+a_2\ lnx$  ，S形曲线函数为$y&#x3D;\frac{1}{a+be^{-x}}$</p>
</li>
</ul>
<h4 id="数据拟合python程序实现："><a href="#数据拟合python程序实现：" class="headerlink" title="数据拟合python程序实现："></a>数据拟合python程序实现：</h4><p>python中有多个模块的多种方法可以进行拟合未知参数. </p>
<p>Numpy中的多项式拟合函数polyfit</p>
<p>Scipy.optimize中的leastsq（最小二乘）、curve_fit</p>
<h5 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h5><p>对下表1的数据进行拟合，并求当x&#x3D;0.25 ,0.35 时, y的预测值.</p>
<center>表1 待拟合数据


<table>
<thead>
<tr>
<th>x</th>
<th>0</th>
<th>0.1</th>
<th>0.2</th>
<th>0.3</th>
<th>0.4</th>
<th>0.5</th>
<th>0.6</th>
<th>0.7</th>
<th>0.8</th>
<th>0.9</th>
<th>1.0</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>-0.447</td>
<td>1.978</td>
<td>3.28</td>
<td>6.16</td>
<td>7.08</td>
<td>7.34</td>
<td>7.66</td>
<td>9.56</td>
<td>9.48</td>
<td>9.30</td>
<td>11.2</td>
</tr>
</tbody></table>
<p>解:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示点</span></span><br><span class="line"><span class="keyword">import</span> numpy  <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x=np.arange(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0.1</span>)</span><br><span class="line"><span class="comment">#print(x)</span></span><br><span class="line">y=np.array([-<span class="number">0.447</span>,<span class="number">1.978</span>,<span class="number">3.28</span>,<span class="number">6.16</span>, <span class="number">7.08</span>, <span class="number">7.34</span>, <span class="number">7.66</span>, <span class="number">9.56</span>, <span class="number">9.48</span>, <span class="number">9.30</span>, <span class="number">11.2</span>])</span><br><span class="line">plt.plot(x,y,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="C:\Kuai8Games\Code\推文\图片\shumo4.png" alt="shumo4"></p>
<p>可以看出,接近于直线或抛物线.这里抛物线更加准确.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy  <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x0=np.arange(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0.1</span>) <span class="comment">#设置初始为0,末尾1.1以前,步长0.1</span></span><br><span class="line">y0=np.array([-<span class="number">0.447</span>,<span class="number">1.978</span>,<span class="number">3.28</span>,<span class="number">6.16</span>, <span class="number">7.08</span>, <span class="number">7.34</span>, <span class="number">7.66</span>, <span class="number">9.56</span>, <span class="number">9.48</span>, <span class="number">9.30</span>, <span class="number">11.2</span>])</span><br><span class="line">p=np.polyfit(x0,y0,<span class="number">2</span>) <span class="comment">#拟合二次多项式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合二次多项式的从高次幂到低次幂系数分别为：&#x27;</span>,p)</span><br><span class="line">yhat=np.polyval(p,[<span class="number">0.25</span>,<span class="number">0.35</span>])  <span class="comment">#令x= 0.25,0.35 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测值分别为：&#x27;</span>,yhat)</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">plt.plot(x0,y0,<span class="string">&#x27;*&#x27;</span>,x0,np.polyval(p,x0),<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="C:\Kuai8Games\Code\推文\图片\shumo5.png" alt="shumo5"></p>
<p>拟合二次多项式的从高次幂到低次幂系数分别为： [-9.81083916 20.12929371 -0.03167133]<br>预测值分别为： [4.38747465 5.81175367]</p>
<h5 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h5><p>对例1的数据用  <strong>curve_fit 函数</strong>拟合二次多项式，并求预测值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">y=<span class="keyword">lambda</span> x,a,b,c: a*x**<span class="number">2</span>+b*x+c</span><br><span class="line">x0=np.arange(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0.1</span>)</span><br><span class="line">y0=np.array([-<span class="number">0.447</span>,<span class="number">1.978</span>,<span class="number">3.28</span>,<span class="number">6.16</span>, <span class="number">7.08</span>, <span class="number">7.34</span>, <span class="number">7.66</span>, <span class="number">9.56</span>, <span class="number">9.48</span>, <span class="number">9.30</span>, <span class="number">11.2</span>])</span><br><span class="line"></span><br><span class="line">popt,pcov=curve_fit(y,x0,y0) <span class="comment">#返回值popt是拟合的参数，pcov是参数的协方差矩阵</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合的参数值为：&#x27;</span>,popt)</span><br><span class="line"><span class="comment">#此处*popt是序列解包，就是把列表popt的包装解开，得到几个元素，作为y的参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x=0.25时的预测值为：&#x27;</span>,y(<span class="number">0.25</span>,*popt)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x=0.35时的预测值为：&#x27;</span>,y(<span class="number">0.35</span>,*popt))</span><br><span class="line"></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>,family=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.plot(x0,y0,<span class="string">&#x27;*&#x27;</span>,x0,y(x0,*popt))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h5 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h5><p>用下标数据拟合二元函数  :  $z&#x3D;ae^{bx}+cy^2$ </p>
<table>
<thead>
<tr>
<th>x</th>
<th>6</th>
<th>2</th>
<th>6</th>
<th>7</th>
<th>4</th>
<th>2</th>
<th>5</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>4</td>
<td>9</td>
<td>5</td>
<td>3</td>
<td>8</td>
<td>5</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>z</td>
<td>5</td>
<td>2</td>
<td>1</td>
<td>9</td>
<td>7</td>
<td>4</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"></span><br><span class="line">x0=np.array([<span class="number">6</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>])</span><br><span class="line">y0=np.array([<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>])</span><br><span class="line">z0=np.array([<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">xy0=np.vstack((x0,y0))  <span class="comment"># 将x和y变为二维数组</span></span><br><span class="line"><span class="comment">#print(xy0)</span></span><br><span class="line"></span><br><span class="line">z_fun=<span class="keyword">lambda</span> t,a,b,c: a*np.exp(b*t[<span class="number">0</span>]) + c*t[<span class="number">1</span>]**<span class="number">2</span></span><br><span class="line">popt,pcov=curve_fit(z_fun,xy0,z0) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a,b,c的拟合值为：&#x27;</span>,popt)</span><br></pre></td></tr></table></figure>



<h5 id="例题四"><a href="#例题四" class="headerlink" title="例题四"></a>例题四</h5><p>利用模拟数据拟合曲面 $z&#x3D;e^{-\frac{(x-\mu_1)^2+(y-\mu_2)^2}{2\sigma^2}}$ , 并画出拟合曲面的图形</p>
<p>其中$\mu_1&#x3D;1$,$\mu_2 &#x3D;2$,$\sigma&#x3D;3$，生成加噪声的模拟数据$\mu_1&#x3D;1.0097$,$\mu_2 &#x3D;1.9968$,$\sigma&#x3D;3.0028$</p>
<p>画出拟合曲面:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">m=<span class="number">200</span></span><br><span class="line">n=<span class="number">300</span></span><br><span class="line">x=np.linspace(-<span class="number">6</span>,<span class="number">6</span>,m)  	<span class="comment">#生成200个点</span></span><br><span class="line">y=np.linspace(-<span class="number">8</span>,<span class="number">8</span>,n)  	<span class="comment">#生成300个点</span></span><br><span class="line">x2,y2=np.meshgrid(x,y) 	<span class="comment">#相当于在xoy平面生成所有的网格点</span></span><br><span class="line"></span><br><span class="line">x3=np.reshape(x2,(<span class="number">1</span>,-<span class="number">1</span>)) <span class="comment">#把x2的数据转换成一行，1表示1行，-1是通配符</span></span><br><span class="line">y3=np.reshape(y2,(<span class="number">1</span>,-<span class="number">1</span>)) </span><br><span class="line">xy=np.vstack((x3,y3)) 	<span class="comment">#叠加成两行的数组</span></span><br><span class="line"><span class="comment">#print(&#x27;xy=&#x27;,xy) #不懂vstack函数时可以用print输出观察，然后再注释掉</span></span><br><span class="line"></span><br><span class="line">pfun=<span class="keyword">lambda</span> t,mu1,mu2,sigma: np.exp(-((t[<span class="number">0</span>]-mu1)**<span class="number">2</span>+(t[<span class="number">1</span>]-mu2)**<span class="number">2</span>)/(<span class="number">2</span>*sigma**<span class="number">2</span>))</span><br><span class="line">z=pfun(xy,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">zr=z+<span class="number">0.2</span>*np.random.normal(size=z.shape) <span class="comment">#加了噪声的数据</span></span><br><span class="line"></span><br><span class="line">popt,pcov=curve_fit(pfun,xy,zr) <span class="comment">#拟合参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;三个参数的拟合值分别为：&#x27;</span>,popt)</span><br><span class="line">zn=pfun(xy,*popt) <span class="comment">#计算拟合函数的值</span></span><br><span class="line"></span><br><span class="line">zn2=np.reshape(zn,x2.shape)</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">ax=plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>) <span class="comment">#创建一个三维坐标轴对象</span></span><br><span class="line">ax.plot_surface(x2,y2,zn2,cmap=<span class="string">&#x27;gist_rainbow&#x27;</span>) <span class="comment">#gist_rainbow是曲面颜色参数</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="C:\Kuai8Games\Code\推文\图片\shumo6.png" alt="shumo6"></p>
<h3 id="数学建模之回归分析"><a href="#数学建模之回归分析" class="headerlink" title="数学建模之回归分析"></a>数学建模之回归分析</h3><h4 id="多元线性回归模型"><a href="#多元线性回归模型" class="headerlink" title="多元线性回归模型"></a>多元线性回归模型</h4><p>通过对变量实际观测的分析、计算，建立一个变量与另一组变量的定量关系即回归方程，经统计检验认为回归效果显著后，可用于<strong>预测与控制</strong></p>
<p>设随机变量 $y$ 与变量 $x_1,x_2,…,x_m$ 有关则其 $m$ 元线性回归模型为：<br>$$<br>y&#x3D;\beta_0+\beta_1x_1+…+\beta_mx_m+\varepsilon<br>$$<br>$\varepsilon$是随机误差服从正态分布  $N(0,\sigma^2)$  ,$\beta_0,\beta_1,…,\beta_m$ 为回归系数。</p>
<h4 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h4><h5 id="由观察确定回归系数"><a href="#由观察确定回归系数" class="headerlink" title="由观察确定回归系数"></a>由观察确定回归系数</h5><p>$\beta_0,\beta_1,…,\beta_m$  的估计值  $b_0,b_1,…,b_m$</p>
<p>将 $n$ 组数据  $(y_i,x_{i1},..,x_{im})$  ,$i&#x3D;1,…,n (n&gt;m)$  带入 $y&#x3D;\beta_0+\beta_1x_1+…+\beta_mx_m+\varepsilon$ 有<br>$$<br>y_i&#x3D;\beta_0+\beta_1x_{i1}+…+\beta_mx_{im}+\varepsilon_i<br>$$</p>
<p>$$<br>记\ \ X&#x3D;<br>\begin{bmatrix}<br>1	   &amp; x_{11} &amp; x_{12} &amp; \cdots  &amp; x_{1m}\<br>1	   &amp; x_{21} &amp; x_{22} &amp; \cdots  &amp; x_{2m}\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>1	   &amp; x_{n1} &amp; x_{n2} &amp; \cdots  &amp; x_{nm}<br>\end{bmatrix},</p>
<p>Y&#x3D;<br>\begin{bmatrix}<br>y_{1} \<br>y_{2} \<br>\vdots \<br>y_{n}<br>\end{bmatrix},</p>
<p>\varepsilon&#x3D;<br>\begin{bmatrix}<br>\varepsilon_1 \ \varepsilon_2 \ \cdots \varepsilon_n<br>\end{bmatrix}^T,</p>
<p>\beta&#x3D;<br>\begin{bmatrix}<br>\beta_1 \ \beta_2 \ \cdots \beta_n<br>\end{bmatrix}^T.<br>$$</p>
<p> 则正规方程组为：$Y&#x3D;X \ \beta + \varepsilon$ , 正规方程组的回归系数的最小二乘法估计 $\hat{\beta}$ 为：<br>$$<br>\hat{\beta} &#x3D; (X^TX)^{-1}X^TY<br>$$<br>将$\hat{\beta}&#x3D;[b_0,b_1,…,b_m]$ 带入$y&#x3D;\beta_0+\beta_1x_1+…+\beta_mx_m+\varepsilon$   得到方程：<br>$$<br>y&#x3D;b_0+b_1x_1+…+b_mx_m<br>$$<br>将数据代入，则得 $y$ 的估计值:<br>$$<br>\hat{y} &#x3D; b_0+b_1x_1+…+b_mx_m<br>$$<br>估计值的残差平方和为:<br>$$<br>SSE&#x3D;\sum_{i&#x3D;1}^{n}e_i^2&#x3D;\sum_{i&#x3D;1}^{n}(y_i-\hat{y_i})^2<br>$$<br>回归平方和为:<br>$$<br>SSR&#x3D;\sum_{i&#x3D;1}^{n}(\overline{y}-\hat{y_i})^2<br>$$</p>
<h5 id="对线性关系、自变量的显著性进行统计检验"><a href="#对线性关系、自变量的显著性进行统计检验" class="headerlink" title="对线性关系、自变量的显著性进行统计检验"></a>对线性关系、自变量的显著性进行统计检验</h5><p>上面完美建立的线性回归方程是假定了变量$y$与$x_1,x_2,…,x_m$ 是有关系的，但真的是否有线性关系吗？需要做统计检验。</p>
<p>首先，因变量 $y$ 与 自变量$x_1,x_2,…,x_m$ 之间关系的检验方式，令原假设成立：<br>$$<br>H_0:\beta_1&#x3D;\beta_2&#x3D;…&#x3D;\beta_m&#x3D;0<br>$$<br>选择统计量$F&#x3D;\frac{SSR&#x2F;m}{SSE&#x2F;(n-m-1)}&#x3D;\frac{SSR\cdot(n-m-1)}{SSE\cdot  m}$~$F(m,n-m-1)$ 进行假设检验，对显著性水平$\alpha$ 和上分位数$F_\alpha(m,n-m-1)$ ,检验准则为：</p>
<ul>
<li><p>若 $ F&gt;F_\alpha(m,n-m-1)$,回归方程显著。</p>
</li>
<li><p>若 $ F&lt;F_\alpha(m,n-m-1)$,回归方程效果不显著。</p>
</li>
</ul>
<p>也可以采用复判定系数(也称拟合优度) $R^2&#x3D;\frac{SSR}{SSR+SSE}$ 作为权衡  $y$ 与 $x_1,x_2,…,x_m$ 相关程度的指标，$R&#x3D;\sqrt{R^2}$成为复相关系数，R越大，  $y$ 与 $x_1,x_2,…,x_m$ 相关关系越密切，通常R&gt;0.8&#x2F;0.9才认为相关关系成立。</p>
<h5 id="利用回归方程进行预测"><a href="#利用回归方程进行预测" class="headerlink" title="利用回归方程进行预测"></a>利用回归方程进行预测</h5><p>对于给定的$x_1^{(0)},x_2^{(0)},…,x_m^{(0)},$ 代入回归方程: $y&#x3D;b_0+b_1x_1+…+b_mx_m $ 得：<br>$$<br>\hat{y_0} &#x3D; b_0+b_1x_1^{(0)}+…+b_mx_m^{(0)},<br>$$<br>用 $\hat{y_0}$做 $y$ 在点$x_1^{(0)},x_2^{(0)},…,x_m^{(0)}$ 的预测值。</p>
<p>也可以进行区间的估计，记$s&#x3D;\sqrt{\frac{SSE}{n-m-1}} ， x_0&#x3D;[1,x_1^{(0)},x_	2^{(0)},…,x_m^{(0)}]$ , 则$y_0$的置信度为$1-\alpha$ 的车预测区间为：<br>$$<br>(\ \hat{y}-t_{1-\alpha&#x2F;2}(n-m-1)s\sqrt{1+x_0^T(X^TX)^{-1}x_0}\ ,\ \hat{y}+t_{1-\alpha&#x2F;2}(n-m-1)s\sqrt{1+x_0^T(X^TX)^{-1}x_0}\ )<br>$$</p>
<h4 id="例题一："><a href="#例题一：" class="headerlink" title="例题一："></a>例题一：</h4><p>水泥凝固时放出的热量 y 与水泥中两种主要化学分成 x<sub>1</sub>,x<sub>2</sub> 有关，今测得一组数据如表1所示，试确定一个线性回归模型$y&#x3D;a_0+a_1x_1+a_2x_2$.</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$y$</th>
<th>序号</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$y$</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>7</td>
<td>26</td>
<td>78.5</td>
<td>8</td>
<td>1</td>
<td>31</td>
<td>72.5</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>29</td>
<td>74.3</td>
<td>9</td>
<td>2</td>
<td>54</td>
<td>93.1</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>56</td>
<td>104.3</td>
<td>10</td>
<td>21</td>
<td>47</td>
<td>115.9</td>
</tr>
<tr>
<td>4</td>
<td>11</td>
<td>31</td>
<td>87.6</td>
<td>11</td>
<td>1</td>
<td>40</td>
<td>83.8</td>
</tr>
<tr>
<td>5</td>
<td>7</td>
<td>52</td>
<td>95.9</td>
<td>12</td>
<td>11</td>
<td>66</td>
<td>113.3</td>
</tr>
<tr>
<td>6</td>
<td>11</td>
<td>55</td>
<td>109.2</td>
<td>13</td>
<td>10</td>
<td>68</td>
<td>109.4</td>
</tr>
<tr>
<td>7</td>
<td>3</td>
<td>71</td>
<td>102.7</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="程序一：利用模块sklearn-linear-model中的函数LinearRegression求解"><a href="#程序一：利用模块sklearn-linear-model中的函数LinearRegression求解" class="headerlink" title="程序一：利用模块sklearn.linear_model中的函数LinearRegression求解"></a>程序一：利用模块sklearn.linear_model中的函数LinearRegression求解</h5><p>解：求得回归模型为<br>$$<br>y&#x3D;52.5773+1.4683x_1+0.6623x_2<br>$$<br>模型的拟合优度$R^2&#x3D;0.9787$,说明拟合效果很好.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">a = np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡17_例2.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">md = LinearRegression().fit(a[:,:<span class="number">2</span>],a[:,<span class="number">2</span>]) <span class="comment">#构建并拟合模型</span></span><br><span class="line"><span class="comment">#上行切片表示用数据的所有行、前两列数据作自变量，所有行、最后一列的数据作因变量</span></span><br><span class="line">y=md.predict(a[:,:<span class="number">2</span>])   <span class="comment">#求预测值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测值为&#x27;</span>,y)      <span class="comment">#输出拟合好后的预测值</span></span><br><span class="line">b0=md.intercept_        <span class="comment">#输出回归模型中的常数项</span></span><br><span class="line">b12=md.coef_            <span class="comment">#输出回归模型的回归系数（常数项以外）</span></span><br><span class="line">R2=md.score(a[:,:<span class="number">2</span>],a[:,<span class="number">2</span>]) <span class="comment">#计算R^2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;回归模型的常数项为&#x27;</span>,b0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;回归模型的自变量系数为&#x27;</span>,b12)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度R^2=&#x27;</span>,R2)</span><br></pre></td></tr></table></figure>



<h4 id="线性回归模型的正则化求解"><a href="#线性回归模型的正则化求解" class="headerlink" title="线性回归模型的正则化求解"></a>线性回归模型的正则化求解</h4><p>在多元线性回归中，解释变量$x_1,x_2,…,x_m$之间出现严重的多重线性时，普通的最小二乘法估计模型参数，往往参数估计方差太大，使普通最小二乘法的效果很不理想. 为改进线性回归模型，采用线性回归正则化方法，岭回归和Lasso回归是其中的两种方法</p>
<p>这里我认为是机器学习中次方过大，导致过拟合，于是得到的函数干扰太大拟合效果不好。</p>
<h5 id="法一：岭回归"><a href="#法一：岭回归" class="headerlink" title="法一：岭回归"></a>法一：岭回归</h5><h6 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h6><p>Malinvand于1966年提出的研究法国经济问题的一组数据，如下表1. 所考虑的因变量为进口总额<strong>y</strong> , 三个解释变量分别为：国内总产值<strong>x<sub>1</sub><strong>、储存量</strong>x<sub>2</sub><strong>、总消费</strong>x<sub>3</sub></strong>(单位均为10亿法郎). 建立<strong>y与x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub>的关系</strong></p>
<table>
<thead>
<tr>
<th align="center">年份</th>
<th align="center">$x_1$</th>
<th align="center">$x_2$</th>
<th align="center">$x_3$</th>
<th align="center">$y$</th>
<th align="center">年份</th>
<th align="center">$x_1$</th>
<th align="center">$x_2$</th>
<th align="center">$x_3$</th>
<th align="center">$y$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1949</td>
<td align="center">149.3</td>
<td align="center">4.2</td>
<td align="center">108.1</td>
<td align="center">15.9</td>
<td align="center">1955</td>
<td align="center">202.1</td>
<td align="center">2.1</td>
<td align="center">146.0</td>
<td align="center">22.7</td>
</tr>
<tr>
<td align="center">1950</td>
<td align="center">171.5</td>
<td align="center">4.1</td>
<td align="center">114.8</td>
<td align="center">16.4</td>
<td align="center">1956</td>
<td align="center">212.4</td>
<td align="center">5.6</td>
<td align="center">154.1</td>
<td align="center">26.5</td>
</tr>
<tr>
<td align="center">1951</td>
<td align="center">175.5</td>
<td align="center">3.1</td>
<td align="center">123.2</td>
<td align="center">19.0</td>
<td align="center">1957</td>
<td align="center">226.1</td>
<td align="center">5.0</td>
<td align="center">162.3</td>
<td align="center">28.1</td>
</tr>
<tr>
<td align="center">1952</td>
<td align="center">180.8</td>
<td align="center">3.1</td>
<td align="center">126.9</td>
<td align="center">19.1</td>
<td align="center">1958</td>
<td align="center">231.9</td>
<td align="center">5.1</td>
<td align="center">164.3</td>
<td align="center">27.6</td>
</tr>
<tr>
<td align="center">1953</td>
<td align="center">190.7</td>
<td align="center">1.1</td>
<td align="center">132.1</td>
<td align="center">18.8</td>
<td align="center">1959</td>
<td align="center">239.0</td>
<td align="center">0.7</td>
<td align="center">167.6</td>
<td align="center">26.3</td>
</tr>
<tr>
<td align="center">1954</td>
<td align="center">202.1</td>
<td align="center">2.2</td>
<td align="center">137.7</td>
<td align="center">20.4</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h6 id="用最小二乘估计建立模型"><a href="#用最小二乘估计建立模型" class="headerlink" title="用最小二乘估计建立模型"></a>用最小二乘估计建立模型</h6><p>对于上述问题，可以直接用普通的最小二乘估计建立$y$关于三个解释变量x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub> 的回归方程为$y&#x3D;-8.6203-0.0742x_1+0.5104x_2+0.3116x_3$ , 并且模型的统计检验指标都相当好，但是$x_1$的系数为负数，这是不符合经济意义的，因为法国是一个原材料进口国，当国内总产值$x_1$增大时，进口总额$y$肯定也会增加，所以符号应该时正的。原因可能是三个自变量x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub> 之间存在多重共线性。</p>
<p>计算$x_1,x_2,x_3$的相关系数矩阵为：<br>$$<br>R&#x3D;<br>\begin{pmatrix}<br>1		&amp;  -0.0329	&amp; 0.9869\<br>-0.0329 &amp;  1		&amp; 0.0357\<br>0.9869	&amp;  0.0357	&amp; 1<br>\end{pmatrix}<br>$$<br>可以看到$x_1\text{与}x_2$的相关系数高达0.9869，说明$x_1与x_3$基本线性相关，若将$x_3$看为因变量，$x_1$看作解释变量，那么$x_3$关于$x_1$的一元线性回归方程为：<br>$$<br>x_3&#x3D;-4.9632+0.7297x_1<br>$$<br>说明$x_3与x_1$之间存在着多重共线性关系。</p>
<h6 id="利用statsmodels库求解线性回归分析"><a href="#利用statsmodels库求解线性回归分析" class="headerlink" title="利用statsmodels库求解线性回归分析"></a>利用statsmodels库求解线性回归分析</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基于数组构建并拟合模型的调用格式为:</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line">sm.OLS(y,X).fit()</span><br></pre></td></tr></table></figure>

<p>程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line">a=np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡18_例1.txt&#x27;</span>)</span><br><span class="line"><span class="comment">#print(a)</span></span><br><span class="line"><span class="comment">#print(a[:5])</span></span><br><span class="line">x=a[:,:<span class="number">3</span>] <span class="comment">#提取自变量观察值矩阵</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">XG=sm.add_constant(x) <span class="comment">#增加第一列全部元素为1得到增广矩阵</span></span><br><span class="line"><span class="built_in">print</span>(XG)</span><br><span class="line"></span><br><span class="line">md=sm.OLS(a[:,<span class="number">3</span>],XG).fit()<span class="comment">#构建并拟合模型</span></span><br><span class="line">b=md.params <span class="comment">#提取所有回归系数</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;$&#x27;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">y=md.predict(XG) <span class="comment">#求已知自变量值的预测值</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;$&#x27;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(md.summary()) <span class="comment"># 输出模型的所有结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;相关系数矩阵：\n&#x27;</span>,np.corrcoef(x.T))</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成新的矩阵，第1列全部是1，第2列是a的第1列数据</span></span><br><span class="line">X1=sm.add_constant(a[:,<span class="number">0</span>])</span><br><span class="line"><span class="comment">#print(X1)</span></span><br><span class="line">md1=sm.OLS(a[:,<span class="number">2</span>],X1).fit() <span class="comment">#构建并拟合模型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;回归系数为：&#x27;</span>,md1.params)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$ print(md.summary()) #这一步中输出为：</span><br><span class="line"></span><br><span class="line">UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=11</span><br><span class="line">warnings.warn(&quot;kurtosistest only valid for n&gt;=20 ... continuing &quot;</span><br><span class="line">                   </span><br><span class="line">                   OLS Regression Results              </span><br><span class="line">====================================================================</span><br><span class="line">Dep. Variable:			y         R-squared:                  0.996</span><br><span class="line">Model:				  OLS         Adj. R-squared:             0.994</span><br><span class="line">Method:     Least Squares         F-statistic:                542.0</span><br><span class="line">Date:    Wed, 12 Aug 2020         Prob (F-statistic):      1.20e-08</span><br><span class="line">Time:            11:52:08         Log-Likelihood:           -1.7480</span><br><span class="line">No. Observations:      11         AIC:                        11.50</span><br><span class="line">Df Residuals:           7         BIC:                        13.09</span><br><span class="line">Df Model:               3                                         </span><br><span class="line">Covariance Type:nonrobust    </span><br><span class="line"></span><br><span class="line">#本人注释：1. Method: Least Squares(最小二乘法)  </span><br><span class="line">		 2.	R-squared: 0.996(复判定系数或叫拟合优度R^2,越高拟合越好)</span><br><span class="line"></span><br><span class="line">====================================================================</span><br><span class="line">          coef    std err      t       P&gt;|t|      [0.025      0.975]</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">const    -8.6203    0.897    -9.611     0.000    -10.741     -6.499</span><br><span class="line">x1       -0.0742    0.028    -2.691     0.031    -0.139      -0.009</span><br><span class="line">x2        0.5104    0.075     6.781     0.000     0.332       0.688</span><br><span class="line">x3        0.3116    0.037     8.357     0.000     0.223       0.400</span><br><span class="line">====================================================================</span><br><span class="line">Omnibus:           5.258        Durbin-Watson:              2.400</span><br><span class="line">Prob(Omnibus):     0.072        Jarque-Bera (JB):           2.250</span><br><span class="line">Skew:              1.080        Prob(JB):                   0.325</span><br><span class="line">Kurtosis:          3.495        Cond. No.                2.05e+03</span><br><span class="line"></span><br><span class="line">#本人注释：1.coef所对应的那一列 拟合系数</span><br><span class="line"></span><br><span class="line">====================================================================</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line">[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</span><br><span class="line">[2] The condition number is large, 2.05e+03. This might indicate that there are</span><br><span class="line">strong multicollinearity or other numerical problems.</span><br><span class="line"></span><br><span class="line">相关系数矩阵：</span><br><span class="line"> [[ 1.         -0.03291436  0.98690551]---&gt;&gt;0.9869很高x1与x2相关性很大</span><br><span class="line"> [-0.03291436  1.          0.03567322]</span><br><span class="line"> [ 0.98690551  0.03567322  1.        ]]</span><br><span class="line"> </span><br><span class="line">回归系数为： [-4.96322784  0.72966696]  ---&gt; x3=-4.963+0.72967*x1</span><br></pre></td></tr></table></figure>



<h5 id="改进的模型：岭回归方程"><a href="#改进的模型：岭回归方程" class="headerlink" title="改进的模型：岭回归方程"></a>改进的模型：岭回归方程</h5><p>为了消除变量之间的多重共线性关系的影响，即消除最小二乘解的参数估计$\hat{\beta} &#x3D; (X^TX)^{-1}X^TY中X^TY的奇异性$，采用岭回归模型，即参数估计为：<br>$$<br>\hat{\beta} (k)&#x3D; (X^TX+kI)^{-1}X^TY<br>$$<br>其中，k是岭参数.   岭参数<img src="file:///C:/Users/墨羽辰/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img">的选择有岭迹法和均方误差法.</p>
<p>求上面那道例题的岭回归方程：</p>
<p>我们可以解得k&#x3D;0.15时，取得较好的拟合效果。对应的标准化岭回归方程为：<br>$$<br>\hat{y}^*&#x3D;0.0610x_1+0.2179x_2+0.8926x_3<br>$$<br>将标准化的回归方程还原后得:<br>$$<br>\hat{y}&#x3D;-9.5320+0.0410x_1+0.6231x_2+0.1520x_3<br>$$<br>拟合优度为 0.9899</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge,RidgeCV</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> zscore</span><br><span class="line"></span><br><span class="line">a=np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡18_例1.txt&#x27;</span>)</span><br><span class="line">n=a.shape[<span class="number">1</span>]-<span class="number">1</span>  <span class="comment">#设置自变量的总个数</span></span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line">aa=zscore(a) <span class="comment">#数据的标准化</span></span><br><span class="line">x=aa[:,:n]   <span class="comment">#提出自变量观察值矩阵 取前三列x1\x2\x3</span></span><br><span class="line">y=aa[:,n]    <span class="comment">#提出因变量矩阵      取最后一列y</span></span><br><span class="line">b=[]         <span class="comment">#用于存储回归系数的空列表</span></span><br><span class="line"></span><br><span class="line">kk=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)  <span class="comment">#设置的不同k值</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> kk:              <span class="comment">#循环迭代的不同k值</span></span><br><span class="line">    md=Ridge(alpha=k).fit(x,y)</span><br><span class="line">    b.append(md.coef_)    <span class="comment">#系数保存在列表中</span></span><br><span class="line"></span><br><span class="line">st=[<span class="string">&#x27;s-r&#x27;</span>,<span class="string">&#x27;*-k&#x27;</span>,<span class="string">&#x27;p-b&#x27;</span>]       <span class="comment">#下面画图的控制字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.plot(kk,np.array(b)[:,i],st[i]) <span class="comment">#作图</span></span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>,<span class="string">&#x27;x3&#x27;</span>],fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">mdcv=RidgeCV(alphas=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)).fit(x,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优alpha=&#x27;</span>,mdcv.alpha_)</span><br><span class="line"></span><br><span class="line"><span class="comment">#md0=Ridge(mdcv.alpha_).fit(x,y) #构建并拟合模型.先选择此行命令，得到最佳k值，但拟合出的x1的系数是负</span></span><br><span class="line">md0=Ridge(<span class="number">0.15</span>).fit(x,y)  <span class="comment">#x1的系数是负，所以这里主观选择k=0.15时得到的拟合优度高，而且变量的拟合系数都是正的</span></span><br><span class="line">cs0=md0.coef_ <span class="comment">#提取标准化数据的回归系数b1,b2,b3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准化数据的所有回归系数为：&#x27;</span>,cs0)</span><br><span class="line"></span><br><span class="line">mu=np.mean(a,axis=<span class="number">0</span>) <span class="comment">#计算所有指标的均值</span></span><br><span class="line">s=np.std(a,axis=<span class="number">0</span>,ddof=<span class="number">1</span>)  <span class="comment">#计算所有的标准差</span></span><br><span class="line">params=[mu[-<span class="number">1</span>]-s[-<span class="number">1</span>]*<span class="built_in">sum</span>(cs0*mu[:-<span class="number">1</span>]/s[:-<span class="number">1</span>]),s[-<span class="number">1</span>]*cs0/s[:-<span class="number">1</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数据的回归系数为：&#x27;</span>,params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度为&#x27;</span>,md0.score(x,y))</span><br></pre></td></tr></table></figure>



<h4 id="lasson-回归"><a href="#lasson-回归" class="headerlink" title="lasson  回归"></a>lasson  回归</h4><h5 id="数学原理简介"><a href="#数学原理简介" class="headerlink" title="数学原理简介"></a>数学原理简介</h5><p>多元回归中的普通最小二乘法是拟合参数向量$\beta$，使得$\left |X\beta-Y \right |^2_2$达到最小值. 岭回归是选择了合适的参数$k\geq 0$ ,拟合参数向量$\beta$ ,使得$\left |X\beta-Y \right |^2_2-\left |k\beta \right |^2_2$达到最小值，解决了$X^TX$不可逆的问题. Lasso回归，是选择合适的参数$k\geq 0$ ,拟合参数向量$\beta$ ,使得<br>$$<br>J(\beta)&#x3D;\left |X\beta-Y \right |^2_2-\left |k\beta \right |_1<br>$$<br>达到最小值，$\left |k\beta \right |_1$为目标函数的惩罚项，k为惩罚系数</p>
<p>lasson回归</p>
<p>由于拟合Lasso回归模型参数时，使用的损失函数（机器学习中的用语）中包含惩罚系数k,因此在计算模型回归系数之前，仍然需要得到最理想的k值，与岭回归模型类似，k值的确定可以通过定性的可视化方法.</p>
<h6 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h6><p>用此方法求解：（上面题的Lasso回归的题目）</p>
<p>Malinvand于1966年提出的研究法国经济问题的一组数据，如下表1. 所考虑的因变量为进口总额<strong>y</strong> , 三个解释变量分别为：国内总产值<strong>x<sub>1</sub><strong>、储存量</strong>x<sub>2</sub><strong>、总消费</strong>x<sub>3</sub></strong>(单位均为10亿法郎). 建立<strong>y与x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub>的关系</strong></p>
<table>
<thead>
<tr>
<th align="center">年份</th>
<th align="center">$x_1$</th>
<th align="center">$x_2$</th>
<th align="center">$x_3$</th>
<th align="center">$y$</th>
<th align="center">年份</th>
<th align="center">$x_1$</th>
<th align="center">$x_2$</th>
<th align="center">$x_3$</th>
<th align="center">$y$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1949</td>
<td align="center">149.3</td>
<td align="center">4.2</td>
<td align="center">108.1</td>
<td align="center">15.9</td>
<td align="center">1955</td>
<td align="center">202.1</td>
<td align="center">2.1</td>
<td align="center">146.0</td>
<td align="center">22.7</td>
</tr>
<tr>
<td align="center">1950</td>
<td align="center">171.5</td>
<td align="center">4.1</td>
<td align="center">114.8</td>
<td align="center">16.4</td>
<td align="center">1956</td>
<td align="center">212.4</td>
<td align="center">5.6</td>
<td align="center">154.1</td>
<td align="center">26.5</td>
</tr>
<tr>
<td align="center">1951</td>
<td align="center">175.5</td>
<td align="center">3.1</td>
<td align="center">123.2</td>
<td align="center">19.0</td>
<td align="center">1957</td>
<td align="center">226.1</td>
<td align="center">5.0</td>
<td align="center">162.3</td>
<td align="center">28.1</td>
</tr>
<tr>
<td align="center">1952</td>
<td align="center">180.8</td>
<td align="center">3.1</td>
<td align="center">126.9</td>
<td align="center">19.1</td>
<td align="center">1958</td>
<td align="center">231.9</td>
<td align="center">5.1</td>
<td align="center">164.3</td>
<td align="center">27.6</td>
</tr>
<tr>
<td align="center">1953</td>
<td align="center">190.7</td>
<td align="center">1.1</td>
<td align="center">132.1</td>
<td align="center">18.8</td>
<td align="center">1959</td>
<td align="center">239.0</td>
<td align="center">0.7</td>
<td align="center">167.6</td>
<td align="center">26.3</td>
</tr>
<tr>
<td align="center">1954</td>
<td align="center">202.1</td>
<td align="center">2.2</td>
<td align="center">137.7</td>
<td align="center">20.4</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso, LassoCV</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> zscore</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">a=np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡18_例1.txt&#x27;</span>)</span><br><span class="line">n=a.shape[<span class="number">1</span>]-<span class="number">1</span>              <span class="comment">#自变量的总个数</span></span><br><span class="line">aa=zscore(a)                <span class="comment">#数据标准化</span></span><br><span class="line">x=aa[:,:n]                  <span class="comment">#提取自变量观测值矩阵</span></span><br><span class="line">y=aa[:,n]                   <span class="comment">#提取因变量观察值矩阵</span></span><br><span class="line">b=[]                        <span class="comment">#用于存储回归系数的空列表</span></span><br><span class="line"></span><br><span class="line">kk=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)    <span class="comment">#生成从10的a次方到10的b次方之间按对数等分的n个元素的行向量</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> kk:                <span class="comment">#循环迭代的不同k值</span></span><br><span class="line">    md=Lasso(alpha=k).fit(x,y)</span><br><span class="line">    b.append(md.coef_)</span><br><span class="line"></span><br><span class="line">st=[<span class="string">&#x27;s-r&#x27;</span>,<span class="string">&#x27;*-k&#x27;</span>,<span class="string">&#x27;p-b&#x27;</span>]      <span class="comment">#下面画图的控制字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.plot(kk,np.array(b)[:,i],st[i])</span><br><span class="line">plt.legend([<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>,<span class="string">&#x27;x3&#x27;</span>],fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">mdcv=LassoCV(alphas=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)).fit(x,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优alpha=&#x27;</span>,mdcv.alpha_)</span><br><span class="line"></span><br><span class="line"><span class="comment">#md0=Lasso(mdcv.alpha_).fit(x,y) #构建并拟合模型</span></span><br><span class="line"></span><br><span class="line">md0=Lasso(<span class="number">0.21</span>).fit(x,y) <span class="comment">#构建并拟合模型</span></span><br><span class="line">cs0=md0.coef_  <span class="comment">#提出标准化数据回归系数b1,b2,b3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准化数据的所有回归系数为：&#x27;</span>,cs0)</span><br><span class="line"></span><br><span class="line">mu=np.mean(a,axis=<span class="number">0</span>)  <span class="comment">#计算所有指标的均值</span></span><br><span class="line">s=np.std(a,axis=<span class="number">0</span>,ddof=<span class="number">1</span>)  <span class="comment">#计算所有指标的标准差</span></span><br><span class="line"></span><br><span class="line">params=[mu[-<span class="number">1</span>]-s[-<span class="number">1</span>]*<span class="built_in">sum</span>(cs0*mu[:<span class="number">1</span>]/s[:-<span class="number">1</span>]),s[-<span class="number">1</span>]*cs0/s[:-<span class="number">1</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数据的回归系数为：&#x27;</span>,params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度：&#x27;</span>,md0.score(x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h6><p>在建立中国私人轿车拥有量模型时，主要考虑一下因素：</p>
<ul>
<li>城镇居民家庭人均可支配收入$x_1$元</li>
<li>全国城镇人口$x_2$亿元</li>
<li>全国汽车产量$x_3$万辆</li>
<li>全国公路长度$x_4$万千米</li>
<li>中国私人轿车拥有量为 $y$ 万辆</li>
</ul>
<p>求建立y的经验公式</p>
<table>
<thead>
<tr>
<th>年份</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$x_3$</th>
<th>$x_4$</th>
<th>$y$</th>
</tr>
</thead>
<tbody><tr>
<td>1994</td>
<td>3496.2</td>
<td>3.43</td>
<td>136.69</td>
<td>111.78</td>
<td>205.42</td>
</tr>
<tr>
<td>1995</td>
<td>4283</td>
<td>3.52</td>
<td>145.27</td>
<td>115.7</td>
<td>249.96</td>
</tr>
<tr>
<td>1996</td>
<td>4838.9</td>
<td>3.73</td>
<td>147.52</td>
<td>118.58</td>
<td>289.67</td>
</tr>
<tr>
<td>1997</td>
<td>5160.3</td>
<td>3.94</td>
<td>158.25</td>
<td>122.64</td>
<td>358.36</td>
</tr>
<tr>
<td>1998</td>
<td>5425.1</td>
<td>4.16</td>
<td>163</td>
<td>127.85</td>
<td>423.65</td>
</tr>
<tr>
<td>1999</td>
<td>5854</td>
<td>4.37</td>
<td>183.2</td>
<td>135.17</td>
<td>533.88</td>
</tr>
<tr>
<td>2000</td>
<td>6280</td>
<td>4.59</td>
<td>207</td>
<td>140.27</td>
<td>625.33</td>
</tr>
<tr>
<td>2001</td>
<td>6859.6</td>
<td>4.81</td>
<td>234.17</td>
<td>169.8</td>
<td>770.78</td>
</tr>
<tr>
<td>2002</td>
<td>7702.8</td>
<td>5.02</td>
<td>325.1</td>
<td>176.52</td>
<td>968.98</td>
</tr>
</tbody></table>
<p>解 &#x3D;&#x3D;（建模思路：可先用普通最小二乘法建立模型，找出不足，然后提出用Lasso模型进行改进，这样体现了建模的逐渐深入和完善的过程，论文也有层次）&#x3D;&#x3D;</p>
<p>首先，最小二乘法建立y与变量之间的关系</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"></span><br><span class="line">a  = np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡19_例2.txt&#x27;</span>)</span><br><span class="line">n  = a.shape[<span class="number">1</span>]-<span class="number">1</span>               <span class="comment"># 算出自变量数目</span></span><br><span class="line">x  = a[:,:n]                    <span class="comment"># 得到所有的自变量</span></span><br><span class="line">XG = sm.add_constant(x)         <span class="comment"># 变量标准化</span></span><br><span class="line">md = sm.OLS(a[:,n],XG).fit()    <span class="comment"># 构建并拟合模型</span></span><br><span class="line"><span class="built_in">print</span>(md.summary())             <span class="comment"># 输出模型的所有结果</span></span><br></pre></td></tr></table></figure>

<p>out:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">                   OLS Regression Results                  </span><br><span class="line">====================================================================</span><br><span class="line">Dep. Variable:            y       R-squared:  拟合度            0.999</span><br><span class="line">Model:                  OLS       Adj. R-squared:              0.999</span><br><span class="line">Date:      Thu, 13 Aug 2020       Prob (F-statistic):       1.14e-06</span><br><span class="line">Time:              20:39:48       Log-Likelihood:            -28.919</span><br><span class="line">No. Observations:         9       AIC:                         67.84</span><br><span class="line">Df Residuals:             4       BIC:                         68.82</span><br><span class="line">Df Model:                 4                                        </span><br><span class="line">Covariance Type:  nonrobust                                         </span><br><span class="line">====================================================================</span><br><span class="line">          coef       std err    t      P&gt;|t|     [0.025     0.975]</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">const  -1028.4134    58.305   -17.638   0.000   -1190.294   -866.532</span><br><span class="line">x1        -0.0159     0.015    -1.043   0.356      -0.058      0.026</span><br><span class="line">x2       245.6120    34.213     7.179   0.002     150.622    340.602</span><br><span class="line">x3         1.6316     0.178     9.148   0.001       1.136      2.127</span><br><span class="line">x4         2.0294     0.580     3.500   0.025       0.420      3.639</span><br><span class="line">      这上面就是系数了                 0.356大于0.05</span><br><span class="line">                                    说明x1对y不显著</span><br><span class="line">====================================================================</span><br><span class="line">Omnibus:           0.575      Durbin-Watson:                   2.151</span><br><span class="line">Prob(Omnibus):     0.750      Jarque-Bera (JB):                0.560</span><br><span class="line">Skew:              0.368      Prob(JB):                        0.756</span><br><span class="line">Kurtosis:          2.025      Cond. No.                     1.24e+05</span><br><span class="line">====================================================================</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line">[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</span><br><span class="line">[2] The condition number is large, 1.24e+05. This might indicate that there are</span><br><span class="line">strong multicollinearity or other numerical problems.</span><br></pre></td></tr></table></figure>

<p>这里曲线拟合$R^2&#x3D;0.999$ 拟合效果很好，但是看到$x_1系数&lt;0$所以不符合现实，且在显著水平$\alpha&#x3D;0.05$下，x1对y不显著。</p>
<p>这里输出结果中，写出了所有变量前面的系数。<br>$$<br>\hat{y}&#x3D;-1028.4134-0.0159x_1+245.6120x_2+1.6316x_3+2.0294x_4<br>$$<br>所以我们要优化：Lasso回归部分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso,LassoCV</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> zscore</span><br><span class="line"></span><br><span class="line">a  = np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡19_例2.txt&#x27;</span>)</span><br><span class="line">n  = a.shape[<span class="number">1</span>]-<span class="number">1</span>               <span class="comment"># 算出自变量数目</span></span><br><span class="line">aa = zscore(a)                  <span class="comment"># 数据标准化</span></span><br><span class="line">x  = aa[:,:n]                   <span class="comment"># 提出自变量的观测值</span></span><br><span class="line">y  = aa[:, n]                   <span class="comment"># 提出因变量的观测值矩阵</span></span><br><span class="line"></span><br><span class="line">b  = []                         <span class="comment"># 用于存储回归系数的空列表</span></span><br><span class="line">kk = np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)      <span class="comment"># 将-4到0进行99等分得到100个数的等差数列，再生成以10为底的，以等差数列的值为指数的等比数列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> kk :</span><br><span class="line">    md=Lasso(alpha=k).fit(x,y)  <span class="comment"># 循环遍历所有的k</span></span><br><span class="line">    b.append(md.coef_)          <span class="comment"># 得到系数</span></span><br><span class="line"></span><br><span class="line">st=[<span class="string">&#x27;s-r&#x27;</span>,<span class="string">&#x27;*-k&#x27;</span>,<span class="string">&#x27;p-b&#x27;</span>,<span class="string">&#x27;^-y&#x27;</span>]    <span class="comment">#下面画图的控制字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    plt.plot(kk,np.array(b)[:,i],st[i])</span><br><span class="line">plt.legend([<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>,<span class="string">&#x27;x3&#x27;</span>,<span class="string">&#x27;x4&#x27;</span>],fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">mdcv = LassoCV(alphas=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)).fit(x,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优 alpha=&#x27;</span>,mdcv.alpha_)</span><br><span class="line"><span class="comment">#md0=Lasso(mdcv.alpha_).fit(x,y)  # 构建并拟合模型</span></span><br><span class="line">md0 = Lasso(<span class="number">0.05</span>).fit(x,y)</span><br><span class="line"></span><br><span class="line">cs0=md0.coef_                     <span class="comment"># 取出标准化数据的回归系数b1.b2,b3,b4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准化数据的所有回归系数为：&#x27;</span>,cs0)</span><br><span class="line"></span><br><span class="line">mu = a.mean(axis=<span class="number">0</span>)               <span class="comment">#计算所有指标的均差</span></span><br><span class="line">s  = a.std(axis=<span class="number">0</span>,ddof=<span class="number">1</span>)         <span class="comment">#计算所有指标的方差</span></span><br><span class="line">params = [mu[-<span class="number">1</span>]-s[-<span class="number">1</span>]*<span class="built_in">sum</span>(cs0*mu[:-<span class="number">1</span>]),s[-<span class="number">1</span>]*cs0/s[:-<span class="number">1</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数据的回归系数为:&#x27;</span>,params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度：&#x27;</span>,md0.score(x,y))</span><br></pre></td></tr></table></figure>

<p>拓展阅读：（了解就可以了，明白什么时候选择Lasso回归合适.）</p>
<p>对于高维数据，维数灾难所带来的过拟合问题，其解决思路是：1）增加样本量；2）减少样本特征，而对于现实情况，会存在所能获取到的样本数据量有限的情况，甚至远小于数据维度，即：d&gt;&gt;n。如证券市场交易数据、多媒体图形图像视频数据、航天航空采集数据、生物特征数据等。 </p>
<p>主成分分析作为一种数据降维方法，其出发点是通过整合原本的单一变量来得到一组新的综合变量，综合变量所代表的意义丰富且变量间互不相关，综合变量包含了原变量大部分的信息，这些综合变量称为主成分。主成分分析是在保留所有原变量的基础上，通过原变量的线性组合得到主成分，选取少数主成分就可保留原变量的绝大部分信息，这样就可用这几个主成分来代替原变量，从而达到降维的目的。</p>
<p>主成分分析法只适用于数据空间维度小于样本量的情况，当数据空间维度很高时，将不再适用。</p>
<p><strong>Lasso是另一种数据降维方法，该方法不仅适用于线性情况，也适用于非线性情况。Lasso是基于惩罚方法对样本数据进行变量选择，通过对原本的系数进行压缩，将原本很小的系数直接压缩至0，从而将这部分系数所对应的变量视为非显著性变量，将不显著的变量直接舍弃。</strong></p>
<h2 id="常用的数据清洗方法"><a href="#常用的数据清洗方法" class="headerlink" title="常用的数据清洗方法"></a>常用的数据清洗方法</h2><p>在数据处理的过程中，一般都需要进行数据的清洗工作，如数据集是否存在重复、缺失，数据是否具有完整性和一致性、数据中是否存在异常值等. 当发现数据中存在如上可能的问题时，都需要有针对性地处理。现在介绍如何识别和处理重复观察、缺失值和异常值.</p>
<h3 id="重复观测处理"><a href="#重复观测处理" class="headerlink" title="重复观测处理"></a>重复观测处理</h3><p>运用pandas对读入的数据进行重复项检查，以及如何删除数据中的重复项。</p>
<center>数据一</center>

<table>
<thead>
<tr>
<th>appcategory</th>
<th>appname</th>
<th>comments</th>
<th>install</th>
<th>love</th>
<th>size</th>
<th>update</th>
</tr>
</thead>
<tbody><tr>
<td>网上购物-商城-团购-优惠-快递</td>
<td>每日优鲜</td>
<td>1297</td>
<td>204.7万</td>
<td>89.00%</td>
<td>15.16MB</td>
<td>2017年10月11日</td>
</tr>
<tr>
<td>网上购物-商城</td>
<td>苏宁易购</td>
<td>577</td>
<td>7996.8万</td>
<td>73.00%</td>
<td>58.9MB</td>
<td>2017年09月21日</td>
</tr>
<tr>
<td>网上购物-商城-优惠</td>
<td>唯品会</td>
<td>2543</td>
<td>7090.1万</td>
<td>86.00%</td>
<td>41.43MB</td>
<td>2017年10月13日</td>
</tr>
<tr>
<td>网上购物-商城-优惠</td>
<td>唯品会</td>
<td>2543</td>
<td>7090.1万</td>
<td>86.00%</td>
<td>41.43MB</td>
<td>2017年10月13日</td>
</tr>
<tr>
<td>网上购物-商城</td>
<td>拼多多</td>
<td>1921</td>
<td>3841.9万</td>
<td>95.00%</td>
<td>13.35MB</td>
<td>2017年10月11日</td>
</tr>
<tr>
<td>网上购物-商城-优惠</td>
<td>寺库奢侈品</td>
<td>1964</td>
<td>175.4万</td>
<td>100.00%</td>
<td>17.21MB</td>
<td>2017年09月30日</td>
</tr>
<tr>
<td>网上购物-商城</td>
<td>淘宝</td>
<td>14244</td>
<td>4.6亿</td>
<td>68.00%</td>
<td>73.78MB</td>
<td>2017年10月13日</td>
</tr>
<tr>
<td>网上购物-商城-团购-优惠</td>
<td>当当</td>
<td>134</td>
<td>1615.3万</td>
<td>61.00%</td>
<td>37.01MB</td>
<td>2017年10月17日</td>
</tr>
<tr>
<td>网上购物-商城-团购-优惠</td>
<td>当当</td>
<td>134</td>
<td>1615.3万</td>
<td>61.00%</td>
<td>37.01MB</td>
<td>2017年10月17日</td>
</tr>
<tr>
<td>网上购物-商城-团购-优惠</td>
<td>当当</td>
<td>134</td>
<td>1615.3万</td>
<td>61.00%</td>
<td>37.01MB</td>
<td>2017年10月17日</td>
</tr>
</tbody></table>
<p>这里很直观的看到有很多数据重复了。</p>
<p>方法：检查上述的数据集是否有重复，pandas中使用duplicated方法，该方法返回的是数据行每一行的检验结果，即每一行的返回一个bool值，使用drop_duplicates方法移除重复值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">a  = pd.read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例1.xlsx&#x27;</span>) <span class="comment">#读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;是否有重复观测：&#x27;</span>,<span class="built_in">any</span>(a.duplicated()))    <span class="comment"># 有重复的值，则输出True</span></span><br><span class="line">a.drop_duplicates(inplace=<span class="literal">True</span>)                <span class="comment"># inplace=True时，直接删除a中的重复数据</span></span><br><span class="line"></span><br><span class="line">f=pd.ExcelWriter(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例1_已删除重复.xlsx&#x27;</span>) <span class="comment"># 创建文件的对象</span></span><br><span class="line">a.to_excel(f)                                  <span class="comment"># 把a已筛选的数据写入Excel中</span></span><br><span class="line">f.save()                                       <span class="comment">#保存文件，数据才真正写入excel文件,查看所保存的路径下的文件夹，已有excel新文件</span></span><br></pre></td></tr></table></figure>



<h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>Pandas使用浮点值NaN表示浮点或浮点数组中的缺失数据，Python内置的None值也会被当作缺失值处理. Pandas使用方法isnull 检测是否为缺失值，检测对象的每个元素返回一个bool值.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检测是否有缺失值</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> NaN</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data=pd.Series([<span class="number">10.0</span>,<span class="literal">None</span>,NaN,<span class="number">30</span>])</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(data.isnull())        <span class="comment"># 输出每个元素的检测结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;是否存在缺失值：&#x27;</span>,<span class="built_in">any</span>(data.isnull()))    <span class="comment"># 输出True</span></span><br></pre></td></tr></table></figure>

<h4 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h4><h5 id="过滤法、删除法"><a href="#过滤法、删除法" class="headerlink" title="过滤法、删除法"></a>过滤法、删除法</h5><ul>
<li>dropna方法，适用于缺失值的观测对象所占比例非常低（如5%以内），直接删除缺失值所在的观测对象。因为对结果影响不大</li>
</ul>
<h5 id="填充法、替换法"><a href="#填充法、替换法" class="headerlink" title="填充法、替换法"></a>填充法、替换法</h5><ul>
<li>用某种常数值替换缺失值，使用fillna方法。例如对连续变量而言，用中位数或均值；对于离散变量，使用众数替换。</li>
</ul>
<h5 id="插值法"><a href="#插值法" class="headerlink" title="插值法"></a>插值法</h5><ul>
<li>根据其他非缺失的变量或观测来预测缺失值，常见有线性插值法、K近邻插值法、Lagrange插值法等</li>
</ul>
<h4 id="对Excel文件数据进行数据-删除-过滤"><a href="#对Excel文件数据进行数据-删除-过滤" class="headerlink" title="对Excel文件数据进行数据(删除)过滤"></a>对Excel文件数据进行数据(删除)过滤</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_excel</span><br><span class="line">a = read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例3.xlsx&#x27;</span>)</span><br><span class="line">b1 = a.dropna()     <span class="comment">#删除所有的缺失值,整行数据都删除</span></span><br><span class="line">b2 = a.dropna(axis=<span class="number">1</span>,thresh=<span class="number">9</span>)</span><br><span class="line"><span class="comment"># 删除一列的数据，这里的thresh就是数据集的个数为多少个，axis=0为行</span></span><br><span class="line">b3 = a.drop(<span class="string">&#x27;用户B&#x27;</span>,axis=<span class="number">1</span>) <span class="comment"># 删除用户B的数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;过滤后的数据：\n&#x27;</span>,b1,<span class="string">&#x27;\n-------------------\n&#x27;</span>,b2,<span class="string">&#x27;\n----------------\n&#x27;</span>,b3)</span><br></pre></td></tr></table></figure>

<h4 id="对excel表中的确实值进行数据填充"><a href="#对excel表中的确实值进行数据填充" class="headerlink" title="对excel表中的确实值进行数据填充"></a>对excel表中的确实值进行数据填充</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_excel</span><br><span class="line">a = read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例4.xlsx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a,<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用0补齐所有的值</span></span><br><span class="line">b1 = a.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用0填补:\n&#x27;</span>,b1,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用前一行的有的值补齐这一行缺失的值</span></span><br><span class="line">b2 = a.fillna(method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用前一行的值填补\n&#x27;</span>,b2,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用后一行向前一行缺失的值补齐</span></span><br><span class="line">b3 = a.fillna(method=<span class="string">&#x27;bfill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用后一行向前一行缺失的值补齐&#x27;</span>,b3,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line">b4=a.fillna(value=&#123;<span class="string">&#x27;gender&#x27;</span>:a.gender.mode()[<span class="number">0</span>],   <span class="comment"># 性别使用总数替换</span></span><br><span class="line">                   <span class="string">&#x27;age&#x27;</span>:a.age.mean(),            <span class="comment"># 年龄使用均值替换</span></span><br><span class="line">                   <span class="string">&#x27;income&#x27;</span>:a.income.median       <span class="comment"># 收入使用中位数替换</span></span><br><span class="line">                     &#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;分变量替换:\n&#x27;</span>,b4)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数值型缺失数据利用插值法进行替换"><a href="#数值型缺失数据利用插值法进行替换" class="headerlink" title="数值型缺失数据利用插值法进行替换"></a>数值型缺失数据利用插值法进行替换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_excel</span><br><span class="line"></span><br><span class="line">a = read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例4.xlsx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b=a.fillna(value=&#123;<span class="string">&#x27;gender&#x27;</span>:a.gender.mode()[<span class="number">0</span>],    <span class="comment"># 性别使用总数替换</span></span><br><span class="line">               <span class="string">&#x27;age&#x27;</span>:a.age.interpolate(method=<span class="string">&#x27;polynomial&#x27;</span>,order=<span class="number">2</span>),</span><br><span class="line">                                            <span class="comment"># 年龄使用二次多项式插值替换</span></span><br><span class="line">               <span class="string">&#x27;income&#x27;</span>:a.income.interpolate() <span class="comment"># 收入使用线性插值替换</span></span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h3><p>异常值的检测一般采用两种方法：<strong>标准差法</strong>、<strong>箱线图法</strong></p>
<p>太阳黑子个数文件<code>sunspots.csv</code>数据用Excel软件打开后的格式如<code>C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例6_sunspots.csv</code>，共有289条记录，识别并处理其中的异常值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">a  = read_csv(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例6_sunspots.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)                  <span class="comment"># 查看数据的多少，此处显示289个记录;2种数据</span></span><br><span class="line"></span><br><span class="line">mu = a.counts.mean()            <span class="comment"># 计算黑子个数counts的年平均数</span></span><br><span class="line"><span class="built_in">print</span>(mu)</span><br><span class="line">s  = a.counts.std()             <span class="comment"># 计算黑子个数标准差</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准差法异常值上限检测：&#x27;</span>,<span class="built_in">any</span>(a.counts&gt;mu+<span class="number">2</span>*s))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准差法异常值下限检测：&#x27;</span>,<span class="built_in">any</span>(a.counts&lt;mu+<span class="number">2</span>*s))</span><br><span class="line"></span><br><span class="line">Q1=a.counts.quantile(<span class="number">0.25</span>)      <span class="comment"># 计算下四分位数</span></span><br><span class="line"><span class="built_in">print</span>(Q1)</span><br><span class="line">Q3=a.counts.quantile(<span class="number">0.75</span>)      <span class="comment"># 计算上四分位数</span></span><br><span class="line"><span class="built_in">print</span>(Q3)</span><br><span class="line">IQR=Q3-Q1                       <span class="comment"># 计算四分位距</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;箱线法图异常值上限检测:&#x27;</span>,<span class="built_in">any</span>(a.counts&gt;Q3+<span class="number">1.5</span>*IQR))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;箱线法图异常值下限检测:&#x27;</span>,<span class="built_in">any</span>(a.counts&lt;Q1-<span class="number">1.5</span>*IQR))</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)         <span class="comment"># 设置绘线风格</span></span><br><span class="line">a.counts.plot(kind=<span class="string">&#x27;hist&#x27;</span>,bins=<span class="number">30</span>,density=<span class="literal">True</span>)</span><br><span class="line">a.counts.plot(kind=<span class="string">&#x27;kde&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;异常值替换前的数据统计特征:\n&#x27;</span>,a.counts.describe(),<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">UB = Q3+<span class="number">1.5</span>*IQR</span><br><span class="line">st=a.counts[a.counts&lt;UB].<span class="built_in">max</span>()   <span class="comment"># 找出低于判别上限的最大值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;判断异常值的上限临界值为：&#x27;</span>,UB)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用以替换异常值的数据为：&#x27;</span>,st)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;异常值的位置：\n&#x27;</span>,a.loc[a.counts&gt;UB,<span class="string">&#x27;counts&#x27;</span>])  <span class="comment"># 观察后可以注释掉</span></span><br><span class="line">a.loc[a.counts&gt;UB, <span class="string">&#x27;counts&#x27;</span>]=st  <span class="comment"># 替换超过判别上限异常值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;异常值替换后的数据统计特征为：\n&#x27;</span>,a.counts.describe(),<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">a.to_csv(<span class="string">&#x27;暑假打卡20_例6_sunspots_已数据清洗.csv&#x27;</span>)</span><br><span class="line"> <span class="comment">#将清洗后的数据存入新的文件，此处可自行修改为想保存的文件路径</span></span><br></pre></td></tr></table></figure>



<h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><p>如何利用现有资源来安排生产，以取得最大经济效益的问题。</p>
<p>例 1 某机床厂生产甲、 乙两种机床， 每台销售后的利润分别为 4000 元与 3000 元。生产甲机床需用 A、 B 机器加工，加工时间分别为每台 2 小时和 1 小时；生产乙机床需用 A、 B、 C 三种机器加工，加工时间为每台各一小时。若每天可用于加工的机器时数分别为 A 机器 10 小时、 B 机器 8 小时和C 机器 7 小时，问该厂应生产甲、乙机床各几台，才能使总利润最大？  </p>
<blockquote>
<p><strong>数学模型</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>4000</td>
<td>甲</td>
<td>2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>3000</td>
<td>乙</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td></td>
<td>10</td>
<td>8</td>
<td>7</td>
</tr>
</tbody></table>
<p>设甲机床有x<sub>1</sub>个，乙机床有x<sub>2</sub>个        						（0）x<sub>1</sub>, x<sub>2</sub> 称之为决策变量  </p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>目标函数  max   z &#x3D; 4 x<sub>1</sub> + 3x<sub>2</sub>     			（1）目标函数 </p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>约束条件：                                              			（2）约束条件  		</p>
<blockquote>
<p>2 x<sub>1</sub> + x<sub>2</sub> &amp;le; 10</p>
<p>x<sub>1</sub> + x<sub>2</sub> &amp;le; 8</p>
<p>x<sub>2</sub>  &amp;le; 7</p>
<p>x<sub>1</sub>,x<sub>2</sub> ≥ 0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Matlab 中规定线性规划的标准形式为<br>$$<br>\min_{x} c^T x<br>$$</p>
<p>$$<br>s.t.\begin{cases} Ax\le b \ Aeq \cdot x &#x3D; beq \lb \le x\le ub\end{cases}<br>$$</p>
<p>其中 c 和 x 为 n 维列向量， A 、 Aeq 为适当维数的矩阵， b 、 beq 为适当维数的列向量。  </p>
<p>线性规划中<br>$$<br>\min_{x} c^T x  \qquad s.t.  \quad Ax \le b<br>$$<br>的Matlab标准型为<br>$$<br>\min_{x} -c^T x  \qquad s.t.  \quad -Ax \le -b<br>$$</p>
<p><strong>可行解</strong>：满足目标  s.t.      <em><strong>最优解</strong></em>：满足可行解的情况下，更加接近目标函数     <strong>可行域</strong>：满足所用的可行解</p>
<p><img src="C:\Users\墨羽辰\AppData\Roaming\Typora\typora-user-images\image-20200516225230769.png" alt="image-20200516225230769"></p>
<p>注：跟高中所学的线性规划的题目相似。平移z函数</p>
<p><img src="C:\Users\墨羽辰\AppData\Roaming\Typora\typora-user-images\image-20200516230019428.png" alt="image-20200516230019428"></p>
<p>（2，6）点处，可能为非空点（无最优解），或者是实数点（有最优解）。</p>
<hr>
<p><em><strong>特别解释及定义：</strong></em></p>
<p>多维空间中：R不再是二维平面了。我们成多维空间形成的可行域为多胞形。二维平面中最优点一般是顶点，多胞体我们称最优点为一下概念：</p>
<p>**定义一：称 n 维空间中的区域 R 为一凸集，若   ∀x<sub>1</sub>, x<sub>2</sub> &amp;isin; R 及 ∀&amp;lambda; ∈(0,1) ，有   &amp;lambda;x<sub>1</sub> + (1- &amp;lambda;)x<sub>2</sub> ∈R   **</p>
<p>**定义二:  设 R 为 n 维空间中的一个凸集， R 中的点 x 被称为 R 的一个极点，若不存在 x<sub>1</sub>、 x<sub>2</sub> ∈ R 及λ ∈(0,1) ,使得 x &#x3D; &amp;lambda;x<sub>1</sub> + (1- &amp;lambda;)x<sub>2</sub>  **</p>
<p>解释：</p>
<p>[1].  定义1 说明凸集中<em><strong>任意两点的连线必在此凸集中</strong></em>；  </p>
<p>[2]. 定义 2 说明，若 x 是凸集 R的一个<strong>极点</strong>，则 <em><strong>x 不能位于 R 中任意两点的连线上</strong></em>。  </p>
<hr>
<h3 id="一：单纯形法-—遍历法"><a href="#一：单纯形法-—遍历法" class="headerlink" title="一：单纯形法  —遍历法"></a>一：单纯形法  —遍历法</h3><p><img src="C:\Users\墨羽辰\AppData\Roaming\Typora\typora-user-images\image-20200516233348815.png" alt="image-20200516233348815"></p>
<p>一般<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1661606">线性规划</a>问题中当线性方程组的变量数大于方程个数，这时会有不定数量的解，而单纯形法是求解线性规划问题的通用方法。</p>
<p><strong>具体步骤</strong>，从线性方程组找出一个个的单纯形，每一个单纯形可以求得一组解，然后再判断该解使目标函数值是增大还是变小了，决定下一步选择的单纯形。通过优化迭代，直到目标函数实现最大或最小值。</p>
<p>等我稍加学习后，在拿出来更新分享。</p>
<h3 id="二：Matlab解法"><a href="#二：Matlab解法" class="headerlink" title="二：Matlab解法"></a>二：Matlab解法</h3><p><em><strong>重点：</strong></em></p>
<p>Matlab 中规定线性规划的标准形式为<br>$$<br>\min_{x} c^T x<br>$$</p>
<p>$$<br>s.t.\begin{cases} Ax\le b \ Aeq \cdot x &#x3D; beq \lb \le x\le ub\end{cases}<br>$$</p>
<p>其中 c 和 x 为 n 维列向量， A 、 Aeq 为适当维数的矩阵， b 、 beq 为适当维数的列向量。  </p>
<p>**[x,fval]&#x3D;linprog(c,A,b,Aeq,beq,LB,UB,X0,OPTIONS)  **</p>
<p>LB 和 UB 分别是变量 x 的下界和上界    		x0 是 x 的初始值       	OPTIONS 是控制参数  </p>
<p> c 和 x 为 n 维列向量           A 、 Aeq 为适当维数的矩阵			 b 、 beq 为适当维数的列向量。 </p>
<p>$$<br>\min_{z} &#x3D; 2x_1+3x_2-5x_3<br>\s.t.\begin{cases}<br>            x_1+x_2+x_3&#x3D;7\2x_1-5x_2+x_3 \ge 12 \x_1,x_2,x_3 \ge 0<br>        \end{cases}<br>$$<br>Matlab编写：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = [<span class="number">2</span>;<span class="number">3</span>;<span class="number">-5</span>];</span><br><span class="line">a = [<span class="number">-2</span>,<span class="number">5</span>,<span class="number">-1</span>;<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">b = [<span class="number">-10</span>,<span class="number">12</span>];</span><br><span class="line">aeq = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">beq = <span class="number">7</span>;</span><br><span class="line">x = linprog(-c,a,b,aeq,beq,<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">value = c&#x27;*x</span><br></pre></td></tr></table></figure>



<h3 id="三、python求解"><a href="#三、python求解" class="headerlink" title="三、python求解"></a>三、python求解</h3><h5 id="scipy-optimize模块求解"><a href="#scipy-optimize模块求解" class="headerlink" title="scipy.optimize模块求解"></a>scipy.optimize模块求解</h5><p>scipy.optimize提供了一个线性求解线性规划的函数linprog</p>
<p>scipy中线性规划的标准形为：<br>$$<br>\min_{x}z&#x3D; c^T x			\<br>s.t.\begin{cases} Ax\le b, 	\<br>Aeq \cdot x &#x3D; beq, 			\<br>Lb \le x\le Ub\end{cases}<br>$$<br>lingrop的基本调用格式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"><span class="comment">### 注：这里的c,A,b,Aeq,beq都要求出来才行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认每个决策变量下界为0，上界为无穷大</span></span><br><span class="line">res=linprog(c, A, b, Aeq, beq) </span><br><span class="line">res=linprog(c,A=<span class="literal">None</span>,b=<span class="literal">None</span>,Aeq=<span class="literal">None</span>,beq=<span class="literal">None</span>,</span><br><span class="line">            bounds=<span class="literal">None</span>,method=’simplex’)</span><br><span class="line"><span class="built_in">print</span>(res.fun)		<span class="comment"># 显示目标函数最小值</span></span><br><span class="line"><span class="built_in">print</span>(res.x)		<span class="comment"># 显示最优解</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>c 和 x 为 n 维列向量，c 对应目标函数的系数变量</p>
</li>
<li><p>A  为适当维数的矩阵， b为适当维数的列向量；A,b分别对应<strong>不等式约束</strong>的系数向量和常数项</p>
</li>
<li><p>Aeq 为适当维数的矩阵，beq 为适当维数的列向量；Aeq，beq分别对应<strong>等式约束</strong>的系数向量和常数项</p>
</li>
</ul>
<h6 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h6><hr>
<p>$$<br>\min_{x}z&#x3D; -x_1+4x_2		\<br>s.t.<br>\begin{cases}<br>-3x_1+\ \ x_2\leqslant\ \ \ \  6\<br>\ \ \ \ \ x_1+2x_2 \leqslant\ \ \ \  4 \<br> \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ x_2  \geqslant  -3<br>\end{cases}<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c=[-<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">A=[[-<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">b=[<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">bounds=((<span class="literal">None</span>,<span class="literal">None</span>),(-<span class="number">3</span>,<span class="literal">None</span>))</span><br><span class="line"><span class="comment">#      x1的取值无穷  x2的取值&gt;=2</span></span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解：&#x27;</span>,res.x)</span><br></pre></td></tr></table></figure>

<p>目标函数的最小值： -21.99999984082497<br>最优解： [ 9.99999989 -2.99999999]</p>
<p>所以最优解为$x_1&#x3D;10,x_2&#x3D;-3$,目标 函数的最优值为 -22.</p>
<hr>
<p>$$<br>\min z&#x3D; x_1-2x_2-3x_3		\<br>s.t.<br>\begin{cases}<br>-2x_1+x_2+\ \  x_3\leqslant \ \ \ 9\<br>-3x_1+x_2+2x_3 \geqslant \ \ \ 4 \<br>\ \ \ 4x_1-2x_2-x_3 &#x3D;  -6 \<br>x_1\geqslant -10, x_2\geqslant 0,x_3取值无约束<br>\end{cases}<br>$$</p>
<p>化成标准型：<br>$$<br>\min w&#x3D; -x_1+2x_2+3x_3		\<br>s.t.<br>\begin{cases}<br>-2x_1+x_2+\ \  x_3\leqslant \ \ \ 9\<br>\ \ \ 3x_1-x_2-2x_3 \leqslant  -4 \<br>\ \ \ 4x_1-2x_2-x_3 &#x3D;  -6 \<br>x_1\geqslant -10, x_2\geqslant 0,x_3取值无约束<br>\end{cases}<br>$$<br>也就是说将所有都化为$ax_1+bx_2\leqslant c$的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c=[-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">A=[[-<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">2</span>]]</span><br><span class="line">b=[<span class="number">9</span>,-<span class="number">4</span>]</span><br><span class="line">Aeq=[[<span class="number">4</span>,-<span class="number">2</span>,-<span class="number">1</span>]]</span><br><span class="line">beq=[-<span class="number">6</span>]</span><br><span class="line">LB=[-<span class="number">10</span>,<span class="number">0</span>,<span class="literal">None</span>]</span><br><span class="line">UB=[<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>]</span><br><span class="line"><span class="comment">#bounds=((-10,None,),(0,None),(None,None))</span></span><br><span class="line">bounds=<span class="built_in">tuple</span>(<span class="built_in">zip</span>(LB,UB))</span><br><span class="line">res=linprog(c,A,b,Aeq,beq,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解：&#x27;</span>,res.x)</span><br><span class="line"></span><br><span class="line"><span class="comment">################ or #####################</span></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c=[-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">A=[[-<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">2</span>]]</span><br><span class="line">b=[<span class="number">9</span>,-<span class="number">4</span>]</span><br><span class="line">Aeq=[[<span class="number">4</span>,-<span class="number">2</span>,-<span class="number">1</span>]]</span><br><span class="line">beq=[-<span class="number">6</span>]</span><br><span class="line">bounds=((-<span class="number">10</span>,<span class="literal">None</span>,),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="literal">None</span>,<span class="literal">None</span>))</span><br><span class="line">res=linprog(c,A,b,Aeq,beq,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解：&#x27;</span>,res.x)</span><br></pre></td></tr></table></figure>

<p>即所求问题的最优解为</p>
<p>目标函数的最小值： 0.4000000006525579<br>最优解： [-1.60000000e+00  8.29738643e-11 -4.00000000e-01]</p>
<p>（注意x2的解为8.29674988x10<sup>-11</sup> ，写成解的时候保留一位小数就是0.0，即0)</p>
<hr>
<p>例题：</p>
<p>加工一种食用油需要精炼若干种原料油并把它们混合起来、原料油的来源有两类共5种：植物油VEG1、植物油VEG2、非植物油OIL1、非植物油OIL2、非植物油OIL3. 购买每种原料油的价格（英镑&#x2F;吨）如下表1，最终产品以<em><strong>150英镑&#x2F;吨的价格出售</strong></em>. 植物油和非植物油需要在<strong>不同的生成线</strong>上进行精炼. <strong>每月能够精炼的植物油不超过200吨，非植物油不超过250吨</strong>；在精炼过程中，重量没有损失，精炼费用可忽略不计. 最终产品要符合硬度的技术条件. 按照硬度计量单位，它必须为<strong>3~6</strong>. 假定<strong>硬度的混合是线性</strong>的，而原材料的硬度如表2所示.</p>
<p>求：为使利润最大，应该怎样指定它的月采购和加工计划</p>
<center>表一  原料油价格</center>

<table>
<thead>
<tr>
<th>原料油</th>
<th>VEG1</th>
<th>VEG2</th>
<th>OIL1</th>
<th>OIL2</th>
<th>OIL3</th>
</tr>
</thead>
<tbody><tr>
<td>价格</td>
<td>110</td>
<td>120</td>
<td>130</td>
<td>110</td>
<td>115</td>
</tr>
</tbody></table>
<center>表2 原料油硬度表</center>

<table>
<thead>
<tr>
<th>原料油</th>
<th>VEG1</th>
<th>VEG2</th>
<th>OIL1</th>
<th>OIL2</th>
<th>OIL3</th>
</tr>
</thead>
<tbody><tr>
<td>硬度值</td>
<td>8.8</td>
<td>6.1</td>
<td>2.0</td>
<td>4.2</td>
<td>5.0</td>
</tr>
</tbody></table>
<p>解：设$x_1,x_2,…,x_5$分别对应了5种原料油吨数，$x_6$为每月加工的成品油吨数</p>
<ol>
<li><p>目标函数是要让净利润达到最大：即<br>$$<br>z&#x3D;-100x_1-120x_2-130x_3-110x_4-115x_5+150x_6<br>$$</p>
</li>
<li><p>约束条件为以下四类：</p>
<p>i.精炼能力的限制</p>
<p>​	植物油精炼能力的限制：$x_1+x_2\leqslant 200$</p>
<p>​	非植物油精炼能力的限制：$x_3+x_4+x_5\leqslant 250$ </p>
<p>ii.硬度的限制</p>
<p>​	硬度上限：$8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\leqslant 6x_6$</p>
<p>​	硬度下限：$8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\geqslant3x_6$</p>
<p>iii.守恒性质限制（重量没有损失）</p>
<p>​	$x_1+x_1+x_3+x_4+x_5&#x3D;x_6$</p>
<p>iiii.非负性限制</p>
<p>​	$x_i\geqslant0,i&#x3D;0,1,…,6$</p>
</li>
</ol>
<p>所以建立如下的线性规划<br>$$<br>max\ z&#x3D;-100x_1-120x_2-130x_3-110x_4-115x_5+150x_6\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 200\<br>x_3+x_4+x_5\leqslant 250\<br>8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\leqslant 6x_6\<br>8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\geqslant3x_6\<br>x_1+x_1+x_3+x_4+x_5&#x3D;x_6\<br>x_i\geqslant0,i&#x3D;0,1,…,6 .<br>\end{cases}<br>$$<br>要先转变成标准型即：<br>$$<br>这种函数\<br>\min_{x}z&#x3D; c^T x			\<br>s.t.\begin{cases} Ax\le b, 	\<br>Aeq \cdot x &#x3D; beq, 			\<br>Lb \le x\le Ub\end{cases}<br>$$<br>所以得到为：<br>$$<br>max\ z&#x3D;-100x_1-120x_2-130x_3-110x_4-115x_5+150x_6\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 200\<br>x_3+x_4+x_5\leqslant 250\<br>8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5-6x_6\leqslant 0\<br>-8.8x_1-6.1x_1-2.0x_3-4.2x_4-5.0x_5+3x_6\leqslant0\<br>x_1+x_1+x_3+x_4+x_5-x_6&#x3D;0\<br>x_i\geqslant0,i&#x3D;0,1,…,6 .<br>\end{cases}<br>$$<br>程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">100</span>,-<span class="number">120</span>,-<span class="number">130</span>,-<span class="number">110</span>,-<span class="number">115</span>,<span class="number">150</span>]</span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">8.8</span>,<span class="number">6.1</span>,<span class="number">2.0</span>,<span class="number">4.2</span>,<span class="number">5.0</span>,-<span class="number">6.0</span>],[-<span class="number">8.8</span>,-<span class="number">6.1</span>,-<span class="number">2.0</span>,-<span class="number">4.2</span>,-<span class="number">5.0</span>,<span class="number">3.0</span>]]</span><br><span class="line"><span class="comment">#b=[200,250,0,0]</span></span><br><span class="line">b=[[<span class="number">200</span>],[<span class="number">250</span>],[<span class="number">0</span>],[<span class="number">0</span>]]</span><br><span class="line">Aeq=[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>]]</span><br><span class="line">beq=[<span class="number">0</span>]</span><br><span class="line">bounds=((<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line">res=linprog(c,A,b,Aeq,beq,bounds)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：&#x27;</span>,res.x)</span><br></pre></td></tr></table></figure>

<p>目标函数的最小值： -4.1769028848418895e-13<br>最优解为： [1.16766018e-16 2.24124639e-15 3.48701448e-16 1.33739624e-15<br> 2.13371900e-15 2.00505560e-15]</p>
<hr>
<p>已知某种商品6个仓库的存活量，8个客户对该商品的需求量，单位商品运价如下表3所示. 试确定6个仓库到8个客户的商品调运数量，使总的运输费用最小.</p>
<table>
<thead>
<tr>
<th>仓库W|单价运价右下\客户V</th>
<th>V1</th>
<th>V2</th>
<th>V3</th>
<th>V4</th>
<th>V5</th>
<th>V6</th>
<th>V7</th>
<th>V8</th>
<th>存货量</th>
</tr>
</thead>
<tbody><tr>
<td>$W_1$</td>
<td>6</td>
<td>2</td>
<td>6</td>
<td>7</td>
<td>4</td>
<td>2</td>
<td>5</td>
<td>9</td>
<td>60</td>
</tr>
<tr>
<td>$W_2$</td>
<td>4</td>
<td>9</td>
<td>5</td>
<td>3</td>
<td>8</td>
<td>5</td>
<td>8</td>
<td>2</td>
<td>55</td>
</tr>
<tr>
<td>$W_3$</td>
<td>5</td>
<td>2</td>
<td>1</td>
<td>9</td>
<td>7</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>51</td>
</tr>
<tr>
<td>$W_4$</td>
<td>7</td>
<td>6</td>
<td>7</td>
<td>3</td>
<td>9</td>
<td>2</td>
<td>7</td>
<td>1</td>
<td>43</td>
</tr>
<tr>
<td>$W_5$</td>
<td>2</td>
<td>3</td>
<td>9</td>
<td>5</td>
<td>7</td>
<td>2</td>
<td>6</td>
<td>5</td>
<td>41</td>
</tr>
<tr>
<td>$W_6$</td>
<td>5</td>
<td>5</td>
<td>2</td>
<td>2</td>
<td>8</td>
<td>1</td>
<td>4</td>
<td>3</td>
<td>52</td>
</tr>
<tr>
<td>需求量</td>
<td>35</td>
<td>37</td>
<td>22</td>
<td>32</td>
<td>41</td>
<td>32</td>
<td>43</td>
<td>38</td>
<td></td>
</tr>
</tbody></table>
<p>解：设</p>
<p>$x_{ij}(i&#x3D;1,2,…,6;j&#x3D;1,2,…,8)$表示第i个仓库到第j个客户的商品数量，</p>
<p>$c_{ij}(i&#x3D;1,2,…,6;j&#x3D;1,2,…,8)$表示第i个仓库运到第j个客户的单位运价，</p>
<p>$d_{j}$表示第j个客户的需求量</p>
<p>$e_i$表示第i个仓库的库存量</p>
<p>建立线性规划模型：<br>$$<br>min \sum_{i&#x3D;1}^{6}\sum_{j&#x3D;1}^{8}c_{ij}x_{ij},\<br>s.t.<br>\begin{cases}<br>\sum_{j&#x3D;1}^{8}x_{ij}\leqslant e_i,i&#x3D;1,2,…,6\<br>\sum_{i&#x3D;1}^{6}x_{ij}\leqslant d_j,j&#x3D;1,2,…,6\<br>x_{ij}\geqslant0,i&#x3D;1,2,…,6;j&#x3D;1,2,…,8. \<br>\end{cases}<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">import cvxpy as cp</span></span><br><span class="line"><span class="string">import numpy as np</span></span><br><span class="line"><span class="string">import pandas as pd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d1=pd.read_excel(r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡21_例4.xlsx&#x27;,header=None)</span></span><br><span class="line"><span class="string"># 这里的header=None是告诉程序没有表头，不然会导致得到的结果的第一行被当作表头使用了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d2=d1.values    # 将值转变为数组</span></span><br><span class="line"><span class="string">c=d2[:-1,:-1]    #读取d2中除最后一行一列的数据</span></span><br><span class="line"><span class="string">e=d2[:-1,-1].reshape(-1,1)#数据表中的最后一列（不包括该列的最后一个元素）,reshape(-1,1)表示生成1列</span></span><br><span class="line"><span class="string">d=d2[-1,:-1].reshape(1,-1)#数据表中的最后一行（不包括该行的最后一个元素），reshape（1，-1）表示生成1行</span></span><br><span class="line"><span class="string">x=cp.Variable((6,8))      #用凸优化的cvxpy库</span></span><br><span class="line"><span class="string">obj=cp.Minimize(cp.sum(cp.multiply(c,x)))   #构造目标函数  即将数据带入x6*8矩阵</span></span><br><span class="line"><span class="string">con=[cp.sum(x,axis=1,keepdims=True)&lt;=e,     #构造约束条件1，axis=1表示按行计算</span></span><br><span class="line"><span class="string">     cp.sum(x,axis=0,keepdims=True)==d,     #构造约束条件2，axis=0表示按列计算</span></span><br><span class="line"><span class="string">     x&gt;=0]</span></span><br><span class="line"><span class="string">prob=cp.Problem(obj,con)    # 构造模型</span></span><br><span class="line"><span class="string">prob.solve(solver=&#x27;SCS&#x27;,verbose=True) #求解模型</span></span><br><span class="line"><span class="string">print(&#x27;最优值为：&#x27;,prob.value)</span></span><br><span class="line"><span class="string">print(&#x27;最优解为：&#x27;,x.value)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d1=pd.read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡21_例4.xlsx&#x27;</span>,header=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#如果excel的数据没有表头的变量，则用header=None后会分配索引，否则会吃掉第一行</span></span><br><span class="line"><span class="comment">#print(d1)</span></span><br><span class="line"></span><br><span class="line">d2=d1.values</span><br><span class="line"><span class="comment">#print(&#x27;d2=:\n&#x27;,d2)</span></span><br><span class="line">c=d2[:-<span class="number">1</span>,:-<span class="number">1</span>] <span class="comment">#读取d2中除最后一行一列的数据</span></span><br><span class="line"><span class="comment">#print(&#x27;c= \n&#x27;,c)</span></span><br><span class="line"></span><br><span class="line">e=d2[:-<span class="number">1</span>,-<span class="number">1</span>].reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"> <span class="comment">#数据表中的最后一列（不包括该列的最后一个元素）,reshape(-1,1)表示生成1列</span></span><br><span class="line">d=d2[-<span class="number">1</span>,:-<span class="number">1</span>].reshape(<span class="number">1</span>,-<span class="number">1</span>) </span><br><span class="line"> <span class="comment">#数据表中的最后一行（不包括该行的最后一个元素），reshape（1，-1）表示生成1行</span></span><br><span class="line"></span><br><span class="line">x=cp.Variable((<span class="number">6</span>,<span class="number">8</span>))</span><br><span class="line">obj=cp.Minimize(cp.<span class="built_in">sum</span>(cp.multiply(c,x))) <span class="comment">#构造目标函数</span></span><br><span class="line"></span><br><span class="line">con=[cp.<span class="built_in">sum</span>(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)&lt;=e,  <span class="comment">#构造约束条件，axis=1表示按行计算</span></span><br><span class="line">    cp.<span class="built_in">sum</span>(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)==d,   <span class="comment">#axis=0表示按列计算</span></span><br><span class="line">     x&gt;=<span class="number">0</span>]</span><br><span class="line">prob=cp.Problem(obj,con) <span class="comment"># 构造模型</span></span><br><span class="line">prob.solve(solver=<span class="string">&#x27;SCS&#x27;</span>,verbose=<span class="literal">True</span>) <span class="comment">#求解模型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优值为：&#x27;</span>,prob.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：&#x27;</span>,x.value)</span><br><span class="line"></span><br><span class="line"><span class="comment">######################这里我出错了，可能没有scs库#######################</span></span><br></pre></td></tr></table></figure>



<h2 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h2><p>灵敏度分析是指对系统因周围条件变化显示出来的敏感程度的分析.</p>
<p>在上一个例题中，都设定了$c_{ij},d_j,e_i$等为常数，但实际问题中，这些系数往往是估计值，或者预测值，经常有少许的变动。</p>
<p>所以提出几点问题</p>
<ul>
<li>如果参数$c_{ij},d_j,e_i$中的一个或几个发生变化，现行最优方案会有什么变化？</li>
<li>将这些参数的变化限制在什么范围下，原最优解任然是最优解？</li>
</ul>
<p>实际上，给定参数量一个步长使其重复求解线性规划问题，以观察最优解的变化情况，这是一个可用的数值方法，特别是计算机求解时。</p>
<h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><p>一家奶制品加工厂用牛奶生成A、B两种奶制品，1桶牛奶可以在<strong>甲类</strong>设备上用<strong>12 h</strong>加工成<strong>3kg A</strong>，或者在<strong>乙类</strong>设备上用<strong>8h <strong>加工成</strong>4kg B.</strong> 假定根据市场需求，生成的A，B全部能售出，且<strong>每千克A 获利24元</strong>，<strong>每千克B 获利16 元</strong>. 现在加工厂<strong>每天能得到50 桶牛奶</strong>的供应，<strong>每天正式工人总的劳动时间为480 h</strong>，并且<strong>甲类设备每天至多能加工100kg A</strong>，<strong>乙类设备的加工能力没有限制</strong>. 试为该厂指定一个生产计划，使每天<strong>获利最大</strong>，并进一步讨论以下两个附加问题：</p>
<p>(1)  若可以聘用临时工人以增加劳动时间，是否聘用临时工人.</p>
<p>(2)  假设由于市场需求变化，每千克A 的获利增加到30元，是否改变生成计划.</p>
<p>解：设$x_1$桶牛奶生成A，$x_2$桶牛奶生成B，每天获利z元</p>
<p>建立方程有：<br>$$<br>min\ z&#x3D;3<em>24x_1+4</em>16x_2&#x3D;72x_1+64x_2\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 50\<br>12x_1+8x_2\leqslant 480\<br>3x_1\leqslant 100\<br>x_1&gt;0,x_2&gt;0<br>\end{cases}<br>$$<br>求解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##我的</span></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">72</span>,-<span class="number">64</span>]<span class="comment">#注意此处是目标系数的相反数</span></span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">12</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">0</span>]]</span><br><span class="line">b=[[<span class="number">50</span>],[<span class="number">480</span>],[<span class="number">100</span>]]</span><br><span class="line">bounds=((<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;求解结果为：\n&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(res.x)</span><br><span class="line"></span><br><span class="line"><span class="comment">##老师的</span></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">72</span>,-<span class="number">64</span>] <span class="comment">#注意此处是目标系数的相反数</span></span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">12</span>,<span class="number">8</span>]]</span><br><span class="line">b=[[<span class="number">50</span>],[<span class="number">480</span>]]</span><br><span class="line">bound=((<span class="number">0</span>,<span class="number">100</span>/<span class="number">3.0</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bound,method=<span class="string">&#x27;simplex&#x27;</span>,options=&#123;<span class="string">&#x27;disp&#x27;</span>:<span class="literal">True</span>&#125;) <span class="comment">#simplex表示单纯形法，</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;求解结果为：\n&#x27;</span>,res)</span><br></pre></td></tr></table></figure>

<p>为什么c&#x3D;[-72,-64]呢？</p>
<ul>
<li>是因为本来这个函数求解的就是最小值，那么要求解最小值的话，变为负数就成为了最大值，但是符号相反。</li>
</ul>
<p>所以最优解为：$x_1&#x3D;20;x_2&#x3D;30$，收益最大化为3360元。</p>
<p>松弛问题slack</p>
<ul>
<li>经过求解可知（slack的两个分量都是0），两个约束条件都是“紧约束”，即最优解是不等式的约束条件达到了边界，约束条件此时实际上是等式约束，（1）所以增加劳动时间，会提高收益，因而附加问题（1）应该聘用临时工人.</li>
</ul>
<p>问题二：</p>
<p>当每千克A 的获利增加到30元<br>$$<br>min\ z&#x3D;3<em>30x_1+4</em>16x_2&#x3D;90x_1+64x_2\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 50\<br>12x_1+8x_2\leqslant 480\<br>3x_1\leqslant 100\<br>x_1&gt;0,x_2&gt;0<br>\end{cases}<br>$$<br>方程几乎不变，只是改变了最优函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">90</span>,-<span class="number">64</span>] <span class="comment">#注意此处是目标系数的相反数</span></span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">12</span>,<span class="number">8</span>]]</span><br><span class="line">b=[[<span class="number">50</span>],[<span class="number">480</span>]]</span><br><span class="line">bound=((<span class="number">0</span>,<span class="number">100</span>/<span class="number">3.0</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bound,method=<span class="string">&#x27;simplex&#x27;</span>,options=&#123;<span class="string">&#x27;disp&#x27;</span>:<span class="literal">True</span>&#125;) <span class="comment">#simplex表示单纯形法，</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;求解结果为：\n&#x27;</span>,res)</span><br></pre></td></tr></table></figure>

<p>最优解不变，但是获得的价为3720.0。所以生产计划不变。</p>
<h2 id="整数规划与非线性规划"><a href="#整数规划与非线性规划" class="headerlink" title="整数规划与非线性规划"></a>整数规划与非线性规划</h2><h3 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h3><p>线性规划的变量是连续型的，但如果变量是离散的非负整数值才有意义，就是整数线性规划，简称整数规划（问题依旧不变，但是物品类似不可分，导致得到的解只有整数解）</p>
<p>求解下列整数线性规划问题<br>$$<br>min\ z&#x3D;40x_1+90x_2\<br>s.t.<br>\begin{cases}<br>9x_1+7x_2\leqslant 56\<br>-7x_1+-20x_2\leqslant -70\<br>x_1&gt;0,x_2&gt;0且为整数<br>\end{cases}<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">c=np.array([<span class="number">40</span>,<span class="number">90</span>])</span><br><span class="line">A=np.array([[<span class="number">9</span>,<span class="number">7</span>],[-<span class="number">7</span>,-<span class="number">20</span>]])</span><br><span class="line">b=np.array([<span class="number">56</span>,-<span class="number">70</span>])</span><br><span class="line">x=cp.Variable(<span class="number">2</span>,integer=<span class="literal">True</span>)  <span class="comment">#定义两个整数决策变量</span></span><br><span class="line"></span><br><span class="line">obj=cp.Minimize(c@x)           <span class="comment">#构造函数</span></span><br><span class="line">cons=[A@x&lt;=b,x&gt;=<span class="number">0</span>]             <span class="comment">#构造约束条件，此处 @表示矩阵与矩阵的乘法</span></span><br><span class="line">prob=cp.Problem(obj,cons)      <span class="comment">#构建问题模型</span></span><br><span class="line">prob.solve(solve=<span class="string">&#x27;GLPK_MI&#x27;</span>,verbose=<span class="literal">True</span>) <span class="comment">#求解问题，GLPK_MI表示单纯性法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优值为：\n&#x27;</span>,prob.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：\n&#x27;</span>,x.value)</span><br></pre></td></tr></table></figure>

<p>最优值为： 350.0                      最优解为： [2. 3.]</p>
<h3 id="指派问题及求解"><a href="#指派问题及求解" class="headerlink" title="指派问题及求解"></a>指派问题及求解</h3><h4 id="标准指派模型"><a href="#标准指派模型" class="headerlink" title="标准指派模型"></a>标准指派模型</h4><p>标准指派问题的数学模型表现为0-1整数规划的形式，当然可以通过整数规划的算法求最优解，但是标准指派问题的数学具有独特的结构，可采用著名的<strong>匈牙利算法</strong>求标准指派问题的最优解。</p>
<hr>
<p>某商业公司计划开办5家新商店，决定由5家建筑公司分别承建. 已知建筑公司$A_i(i&#x3D;1,..,5)$,对新商店$B_j(j&#x3D;1,..,5)$的建造费用的报价（万元）为$c_{ij}(i,j&#x3D;1,..,5)$,如下。为了节省费用，商业公司应当对5家建筑公司怎样分配建造任务，才能使总的建造费最少？</p>
<table>
<thead>
<tr>
<th></th>
<th>$B_1$</th>
<th>$B_2$</th>
<th>$B_3$</th>
<th>$B_4$</th>
<th>$B_5$</th>
</tr>
</thead>
<tbody><tr>
<td>$A_1$</td>
<td>4</td>
<td>8</td>
<td>7</td>
<td>15</td>
<td>12</td>
</tr>
<tr>
<td>$A_2$</td>
<td>7</td>
<td>9</td>
<td>17</td>
<td>14</td>
<td>10</td>
</tr>
<tr>
<td>$A_3$</td>
<td>6</td>
<td>9</td>
<td>12</td>
<td>8</td>
<td>7</td>
</tr>
<tr>
<td>$A_4$</td>
<td>6</td>
<td>7</td>
<td>14</td>
<td>6</td>
<td>10</td>
</tr>
<tr>
<td>$A_5$</td>
<td>6</td>
<td>9</td>
<td>12</td>
<td>10</td>
<td>6</td>
</tr>
</tbody></table>
<p>解：这是一个标准的指派问题. 引进0-1变量<br>$$<br>x_{ij}<br>\begin{cases}<br>1,A_i承建B_j;\<br>0,A_i不承建B_j;\<br>\end{cases}<br>\ \ \ (i,j&#x3D;1,2,3,4,5)<br>$$<br>建立数学模型：<br>$$<br>min\ z&#x3D;\sum_{i&#x3D;1}^{5}\sum_{j&#x3D;1}^{5}c_{ij}+x_{ij}\<br>s.t.<br>\begin{cases}<br>\sum_{j&#x3D;1}^{5}x_{ij}&#x3D;1,i&#x3D;1,2,…,5\<br>\sum_{i&#x3D;1}^{5}x_{ij}&#x3D;1,i&#x3D;1,2,…,5\<br>x_{ij}&#x3D;0\ or\ 1,(i,j&#x3D;1,2,…,5)<br>\end{cases}<br>(意思是每个房子都要建且只能是一个建筑队去建且要不不建要不建)<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"></span><br><span class="line">c=np.array([</span><br><span class="line">    [<span class="number">4</span>	,<span class="number">8</span>	,<span class="number">7</span>	,<span class="number">15</span>	,<span class="number">12</span>],</span><br><span class="line">    [<span class="number">7</span>	,<span class="number">9</span>	,<span class="number">17</span>	,<span class="number">14</span>	,<span class="number">10</span>],</span><br><span class="line">    [<span class="number">6</span>	,<span class="number">9</span>	,<span class="number">12</span>	,<span class="number">8</span>	,<span class="number">7</span> ],</span><br><span class="line">    [<span class="number">6</span>	,<span class="number">7</span>	,<span class="number">14</span>	,<span class="number">6</span>	,<span class="number">10</span>],</span><br><span class="line">    [<span class="number">6</span>	,<span class="number">9</span>	,<span class="number">12</span>	,<span class="number">10</span>	,<span class="number">6</span> ] ])</span><br><span class="line">x=cp.Variable((<span class="number">5</span>,<span class="number">5</span>),integer=<span class="literal">True</span>) <span class="comment">#定义5*5的整型变量</span></span><br><span class="line"></span><br><span class="line">obj=cp.Minimize(cp.<span class="built_in">sum</span>(cp.multiply(c,x)))   <span class="comment">#构造函数</span></span><br><span class="line">con=[<span class="number">0</span>&lt;=x,x&lt;=<span class="number">1</span>,cp.<span class="built_in">sum</span>(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)==<span class="number">1</span>,</span><br><span class="line">     cp.<span class="built_in">sum</span>(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)==<span class="number">1</span>]</span><br><span class="line"><span class="comment"># axis=0表示按列相加，keepdims=True指保持其二维特性</span></span><br><span class="line">prob=cp.Problem(obj,con)</span><br><span class="line">prob.solve(solver=<span class="string">&#x27;GLPK_MI&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优值为：&#x27;</span>,prob.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：\n&#x27;</span>,x.value)</span><br></pre></td></tr></table></figure>

<h4 id="广义指派模型"><a href="#广义指派模型" class="headerlink" title="广义指派模型"></a>广义指派模型</h4><h5 id="最大化指派模型"><a href="#最大化指派模型" class="headerlink" title="最大化指派模型"></a>最大化指派模型</h5><p>在实际应用中，常会遇到各种非标准形式的指派问题—广义指派问题，通常的处理方法是<strong>先讲它们转化为标准形式，然后再用匈牙利算法求解</strong><strong>.</strong></p>
<p>一些指派问题中，每人完成各项工作的<strong>效率</strong>可能是诸如<strong>利润、业绩</strong>等(效益型指标&#x2F;指标体现)，此时则以总的工作效率最大为目标函数，即<br>$$<br>max\ z&#x3D;\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij}<br>$$<br>对于最大化指派问题，若令：<br>$$<br>M&#x3D;\max_{i\leqslant n,j\leqslant n} {c_{ij} }<br>$$<br>再由于约束函数条件的限制<br>$$<br>\sum^{n}<em>{i&#x3D;1}\sum</em>{j&#x3D;1}^{n}x_{ij}&#x3D;n<br>$$<br>则有：<br>$$<br>min\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}(M-c_{ij})x_{ij}\<br>&#x3D;min(\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}Mx_{ij}-\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij})\<br>&#x3D;nM-max\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \<br>$$<br>即<br>$$<br>max\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij}&#x3D;<br>nM-min\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}(M-c_{ij})x_{ij}<br>$$<br>于是，使得$C&#x3D;(c_{ij})<em>{n\times n}$为效率矩阵的最大化指派问题，就转化为求以$(M-c</em>{ij})_{n\times n}$为效率矩阵的标准指派问题。</p>
<h5 id="人数和任务数不等的指派问题"><a href="#人数和任务数不等的指派问题" class="headerlink" title="人数和任务数不等的指派问题"></a>人数和任务数不等的指派问题</h5><ul>
<li>若人数少于任务数，添加虚拟的“人”，对应的效率取为0</li>
<li>若人数多于任务数，添加虚拟的“任务”，对应的效率取为0</li>
</ul>
<h5 id="一个人可完成多项任务的指派问题"><a href="#一个人可完成多项任务的指派问题" class="headerlink" title="一个人可完成多项任务的指派问题"></a>一个人可完成多项任务的指派问题</h5><ul>
<li>可将该人看作相同的几个人来接受指派，只需令其完成同一项任务的效率都一样即可</li>
</ul>
<h5 id="某项任务一定不能由某人完成的指派问题"><a href="#某项任务一定不能由某人完成的指派问题" class="headerlink" title="某项任务一定不能由某人完成的指派问题"></a>某项任务一定不能由某人完成的指派问题</h5><ul>
<li>对于这样的指派问题，只需将相应的效率值取成足够大的数即可.</li>
</ul>
<p>注意：上述是理论推导，在实际使用软件求解广义指派问题时，也可直接建立0-1整数规划模型，不需要把广义指派问题化成标准的指派问题.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://javis-yu.github.io">于邦震</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://javis-yu.github.io/archives/a66872a2.html">https://javis-yu.github.io/archives/a66872a2.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://javis-yu.github.io" target="_blank">Javis's Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-6277c3fcf92f7961" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/archives/55b8db93.html"><img class="prev-cover" src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/bg3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">安装 HEXO</div></div></a></div><div class="next-post pull-right"><a href="/archives/12e2ae1e.html"><img class="next-cover" src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/bg3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">电子钟的设计</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/headimg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">于邦震</div><div class="author-info__description">一个苦逼的二本大学生挣扎的历史</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Javis-Yu"><i class="fab fa-github"></i><span>我的GitHub 一起玩丫😘~</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Javis-Yu" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:yubangzhenmo@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://user.qzone.qq.com/1213695387" rel="external nofollow noreferrer" target="_blank" title="QQ：1213695387"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://mp.weixin.qq.com/s/I-0GQGbZmyjvwCht4vdwCw" rel="external nofollow noreferrer" target="_blank" title="微信公众号：浮生有雨秃头路"><i class="fa-brands fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">保证会持续更新有意思的知识🤯，不过希望您们喜欢🥴！！可以在留言里告诉我🥳，说不定下一个就更新你想知道的内容哦☕！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.</span> <span class="toc-text">数学建模</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0"><span class="toc-number">2.</span> <span class="toc-text">数学建模学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.0.1.</span> <span class="toc-text">建模方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.2.</span> <span class="toc-text">微分方程建模方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8C%89%E8%A7%84%E5%BE%8B%E7%9B%B4%E6%8E%A5%E5%88%97%E6%96%B9%E7%A8%8B"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">1.    按规律直接列方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BE%AE%E5%85%83%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">2.    微元分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A8%A1%E6%8B%9F%E8%BF%91%E4%BC%BC%E6%B3%95"><span class="toc-number">2.0.2.4.</span> <span class="toc-text">3.    模拟近似法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lorenz%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B7%E6%B2%8C%E6%95%88%E5%BA%94"><span class="toc-number">2.0.3.</span> <span class="toc-text">Lorenz模型的混沌效应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Malthus%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.4.</span> <span class="toc-text">Malthus模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A8%A1%E5%9E%8B%E5%81%87%E8%AE%BE"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">1.模型假设</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%B1%82%E8%A7%A3"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">2.建模与求解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7"><span class="toc-number">2.0.4.3.</span> <span class="toc-text">3.模型评价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%A8%A1%E5%9E%8B%E6%94%B9%E8%BF%9B"><span class="toc-number">2.0.4.4.</span> <span class="toc-text">4.模型改进</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E5%86%8D%E6%AC%A1%E5%81%87%E8%AE%BE"><span class="toc-number">2.0.4.4.1.</span> <span class="toc-text">模型再次假设</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%B1%82%E8%A7%A3"><span class="toc-number">2.0.4.4.2.</span> <span class="toc-text">模型建立与求解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%A3%80%E9%AA%8C"><span class="toc-number">2.0.4.4.3.</span> <span class="toc-text">模型检验</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">2.0.4.5.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B1%82%E8%A7%A3"><span class="toc-number">2.0.4.5.1.</span> <span class="toc-text">建立模型与求解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1"><span class="toc-number">2.0.4.5.2.</span> <span class="toc-text">参数估计</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95"><span class="toc-number">2.0.4.5.2.1.</span> <span class="toc-text">非线性最小二乘法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95"><span class="toc-number">2.0.4.5.2.2.</span> <span class="toc-text">线性最小二乘法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E6%9F%93%E7%97%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.5.</span> <span class="toc-text">传染病模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E5%81%87%E8%AE%BE"><span class="toc-number">2.0.5.1.</span> <span class="toc-text">模型假设</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E5%BB%BA%E7%AB%8B"><span class="toc-number">2.0.5.2.</span> <span class="toc-text">模型建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%B1%82%E8%A7%A3%E4%B8%8E%E5%88%86%E8%A7%A3"><span class="toc-number">2.0.5.3.</span> <span class="toc-text">模型求解与分解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.0.5.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1-1"><span class="toc-number">2.0.5.5.</span> <span class="toc-text">参数估计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">2.0.5.6.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.0.5.6.1.</span> <span class="toc-text">程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88"><span class="toc-number">2.0.6.</span> <span class="toc-text">插值与拟合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%9F%E5%90%88%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">2.0.6.1.</span> <span class="toc-text">拟合函数的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8B%9F%E5%90%88python%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">2.0.6.2.</span> <span class="toc-text">数据拟合python程序实现：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%B8%80"><span class="toc-number">2.0.6.2.1.</span> <span class="toc-text">例题一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%BA%8C"><span class="toc-number">2.0.6.2.2.</span> <span class="toc-text">例题二</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%B8%89"><span class="toc-number">2.0.6.2.3.</span> <span class="toc-text">例题三</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%9B%9B"><span class="toc-number">2.0.6.2.4.</span> <span class="toc-text">例题四</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B9%8B%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90"><span class="toc-number">2.0.7.</span> <span class="toc-text">数学建模之回归分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.7.1.</span> <span class="toc-text">多元线性回归模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.0.7.2.</span> <span class="toc-text">主要步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%B1%E8%A7%82%E5%AF%9F%E7%A1%AE%E5%AE%9A%E5%9B%9E%E5%BD%92%E7%B3%BB%E6%95%B0"><span class="toc-number">2.0.7.2.1.</span> <span class="toc-text">由观察确定回归系数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%BA%BF%E6%80%A7%E5%85%B3%E7%B3%BB%E3%80%81%E8%87%AA%E5%8F%98%E9%87%8F%E7%9A%84%E6%98%BE%E8%91%97%E6%80%A7%E8%BF%9B%E8%A1%8C%E7%BB%9F%E8%AE%A1%E6%A3%80%E9%AA%8C"><span class="toc-number">2.0.7.2.2.</span> <span class="toc-text">对线性关系、自变量的显著性进行统计检验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%9B%9E%E5%BD%92%E6%96%B9%E7%A8%8B%E8%BF%9B%E8%A1%8C%E9%A2%84%E6%B5%8B"><span class="toc-number">2.0.7.2.3.</span> <span class="toc-text">利用回归方程进行预测</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E4%B8%80%EF%BC%9A"><span class="toc-number">2.0.7.3.</span> <span class="toc-text">例题一：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%80%EF%BC%9A%E5%88%A9%E7%94%A8%E6%A8%A1%E5%9D%97sklearn-linear-model%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0LinearRegression%E6%B1%82%E8%A7%A3"><span class="toc-number">2.0.7.3.1.</span> <span class="toc-text">程序一：利用模块sklearn.linear_model中的函数LinearRegression求解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96%E6%B1%82%E8%A7%A3"><span class="toc-number">2.0.7.4.</span> <span class="toc-text">线性回归模型的正则化求解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%95%E4%B8%80%EF%BC%9A%E5%B2%AD%E5%9B%9E%E5%BD%92"><span class="toc-number">2.0.7.4.1.</span> <span class="toc-text">法一：岭回归</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">2.0.7.4.1.1.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E4%BC%B0%E8%AE%A1%E5%BB%BA%E7%AB%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.7.4.1.2.</span> <span class="toc-text">用最小二乘估计建立模型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A9%E7%94%A8statsmodels%E5%BA%93%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90"><span class="toc-number">2.0.7.4.1.3.</span> <span class="toc-text">利用statsmodels库求解线性回归分析</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%B2%AD%E5%9B%9E%E5%BD%92%E6%96%B9%E7%A8%8B"><span class="toc-number">2.0.7.4.2.</span> <span class="toc-text">改进的模型：岭回归方程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lasson-%E5%9B%9E%E5%BD%92"><span class="toc-number">2.0.7.5.</span> <span class="toc-text">lasson  回归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B"><span class="toc-number">2.0.7.5.1.</span> <span class="toc-text">数学原理简介</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="toc-number">2.0.7.5.1.1.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="toc-number">2.0.7.5.1.2.</span> <span class="toc-text">例题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">常用的数据清洗方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E8%A7%82%E6%B5%8B%E5%A4%84%E7%90%86"><span class="toc-number">2.1.1.</span> <span class="toc-text">重复观测处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">2.1.2.</span> <span class="toc-text">缺失值处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">三种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E6%B3%95%E3%80%81%E5%88%A0%E9%99%A4%E6%B3%95"><span class="toc-number">2.1.2.1.1.</span> <span class="toc-text">过滤法、删除法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%B3%95%E3%80%81%E6%9B%BF%E6%8D%A2%E6%B3%95"><span class="toc-number">2.1.2.1.2.</span> <span class="toc-text">填充法、替换法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%B3%95"><span class="toc-number">2.1.2.1.3.</span> <span class="toc-text">插值法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9Excel%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE-%E5%88%A0%E9%99%A4-%E8%BF%87%E6%BB%A4"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">对Excel文件数据进行数据(删除)过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9excel%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%A1%AE%E5%AE%9E%E5%80%BC%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">对excel表中的确实值进行数据填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%9E%8B%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE%E5%88%A9%E7%94%A8%E6%8F%92%E5%80%BC%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">数值型缺失数据利用插值法进行替换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">2.1.3.</span> <span class="toc-text">异常值处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92"><span class="toc-number">2.2.</span> <span class="toc-text">线性规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95-%E2%80%94%E9%81%8D%E5%8E%86%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">一：单纯形法  —遍历法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9AMatlab%E8%A7%A3%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">二：Matlab解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81python%E6%B1%82%E8%A7%A3"><span class="toc-number">2.2.3.</span> <span class="toc-text">三、python求解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#scipy-optimize%E6%A8%A1%E5%9D%97%E6%B1%82%E8%A7%A3"><span class="toc-number">2.2.3.0.1.</span> <span class="toc-text">scipy.optimize模块求解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-5"><span class="toc-number">2.2.3.0.1.1.</span> <span class="toc-text">例题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%B5%E6%95%8F%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">灵敏度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-6"><span class="toc-number">2.3.1.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92"><span class="toc-number">2.4.</span> <span class="toc-text">整数规划与非线性规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92"><span class="toc-number">2.4.1.</span> <span class="toc-text">整数规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98%E5%8F%8A%E6%B1%82%E8%A7%A3"><span class="toc-number">2.4.2.</span> <span class="toc-text">指派问题及求解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%8C%87%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">标准指派模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E6%8C%87%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">广义指派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8C%96%E6%8C%87%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.2.2.1.</span> <span class="toc-text">最大化指派模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%BA%E6%95%B0%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%95%B0%E4%B8%8D%E7%AD%89%E7%9A%84%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.2.2.</span> <span class="toc-text">人数和任务数不等的指派问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BA%BA%E5%8F%AF%E5%AE%8C%E6%88%90%E5%A4%9A%E9%A1%B9%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.2.3.</span> <span class="toc-text">一个人可完成多项任务的指派问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%90%E9%A1%B9%E4%BB%BB%E5%8A%A1%E4%B8%80%E5%AE%9A%E4%B8%8D%E8%83%BD%E7%94%B1%E6%9F%90%E4%BA%BA%E5%AE%8C%E6%88%90%E7%9A%84%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.2.4.</span> <span class="toc-text">某项任务一定不能由某人完成的指派问题</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/archives/4a17b156.html" title="Hello World"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/bg3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/archives/4a17b156.html" title="Hello World">Hello World</a><time datetime="2022-05-08T16:34:28.389Z" title="发表于 2022-05-09 00:34:28">2022-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/e2465b5f.html" title="这是第一个尝试"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/bg3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="这是第一个尝试"/></a><div class="content"><a class="title" href="/archives/e2465b5f.html" title="这是第一个尝试">这是第一个尝试</a><time datetime="2022-05-08T16:34:28.387Z" title="发表于 2022-05-09 00:34:28">2022-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/d44ed278.html" title="LCD1602程序"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/bg3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LCD1602程序"/></a><div class="content"><a class="title" href="/archives/d44ed278.html" title="LCD1602程序">LCD1602程序</a><time datetime="2020-08-05T04:34:45.000Z" title="发表于 2020-08-05 12:34:45">2020-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/67844827.html" title="Scikit-learn学习"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/bg3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Scikit-learn学习"/></a><div class="content"><a class="title" href="/archives/67844827.html" title="Scikit-learn学习">Scikit-learn学习</a><time datetime="2020-08-05T04:34:45.000Z" title="发表于 2020-08-05 12:34:45">2020-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/54fadd01.html" title="mainim学习2"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/bg3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mainim学习2"/></a><div class="content"><a class="title" href="/archives/54fadd01.html" title="mainim学习2">mainim学习2</a><time datetime="2020-08-05T04:34:45.000Z" title="发表于 2020-08-05 12:34:45">2020-08-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By 于邦震</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">苦逼大学生向您问好 欢迎来到我的 <a href="https://javis-yu.github.io/">小小奋斗史博客</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="486462660" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>