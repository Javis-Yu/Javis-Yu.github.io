<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LCD1602程序</title>
    <url>/archives/d44ed278.html</url>
    <content><![CDATA[<h1 id="LCD1602"><a href="#LCD1602" class="headerlink" title="LCD1602"></a>LCD1602</h1><p>为什么叫1602呢？</p>
<p>原因：LCD的显示是2行，每行只有16个字符显示。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk44.jpg" alt="pk44"></p>
<center>管脚功能</center>

<table>
<thead>
<tr>
<th>引脚</th>
<th>符号</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>VSS</td>
<td>一般接地</td>
</tr>
<tr>
<td>2</td>
<td>VDD</td>
<td>接电源（+5V）</td>
</tr>
<tr>
<td>3</td>
<td>V0</td>
<td>液晶显示器对比度调整端，接正电源时对比度最弱，接地电源时对比度最高（对比度过高时会产生“鬼影”，使用时可以通过一个10K的电位器调整对比度）。</td>
</tr>
<tr>
<td>4</td>
<td>RS</td>
<td>RS为寄存器选择，高电平1时选择数据寄存器、低电平0时选择指令寄存器。</td>
</tr>
<tr>
<td>5</td>
<td>R&#x2F;W</td>
<td>R&#x2F;W为读写信号线，高电平(1)时进行读操作，低电平(0)时进行写操作。</td>
</tr>
<tr>
<td>6</td>
<td>E</td>
<td>E(或EN)端为使能(enable)端，写操作时，下降沿使能。读操作时，E高电平有效</td>
</tr>
<tr>
<td>7</td>
<td>DB0</td>
<td>低4位三态、 双向数据总线 0位（最低位）</td>
</tr>
<tr>
<td>8</td>
<td>DB1</td>
<td>低4位三态、 双向数据总线 1位</td>
</tr>
<tr>
<td>9</td>
<td>DB2</td>
<td>低4位三态、 双向数据总线 2位</td>
</tr>
<tr>
<td>10</td>
<td>DB3</td>
<td>低4位三态、 双向数据总线 3位</td>
</tr>
<tr>
<td>11</td>
<td>DB4</td>
<td>高4位三态、 双向数据总线 4位</td>
</tr>
<tr>
<td>12</td>
<td>DB5</td>
<td>高4位三态、 双向数据总线 5位</td>
</tr>
<tr>
<td>13</td>
<td>DB6</td>
<td>高4位三态、 双向数据总线 6位</td>
</tr>
<tr>
<td>14</td>
<td>DB7</td>
<td>高4位三态、 双向数据总线 7位（最高位）（也是busy flag）</td>
</tr>
<tr>
<td>15</td>
<td>BLA</td>
<td>背光电源正极 （仿真中没有）</td>
</tr>
<tr>
<td>16</td>
<td>BLK</td>
<td>背光 电源负极（仿真中没有）</td>
</tr>
</tbody></table>
<center>显示地址</center>

<table>
<thead>
<tr>
<th>00H</th>
<th>01H</th>
<th>02H</th>
<th>03H</th>
<th>04H</th>
<th>05H</th>
<th>06H</th>
<th>07H</th>
<th>08H</th>
<th>09H</th>
<th>0AH</th>
<th>0BH</th>
<th>0CH</th>
<th>0DH</th>
<th>0EH</th>
<th>0FH</th>
</tr>
</thead>
<tbody><tr>
<td>40H</td>
<td>41H</td>
<td>42H</td>
<td>43H</td>
<td>44H</td>
<td>45H</td>
<td>46H</td>
<td>47H</td>
<td>48H</td>
<td>49H</td>
<td>4AH</td>
<td>4BH</td>
<td>4CH</td>
<td>4DH</td>
<td>4EH</td>
<td>4FH</td>
</tr>
</tbody></table>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk43.png" alt="pk43"></p>
<p>本身的原始地址 ：0x80  则要找的地址为：0x80+00  0x80+01 …</p>
<center>指令</center>

<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk48.png" alt="pk48"></p>
<p>常用的指令：</p>
<p>0x38 : 设置16 * 2显示，5 * 7点阵 ，8位数据接口</p>
<p>0x0C : 设置开显示 ，不显示光标</p>
<p>0x06 : 写一个字符后地址指针+1</p>
<p>0x01 :显示清0   数据指针清0</p>
<p>0x80 : LCD第一行的起始地址</p>
<p>0x80+0x40 :  LCD第二行的起始地址</p>
<center>时序图</center>

<p>看懂时序图：<a href="https://blog.csdn.net/u010794281/article/details/46273479">https://blog.csdn.net/u010794281/article/details/46273479</a> 可以参考讲解</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk46.png" alt="pk46"></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk47.png" alt="pk47"></p>
]]></content>
      <categories>
        <category>硬件类</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Proteus_keil仿真单片机二</title>
    <url>/archives/570258ab.html</url>
    <content><![CDATA[<h1 id="Proteus-keil仿真单片机二"><a href="#Proteus-keil仿真单片机二" class="headerlink" title="Proteus_keil仿真单片机二"></a>Proteus_keil仿真单片机二</h1><h2 id="LED灯的使用及流水灯的实现"><a href="#LED灯的使用及流水灯的实现" class="headerlink" title="LED灯的使用及流水灯的实现"></a>LED灯的使用及流水灯的实现</h2><h3 id="LED灯的介绍"><a href="#LED灯的介绍" class="headerlink" title="LED灯的介绍"></a>LED灯的介绍</h3><p><strong>发光二极管</strong>（LED）：在电路及仪器中作为指示灯，或者组成文字或数字显示。</p>
<p>单向导通性，导致发光二极管要又PN断点之分，所以就会产生共阴极和共阳极区别（在后面讨论）</p>
<p>​											     <em><strong>控制电流从P端口流向N端口。</strong></em></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/PK14.png" alt="PK14"></p>
<p> 许多的广告牌，是由很多个LED灯不断的闪烁，导致一片区域的灯亮起来，然后形成文字的移动等，led灯的使用有很多地方，LED灯几乎是电器必带的一个，总会显示电器的开关或运行。但LED又是最简单的元器件，许多的单片机或开发板，总会以先控制LED来尝试第一个历程。这里我们先不长篇大论的讨论真实的单片机是如何的，但我觉得有必要先讲解不同，为暂时没资金但未来会买单片机的同学有所提示。</p>
<h4 id="单片机和仿真软件的不同"><a href="#单片机和仿真软件的不同" class="headerlink" title="单片机和仿真软件的不同"></a>单片机和仿真软件的不同</h4><p>1、真实的单片机是已经将电路固定好了，难以改变，我们只能通过外部拓展来来进行我们想要拓展的元器件。但仿真软件的电路是不固定的，可以根据所学的电路分析的知识，来进行电器的连接。这样子我们可以灵活多变的设计电路，这里设计到自己设计PCB板，建议仿真入手，提高理解。</p>
<p>2.单片机的部分引脚拓展了许多的功能，一个引脚便控制多个器件，这样子大大减少了IO口的使用。仿真软件可以灵活的改变引脚。</p>
<p>3.单片机的0端，许多会拓展时钟等，但仿真单片机里面已经自带好了时钟。（这里使用时钟什么的都一样使用。）</p>
<p>未来还会有区别我们在讨论。</p>
<h2 id="创建流水灯项目"><a href="#创建流水灯项目" class="headerlink" title="创建流水灯项目"></a>创建流水灯项目</h2><p>在keil中创建项目，并创建<code>xx.c</code>文件，并设置好输出hex文件的初始设置。</p>
<h3 id="流水灯的设计"><a href="#流水灯的设计" class="headerlink" title="流水灯的设计"></a>流水灯的设计</h3><h3 id="Proteus设计电路"><a href="#Proteus设计电路" class="headerlink" title="Proteus设计电路"></a>Proteus设计电路</h3><p>这里使用AT89C51芯片、led（灯）、res（电阻）。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/prj.png" alt="prj"></p>
<p>选好元器件后，进行摆放。分为共阴极和共阳极（如下）</p>
<h4 id="共阳极"><a href="#共阳极" class="headerlink" title="共阳极"></a>共阳极</h4><p>右上角的三角符号是这个软件的高电位，即电源。所有的流水灯的阳极都是连接在LED灯的P端口，这样子就是共阳极。</p>
<p>然后在看左边，电阻是300欧姆，为什么加电阻呢？</p>
<p>原因很简单，单片机端口是无法承受过大的电流和电压的，电阻是防止过大，导致烧坏芯片；但倘若电阻过大，led灯也可能会不亮。</p>
<p>然后在向左边，这个东西很简单，就是一个端口，两个同名的端口提高命名的方法连接（连接方式在附录），这样子电气图便可以按区块分布。这里我使用了0端口的0~7来控制。当LED灯两端呈现一正一负便可以发光。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk15.png" alt="pk15"></p>
<h4 id="共阴极"><a href="#共阴极" class="headerlink" title="共阴极"></a>共阴极</h4><p>所有的流水灯的阴极都是连接在LED灯的N端口，这样子就是共阴极，与上面的恰恰相反（这里忘了加电阻，不过仿真电路问题不大，我们等等看看会不会出现问题，买的单片机开发板基本上不用考虑电路设计。）</p>
<p>总的电路如下所示：（记得保存）</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk20.png" alt="pk20"></p>
<h3 id="Keil"><a href="#Keil" class="headerlink" title="Keil"></a>Keil</h3><h4 id="流水灯程序实现"><a href="#流水灯程序实现" class="headerlink" title="流水灯程序实现"></a>流水灯程序实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//最基本的程序框架</span><br><span class="line"></span><br><span class="line">#include &quot;reg51.h&quot; 		//这个是89c51的头文件，一般我们都选择是双引号引起来，c语言中，标准库才是使用#include&lt;..&gt; 尖括号，这里一般使用&quot;&quot;较好</span><br><span class="line">sbit LED00=P0^0;		//位操作sbit</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	while(1) 			//这里使用while的原因是因为单片机应当是一直循环执行的。</span><br><span class="line">	&#123;</span><br><span class="line">		//* code *//</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="点亮一个LED灯"><a href="#点亮一个LED灯" class="headerlink" title="点亮一个LED灯"></a>点亮一个LED灯</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line">sbit led00=P0^<span class="number">0</span>;			   <span class="comment">//初始P00口    ^号是选择大端口的一个引脚</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span>     	<span class="comment">//延迟函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">120</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		led00=<span class="number">0</span>;				<span class="comment">//共阳-亮</span></span><br><span class="line">        delay(<span class="number">5</span>);</span><br><span class="line">        led00=<span class="number">1</span>;				<span class="comment">//共阳-灭</span></span><br><span class="line">        delay(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk21.png" alt="pk21"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk23.png" alt="pk23"></p>
<p>在Proteus左下角有个播放键</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk24.png" alt="pk24"></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk25.png" alt="pk25"></p>
<p>若你也是这样子的错误，不要慌。这是因为自己的用户名是英文，使用导致出错。这里建议添加一个英文用户。（若不会的话可以在评论区交流，很简单的）</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/prj.png" alt="prj"></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk26.png" alt="pk26"></p>
<h5 id="流水灯特殊实现"><a href="#流水灯特殊实现" class="headerlink" title="流水灯特殊实现"></a>流水灯特殊实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span>     <span class="comment">//延迟函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">120</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led</span><span class="params">()</span> 				 </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		P0=~(<span class="number">0X01</span>&lt;&lt;i);	  <span class="comment">//P0=~(0X01&lt;&lt;i) 0000 0001  位运算</span></span><br><span class="line">		P1=	<span class="number">0X01</span>&lt;&lt;i;	  <span class="comment">//		      0000 0010	</span></span><br><span class="line">		delay(<span class="number">70</span>);	      <span class="comment">//	 		  0000 0100</span></span><br><span class="line">	&#125;					  <span class="comment">//               ...</span></span><br><span class="line">&#125;									</span><br><span class="line">										</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		led();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>P0&#x3D;~(0X01&lt;&lt;i);	共阳的</p>
<p>P1&#x3D;	0X01&lt;&lt;i;	共阴的</p>
<h5 id="流水灯一般实现"><a href="#流水灯一般实现" class="headerlink" title="流水灯一般实现"></a>流水灯一般实现</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;reg51.h&quot;</span><br><span class="line">unsigned char leddata[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;</span><br><span class="line">//通过控制一个端口的所有引脚 以0000 0000 为16进制数来进行控制。</span><br><span class="line"></span><br><span class="line">void delay(unsigned int n)     //延迟函数</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">	for(i=0;i&lt;n;i++)</span><br><span class="line">    	for(j=0;j&lt;120;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void led() 					</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0;i&lt;8;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		P1=leddata[i];</span><br><span class="line">		delay(70);</span><br><span class="line">		P0=leddata[i];</span><br><span class="line">		delay(70);</span><br><span class="line">	&#125;					</span><br><span class="line">&#125;									</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		led();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk27.png" alt="pk27"></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="一、端口的连接"><a href="#一、端口的连接" class="headerlink" title="一、端口的连接"></a>一、端口的连接</h3><p>首先选好要连接的端口，连接一条线出来，出来一点点的地方双击左键，使得生成节点（在这里属于端口）如下图</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk17.png" alt="pk17"></p>
<p>但这个端口不完整，仅仅是无对应端的端口，然后我们放大线条出现红色虚线，右键选择“放置网络标号”，填写一个唯一的标号，然后再在对应芯片的对应端也做如上方法。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk18.png" alt="pk18"></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk19.png" alt="pk19"></p>
]]></content>
      <categories>
        <category>硬件类</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Proteus 和 Keil --&gt;模拟单片机</title>
    <url>/archives/b256b6b7.html</url>
    <content><![CDATA[<h1 id="Proteus-和-Keil-–-gt-模拟单片机"><a href="#Proteus-和-Keil-–-gt-模拟单片机" class="headerlink" title="Proteus 和 Keil –&gt;模拟单片机"></a>Proteus 和 Keil –&gt;模拟单片机</h1><p>&lt;**献给那些爱学习，但起始资金有很大问题的同学**&gt;</p>
<p>但我还是建议买一个属于自己的单片机，这样子更加能够有实战作用，且能够解决一些软件上的问题。这个工具只能代替你去了解和掌握，但实践起来稍微会有偏差的。</p>
<p>注：<em><strong>本教程不自带软件破解的安装（毕竟有版权、要的话私下私信我们），仅限于安装学习，不可商业化使用。</strong></em></p>
<p>[toc]</p>
<h2 id="Proteus"><a href="#Proteus" class="headerlink" title="Proteus"></a>Proteus</h2><p>Proteus是一款电子设计自动化（EDA）软件，除具有其它EDA软件的仿真功能，还能仿真单片机及其外围器件。</p>
<p>这里我们较多使用为学习单片机的软件工具，不仅仅更加了解电路知识，也让我们学到了51单片机的结构于控制，是很好的搭建单片机的软件，倘若自己也要开发一款PCB电路板，想要看看自己设计的电路的控制情况，这里推荐使用这个。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk1.png" alt="pk1"></p>
<h2 id="Keil"><a href="#Keil" class="headerlink" title="Keil"></a>Keil</h2><p>​		单片机的开发工具，多用于为单片机写程序软件。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk2.png" alt="pk2"></p>
<h2 id="配置软件"><a href="#配置软件" class="headerlink" title="配置软件"></a>配置软件</h2><p>下载好两个文件后，要配置两个文件，使得他们能够相互连通，一个编程，一个仿真实验。</p>
<p>首先，是Proteus，这个比较直接，下载好后可以直接使用，不用太麻烦。</p>
<p>其次，是Keil，要设置好输出文件。</p>
<p>方法：<img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk3.png" alt="pk3"></p>
<p>使得编译好的文件能够烧录到仿真软件中，单片机也是如此。</p>
<h2 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h2><h3 id="Proteus-1"><a href="#Proteus-1" class="headerlink" title="Proteus"></a>Proteus</h3><h4 id="添加元件和使用元件"><a href="#添加元件和使用元件" class="headerlink" title="添加元件和使用元件"></a>添加元件和使用元件</h4><p>有些元件的寻找和放置等使用方式+接地和接电源的符号</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk4.png" alt="pk4"></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk5.png" alt="pk5"></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk6.png" alt="pk6"></p>
<p>Ctrl+s—&gt;保存项目文件</p>
<h3 id="Keil-1"><a href="#Keil-1" class="headerlink" title="Keil"></a>Keil</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk7.png" alt="pk7"></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk8.png" alt="pk8"></p>
<p>这里应该是输入项目名，打错了</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk9.png" alt="pk9"></p>
<p>1处，因为我使用的是Keil5，是不包含51单片机的芯片的，所以我去官网下载了芯片文件，建议去网上下载keil4，减少了许多 麻烦。倘若你和我一样接触过或使用过stm32，可以使用我的方法。这个方法我放到附录中。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/PK10.png" alt="PK10"></p>
<h4 id="创建和添加c文件"><a href="#创建和添加c文件" class="headerlink" title="创建和添加c文件"></a>创建和添加c文件</h4><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk11.png" alt="pk11"></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk12.png" alt="pk12"></p>
<p>这样子基础工作几乎全部搞定。</p>
<p>接下来我们就可以开发了。</p>
<p>下一次更新《LED灯的使用及流水灯的实现》</p>
<p>以后有机会，我会在文章后添加<strong>视频讲解</strong>。比较麻烦啦。但如果许多的关注和“在看”，一定人气了也许就会加倍努力了啦。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h2 id="一、下载-C51相关依赖包"><a href="#一、下载-C51相关依赖包" class="headerlink" title="一、下载 C51相关依赖包"></a>一、下载 C51相关依赖包</h2><p> keil官网下载地址：   <a href="https://www.keil.com/download/product/">https://www.keil.com/download/product/</a></p>
<p>这里我给出来哈：官网有些比较慢，信息填写也麻烦。</p>
<p>链接：<a href="https://pan.baidu.com/s/1I_XyuAOLtgBlcwCW_EAuTw">https://pan.baidu.com/s/1I_XyuAOLtgBlcwCW_EAuTw</a><br>提取码：ju98</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/PK13.png" alt="PK13"></p>
<p>填写好里面的表单，我们便可以下载资料了。</p>
<h3 id="安装包与库文件"><a href="#安装包与库文件" class="headerlink" title="安装包与库文件"></a>安装包与库文件</h3><p>默认配置安装即可，安装位置一般会标出的。</p>
<p>然后就可以了，进入创建项目时，便会有80c51的芯片了。</p>
]]></content>
      <categories>
        <category>硬件类</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora基础</title>
    <url>/archives/e6f98d98.html</url>
    <content><![CDATA[<h1 id="Typora基础（使用篇）"><a href="#Typora基础（使用篇）" class="headerlink" title="Typora基础（使用篇）"></a>Typora基础（使用篇）</h1><blockquote>
<p>Typora让你像写Word一样行云流水<br>(特别提醒(一定使用英文半角符号))</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p>
<ul>
<li>Markdown的语法因不同的解析器或编辑器而异，Typora使用的是<a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/">GitHub Flavored Markdown</a>。</li>
</ul>
<h2 id="Markdown介绍"><a href="#Markdown介绍" class="headerlink" title="Markdown介绍"></a>Markdown介绍</h2><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 <code>.md</code>, <code>.markdown</code>。</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul>
<li>&#x3D;&#x3D;加粗&#x3D;&#x3D;：                 			<code>Ctrl + B</code></li>
<li>标题：                             <code>Ctrl + H</code></li>
<li>插入链接：                      <code>Ctrl + K</code></li>
<li>插入代码：                      <code>Ctrl + Shift + C</code> </li>
<li>行内代码：                      <code>Ctrl + Shift + K</code></li>
<li>插入图片：                      <code>Ctrl + Shift + I</code></li>
<li>无序列表：                      <code>Ctrl + Shift + L</code> </li>
<li>撤销：                             <code>Ctrl + Z</code></li>
<li>一级标题：                      <code>Ctrl + 1~6</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Typora快捷键整合</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">Ctrl+1  		一阶标题    </span></span><br><span class="line"><span class="string">Ctrl+2  		二阶标题    </span></span><br><span class="line"><span class="string">Ctrl+3  		三阶标题    </span></span><br><span class="line"><span class="string">Ctrl+4  		四阶标题    </span></span><br><span class="line"><span class="string">Ctrl+5  		五阶标题    </span></span><br><span class="line"><span class="string">Ctrl+6  		六阶标题    </span></span><br><span class="line"><span class="string">Ctrl+B  		字体加粗</span></span><br><span class="line"><span class="string">Ctrl+I  		字体倾斜</span></span><br><span class="line"><span class="string">Ctrl+U  		下划线</span></span><br><span class="line"><span class="string">Ctrl+Home   	返回Typora顶部</span></span><br><span class="line"><span class="string">Ctrl+End    	返回Typora底部</span></span><br><span class="line"><span class="string">Ctrl+T  		创建表格</span></span><br><span class="line"><span class="string">Ctrl+L  		选中某句话   </span></span><br><span class="line"><span class="string">Ctrl+K  		创建超链接</span></span><br><span class="line"><span class="string">Ctrl+D  		选中某个单词  </span></span><br><span class="line"><span class="string">Ctrl+E  		选中相同格式的文字  </span></span><br><span class="line"><span class="string">Ctrl+H  		搜索并替换</span></span><br><span class="line"><span class="string">Ctrl+F  		搜索</span></span><br><span class="line"><span class="string">Alt+Shift+5 	删除线 </span></span><br><span class="line"><span class="string">Ctrl+Shift+I    插入图片</span></span><br><span class="line"><span class="string">Ctrl+Shift+M 	公式块 </span></span><br><span class="line"><span class="string">Ctrl+Shift+Q    引用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">一些实体符号需要在实体符号之前加”\”才能够显示(很像程序语言的‘转义字符’)</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>





<h3 id="标题级别"><a href="#标题级别" class="headerlink" title="标题级别"></a>标题级别</h3><p>使用#号键1~6个#可以选择标题级数</p>
<p># 一级标题 快捷键为 Ctrl + 1<br>## 二级标题 快捷键为 Ctrl + 2<br>……<br>###### 六级标题 快捷键为 Ctrl + 6</p>
<h3 id="引用文字-gt"><a href="#引用文字-gt" class="headerlink" title="引用文字  &gt;"></a>引用文字  &gt;</h3><p>&gt; + 空格 + 引用文字</p>
<blockquote>
<p>如下形式</p>
</blockquote>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用 * + - 都可以创建一个无序列表</p>
<ul>
<li><code>* 空格 引用文字</code></li>
</ul>
<ul>
<li><p><code>+ 空格 引用文字</code></p>
</li>
<li><p><code>- 空格 引用文字</code></p>
</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用 1. 2. 3. 创建有序列表(与word有点像)</p>
<ol>
<li><p>AAA</p>
</li>
<li><p>BBB</p>
</li>
<li><p>CCC</p>
</li>
</ol>
<h3 id="代码块-反引号-96"><a href="#代码块-反引号-96" class="headerlink" title="代码块  反引号&#96;"></a>代码块  反引号&#96;</h3><p>在Typora中插入程序代码的方式有两种：</p>
<ul>
<li>短：使用反引号&#96;&#96;（即 ~ 键 Tab键上方）<code>。</code>就像这样子短一点的&#96;</li>
<li>长：插入多行代码输入<em><strong>3个反引号 (&#96;)+ 回车</strong></em>，并在后面选择一个语言名称即可实现语法高亮。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">helloworld</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line">(这里使用python语法高亮)</span><br></pre></td></tr></table></figure>



<h3 id="数学表达式（会有公式篇进行细致讲解）"><a href="#数学表达式（会有公式篇进行细致讲解）" class="headerlink" title="数学表达式（会有公式篇进行细致讲解）$$"></a>数学表达式（会有公式篇进行细致讲解）<code>$$</code></h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。根据需要加载 Mathjax 对数学公式进行渲染。</p>
<p><em><strong>按下 <code>$$</code>，然后按下回车键，即可进行数学公式的编辑。</strong></em>（如下形式）</p>
<ul>
<li>$$ 之间的便是要打的代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;_1\times\mathbf&#123;V&#125;_2 = \mathbf&#123;X&#125;_3</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>



<h3 id="插入表格Ctrl-T"><a href="#插入表格Ctrl-T" class="headerlink" title="插入表格Ctrl + T"></a>插入表格<code>Ctrl + T</code></h3><p>输入 <code>| 表头1 | 表头2 |</code>并回车。即可创建一个包含2列表。或快捷键 <code>Ctrl + T</code>弹出对话框。</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">number</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>不管是哪种方式，第一行为表头，第二行为分割表头和主体部分，第三行开始每一行为一个表格行</li>
<li>列与列之间用管道符号<code>|</code> 隔开</li>
<li>还可设置对齐方式(表头与内容之间)，如果不使用对齐标记，内容默认左对齐，表头居中对齐<ul>
<li>左对齐 ：|</li>
<li>右对齐 |：</li>
<li>中对齐 ：|：</li>
</ul>
</li>
<li>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界</li>
<li>为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。</li>
</ul>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>这个例子的脚注为[^1]。写法为：[ ^1]   </p>
<blockquote>
<p> e.g. [^关注我们][^关注我们]</p>
</blockquote>
<p>注意：脚注内容可为任意字符，包括中文。</p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>输入 <code>***</code> 或者 <code>---</code> 再按回车即可绘制一条水平线，如下：</p>
<hr>
<h3 id="目录（TOC）"><a href="#目录（TOC）" class="headerlink" title="目录（TOC）"></a>目录（TOC）</h3><p>输入 <code>[ toc ]</code> 然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h4><p>这是一个带有标题属性的 <code>[链接](http://example.com/ &quot;标题&quot;)</code><br>这是一个没有标题属性的 <code>[链接](http://example.net/)</code></p>
<p><a href="http://example.com/" title="标题">链接</a></p>
<p><a href="http://example.net/">链接</a></p>
<p>虽然看起来没啥区别</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>[读写走停]:<a href="http://guizhidaoshishenme.com/">http://guizhidaoshishenme.com</a>	“关注我们”<br>[id]: <a href="http://example.com/">http://example.com/</a>  “Title Optional”</p>
<h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><p>Typora允许用&lt;括号括起来&gt;, 把URL作为链接插入。</p>
<p>Typora还会自动链接标准网址。</p>
<p><a href="http://guizhidaoshishenme.com/">http://guizhidaoshishenme.com</a></p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![显示的文字](C:\Users\Hider\Desktop\echart.png &quot;图片标题&quot;)</span><br><span class="line">![显示的文字](C:\Users\Hider\Desktop\echart.png)</span><br></pre></td></tr></table></figure>

<p><em><strong>可以拖进来，或者复制粘贴进来</strong></em>          </p>
<p> 前情回顾： 复制粘贴的方式可以使用  <strong>snipaste</strong>  是个应用</p>
<h3 id="斜体-单个星号"><a href="#斜体-单个星号" class="headerlink" title="斜体 *单个星号*"></a>斜体 <code>*单个星号*</code></h3><p>使用 <code>*单个星号*</code> 或者 <code>_单下划线_</code> 可以字体倾斜。快捷键 <code>Ctrl + I</code></p>
<p><em>斜体</em></p>
<h3 id="加粗-两个星号"><a href="#加粗-两个星号" class="headerlink" title="加粗**两个星号**"></a>加粗<code>**两个星号**</code></h3><p>使用 <code>**两个星号**</code> 或者 <code>__两个下划线__</code> 可以字体加粗。快捷键 <code>Ctrl + B</code></p>
<p><strong>加粗</strong></p>
<h3 id="加粗斜体-加粗斜体"><a href="#加粗斜体-加粗斜体" class="headerlink" title="加粗斜体***加粗斜体***"></a>加粗斜体<code>***加粗斜体***</code></h3><p>使用<code>***加粗斜体***</code>可以加粗斜体。</p>
<p><em><strong>加粗斜体</strong></em></p>
<h3 id="删除线-Alt-Shift-5"><a href="#删除线-Alt-Shift-5" class="headerlink" title="删除线 Alt + Shift + 5"></a>删除线 <code>Alt + Shift + 5</code></h3><p>使用<code>~~删除线~~</code> 或快捷键 <code>Alt + Shift + 5</code></p>
<p><del>展示删除线</del></p>
<h3 id="下划线-Ctrl-U"><a href="#下划线-Ctrl-U" class="headerlink" title="下划线  Ctrl + U"></a>下划线  <code>Ctrl + U</code></h3><p>通过<code>&lt;u&gt;下划线的内容&lt;/u&gt;</code> 或者 快捷键<code>Ctrl + U</code>可实现下划线</p>
<p><u>下划线的内容</u></p>
<h3 id="表情符号-："><a href="#表情符号-：" class="headerlink" title="表情符号   ："></a>表情符号   <code>：</code></h3><p>&#x3D;&#x3D;科普&#x3D;&#x3D;：window电脑的中文输入法下：按<code>Ctrl + Shift + B</code>    <em>便可出现微软自带的  emoji表情</em></p>
<p>Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</p>
<p>一定是英文的<code>：</code></p>
<p>:smile   </p>
<p>😺</p>
<h3 id="下标-lt-sub-gt-文本-lt-sub-gt"><a href="#下标-lt-sub-gt-文本-lt-sub-gt" class="headerlink" title="下标&lt;sub&gt;文本&lt;/sub&gt;"></a>下标<code>&lt;sub&gt;文本&lt;/sub&gt;</code></h3><p>可以使用 <sub>eg.</sub><code>&lt;sub&gt;文本&lt;/sub&gt;</code>实现下标。</p>
<p>例如：H<sub>2</sub>O</p>
<h3 id="上标-lt-sup-gt-文本-lt-sup-gt"><a href="#上标-lt-sup-gt-文本-lt-sup-gt" class="headerlink" title="上标&lt;sup&gt;文本&lt;/sup&gt;"></a>上标<code>&lt;sup&gt;文本&lt;/sup&gt;</code></h3><p>可以使用<code>&lt;sup&gt;文本&lt;/sup&gt;</code>实现上标。</p>
<p>X<sup>2</sup>+x&#x3D;1</p>
<h3 id="高亮-高亮"><a href="#高亮-高亮" class="headerlink" title="高亮==高亮=="></a>高亮<code>==高亮==</code></h3><p><code>==高亮==</code></p>
<p>&#x3D;&#x3D;我是高亮&#x3D;&#x3D;</p>
<h3 id="文本居中-lt-center-gt-lt-center-gt"><a href="#文本居中-lt-center-gt-lt-center-gt" class="headerlink" title="文本居中&lt;center&gt;&lt;/center&gt;"></a>文本居中<code>&lt;center&gt;&lt;/center&gt;</code></h3><p>使用 <code>&lt;center&gt;这是要居中的内容&lt;/center&gt;</code>可以使文本居中</p>
<center>这是要居中的文本内容</center>

<h3 id="换行符Enter"><a href="#换行符Enter" class="headerlink" title="换行符Enter"></a>换行符<code>Enter</code></h3><p>或者可以使用<code> &lt;br/&gt;</code>实现换行。html语法</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义 \"></a>转义 \</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line"><span class="bullet">*</span>   星号</span><br><span class="line"><span class="emphasis">_   下划线</span></span><br><span class="line"><span class="emphasis">&#123;&#125;  花括号</span></span><br><span class="line"><span class="emphasis">[]  方括号</span></span><br><span class="line"><span class="emphasis">()  小括号</span></span><br><span class="line"><span class="emphasis">#   井字号</span></span><br><span class="line"><span class="emphasis">+   加号</span></span><br><span class="line"><span class="emphasis">-   减号</span></span><br><span class="line"><span class="emphasis">.   英文句点</span></span><br><span class="line"><span class="emphasis">!   感叹号</span></span><br></pre></td></tr></table></figure>





<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>支持HTML</p>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p>
<p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>建议打开<em><strong>大纲视图  <code>Ctrl + Shift + 1</code></strong></em></p>
</li>
<li><p>许多命令可以，右键可查询</p>
<h1 id="HTML特殊字符编码对照表"><a href="#HTML特殊字符编码对照表" class="headerlink" title="HTML特殊字符编码对照表"></a>HTML特殊字符编码对照表</h1></li>
</ol>
<table>
<thead>
<tr>
<th align="center">特殊符号</th>
<th align="center">命名实体</th>
<th align="center">十进制编码</th>
<th align="center">特殊符号</th>
<th align="center">命名实体</th>
<th align="center">十进制编码</th>
<th align="center">特殊符号</th>
<th align="center">命名实体</th>
<th align="center">十进制编码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Α</td>
<td align="center">&amp;Alpha;</td>
<td align="center">&amp;#913;</td>
<td align="center">Β</td>
<td align="center">&amp;Beta;</td>
<td align="center">&amp;#914;</td>
<td align="center">Γ</td>
<td align="center">&amp;Gamma;</td>
<td align="center">&amp;#915;</td>
</tr>
<tr>
<td align="center">Δ</td>
<td align="center">&amp;Delta;</td>
<td align="center">&amp;#916;</td>
<td align="center">Ε</td>
<td align="center">&amp;Epsilon;</td>
<td align="center">&amp;#917;</td>
<td align="center">Ζ</td>
<td align="center">&amp;Zeta;</td>
<td align="center">&amp;#918;</td>
</tr>
<tr>
<td align="center">Η</td>
<td align="center">&amp;Eta;</td>
<td align="center">&amp;#919;</td>
<td align="center">Θ</td>
<td align="center">&amp;Theta;</td>
<td align="center">&amp;#920;</td>
<td align="center">Ι</td>
<td align="center">&amp;Iota;</td>
<td align="center">&amp;#921;</td>
</tr>
<tr>
<td align="center">Κ</td>
<td align="center">&amp;Kappa;</td>
<td align="center">&amp;#922;</td>
<td align="center">Λ</td>
<td align="center">&amp;Lambda;</td>
<td align="center">&amp;#923;</td>
<td align="center">Μ</td>
<td align="center">&amp;Mu;</td>
<td align="center">&amp;#924;</td>
</tr>
<tr>
<td align="center">Ν</td>
<td align="center">&amp;Nu;</td>
<td align="center">&amp;#925;</td>
<td align="center">Ξ</td>
<td align="center">&amp;Xi;</td>
<td align="center">&amp;#926;</td>
<td align="center">Ο</td>
<td align="center">&amp;Omicron;</td>
<td align="center">&amp;#927;</td>
</tr>
<tr>
<td align="center">Π</td>
<td align="center">&amp;Pi;</td>
<td align="center">&amp;#928;</td>
<td align="center">Ρ</td>
<td align="center">&amp;Rho;</td>
<td align="center">&amp;#929;</td>
<td align="center">Σ</td>
<td align="center">&amp;Sigma;</td>
<td align="center">&amp;#931;</td>
</tr>
<tr>
<td align="center">Τ</td>
<td align="center">&amp;Tau;</td>
<td align="center">&amp;#932;</td>
<td align="center">Υ</td>
<td align="center">&amp;Upsilon;</td>
<td align="center">&amp;#933;</td>
<td align="center">Φ</td>
<td align="center">&amp;Phi;</td>
<td align="center">&amp;#934;</td>
</tr>
<tr>
<td align="center">Χ</td>
<td align="center">&amp;Chi;</td>
<td align="center">&amp;#935;</td>
<td align="center">Ψ</td>
<td align="center">&amp;Psi;</td>
<td align="center">&amp;#936;</td>
<td align="center">Ω</td>
<td align="center">&amp;Omega;</td>
<td align="center">&amp;#937;</td>
</tr>
<tr>
<td align="center">α</td>
<td align="center">&amp;alpha;</td>
<td align="center">&amp;#945;</td>
<td align="center">β</td>
<td align="center">&amp;beta;</td>
<td align="center">&amp;#946;</td>
<td align="center">γ</td>
<td align="center">&amp;gamma;</td>
<td align="center">&amp;#947;</td>
</tr>
<tr>
<td align="center">δ</td>
<td align="center">&amp;delta;</td>
<td align="center">&amp;#948;</td>
<td align="center">ε</td>
<td align="center">&amp;epsilon;</td>
<td align="center">&amp;#949;</td>
<td align="center">ζ</td>
<td align="center">&amp;zeta;</td>
<td align="center">&amp;#950;</td>
</tr>
<tr>
<td align="center">η</td>
<td align="center">&amp;eta;</td>
<td align="center">&amp;#951;</td>
<td align="center">θ</td>
<td align="center">&amp;theta;</td>
<td align="center">&amp;#952;</td>
<td align="center">ι</td>
<td align="center">&amp;iota;</td>
<td align="center">&amp;#953;</td>
</tr>
<tr>
<td align="center">κ</td>
<td align="center">&amp;kappa;</td>
<td align="center">&amp;#954;</td>
<td align="center">λ</td>
<td align="center">&amp;lambda;</td>
<td align="center">&amp;#955;</td>
<td align="center">μ</td>
<td align="center">&amp;mu;</td>
<td align="center">&amp;#956;</td>
</tr>
<tr>
<td align="center">ν</td>
<td align="center">&amp;nu;</td>
<td align="center">&amp;#957;</td>
<td align="center">ξ</td>
<td align="center">&amp;xi;</td>
<td align="center">&amp;#958;</td>
<td align="center">ο</td>
<td align="center">&amp;omicron;</td>
<td align="center">&amp;#959;</td>
</tr>
<tr>
<td align="center">π</td>
<td align="center">&amp;pi;</td>
<td align="center">&amp;#960;</td>
<td align="center">ρ</td>
<td align="center">&amp;rho;</td>
<td align="center">&amp;#961;</td>
<td align="center">ς</td>
<td align="center">&amp;sigmaf;</td>
<td align="center">&amp;#962;</td>
</tr>
<tr>
<td align="center">σ</td>
<td align="center">&amp;sigma;</td>
<td align="center">&amp;#963;</td>
<td align="center">τ</td>
<td align="center">&amp;tau;</td>
<td align="center">&amp;#964;</td>
<td align="center">υ</td>
<td align="center">&amp;upsilon;</td>
<td align="center">&amp;#965;</td>
</tr>
<tr>
<td align="center">φ</td>
<td align="center">&amp;phi;</td>
<td align="center">&amp;#966;</td>
<td align="center">χ</td>
<td align="center">&amp;chi;</td>
<td align="center">&amp;#967;</td>
<td align="center">ψ</td>
<td align="center">&amp;psi;</td>
<td align="center">&amp;#968;</td>
</tr>
<tr>
<td align="center">ω</td>
<td align="center">&amp;omega;</td>
<td align="center">&amp;#969;</td>
<td align="center">ϑ</td>
<td align="center">&amp;thetasym;</td>
<td align="center">&amp;#977;</td>
<td align="center">ϒ</td>
<td align="center">&amp;upsih;</td>
<td align="center">&amp;#978;</td>
</tr>
<tr>
<td align="center">ϖ</td>
<td align="center">&amp;piv;</td>
<td align="center">&amp;#982;</td>
<td align="center">•</td>
<td align="center">&amp;bull;</td>
<td align="center">&amp;#8226;</td>
<td align="center">…</td>
<td align="center">&amp;hellip;</td>
<td align="center">&amp;#8230;</td>
</tr>
<tr>
<td align="center">′</td>
<td align="center">&amp;prime;</td>
<td align="center">&amp;#8242;</td>
<td align="center">″</td>
<td align="center">&amp;Prime;</td>
<td align="center">&amp;#8243;</td>
<td align="center">‾</td>
<td align="center">&amp;oline;</td>
<td align="center">&amp;#8254;</td>
</tr>
<tr>
<td align="center">⁄</td>
<td align="center">&amp;frasl;</td>
<td align="center">&amp;#8260;</td>
<td align="center">℘</td>
<td align="center">&amp;weierp;</td>
<td align="center">&amp;#8472;</td>
<td align="center">ℑ</td>
<td align="center">&amp;image;</td>
<td align="center">&amp;#8465;</td>
</tr>
<tr>
<td align="center">ℜ</td>
<td align="center">&amp;real;</td>
<td align="center">&amp;#8476;</td>
<td align="center">™</td>
<td align="center">&amp;trade;</td>
<td align="center">&amp;#8482;</td>
<td align="center">ℵ</td>
<td align="center">&amp;alefsym;</td>
<td align="center">&amp;#8501;</td>
</tr>
<tr>
<td align="center">←</td>
<td align="center">&amp;larr;</td>
<td align="center">&amp;#8592;</td>
<td align="center">↑</td>
<td align="center">&amp;uarr;</td>
<td align="center">&amp;#8593;</td>
<td align="center">→</td>
<td align="center">&amp;rarr;</td>
<td align="center">&amp;#8594;</td>
</tr>
<tr>
<td align="center">↓</td>
<td align="center">&amp;darr;</td>
<td align="center">&amp;#8595;</td>
<td align="center">↔</td>
<td align="center">&amp;harr;</td>
<td align="center">&amp;#8596;</td>
<td align="center">↵</td>
<td align="center">&amp;crarr;</td>
<td align="center">&amp;#8629;</td>
</tr>
<tr>
<td align="center">⇐</td>
<td align="center">&amp;lArr;</td>
<td align="center">&amp;#8656;</td>
<td align="center">⇑</td>
<td align="center">&amp;uArr;</td>
<td align="center">&amp;#8657;</td>
<td align="center">⇒</td>
<td align="center">&amp;rArr;</td>
<td align="center">&amp;#8658;</td>
</tr>
<tr>
<td align="center">⇓</td>
<td align="center">&amp;dArr;</td>
<td align="center">&amp;#8659;</td>
<td align="center">⇔</td>
<td align="center">&amp;hArr;</td>
<td align="center">&amp;#8660;</td>
<td align="center">∀</td>
<td align="center">&amp;forall;</td>
<td align="center">&amp;#8704;</td>
</tr>
<tr>
<td align="center">∂</td>
<td align="center">&amp;part;</td>
<td align="center">&amp;#8706;</td>
<td align="center">∃</td>
<td align="center">&amp;exist;</td>
<td align="center">&amp;#8707;</td>
<td align="center">∅</td>
<td align="center">&amp;empty;</td>
<td align="center">&amp;#8709;</td>
</tr>
<tr>
<td align="center">∇</td>
<td align="center">&amp;nabla;</td>
<td align="center">&amp;#8711;</td>
<td align="center">∈</td>
<td align="center">&amp;isin;</td>
<td align="center">&amp;#8712;</td>
<td align="center">∉</td>
<td align="center">&amp;notin;</td>
<td align="center">&amp;#8713;</td>
</tr>
<tr>
<td align="center">∋</td>
<td align="center">&amp;ni;</td>
<td align="center">&amp;#8715;</td>
<td align="center">∏</td>
<td align="center">&amp;prod;</td>
<td align="center">&amp;#8719;</td>
<td align="center">∑</td>
<td align="center">&amp;sum;</td>
<td align="center">&amp;#8722;</td>
</tr>
<tr>
<td align="center">−</td>
<td align="center">&amp;minus;</td>
<td align="center">&amp;#8722;</td>
<td align="center">∗</td>
<td align="center">&amp;lowast;</td>
<td align="center">&amp;#8727;</td>
<td align="center">√</td>
<td align="center">&amp;radic;</td>
<td align="center">&amp;#8730;</td>
</tr>
<tr>
<td align="center">∝</td>
<td align="center">&amp;prop;</td>
<td align="center">&amp;#8733;</td>
<td align="center">∞</td>
<td align="center">&amp;infin;</td>
<td align="center">&amp;#8734;</td>
<td align="center">∠</td>
<td align="center">&amp;ang;</td>
<td align="center">&amp;#8736;</td>
</tr>
<tr>
<td align="center">∧</td>
<td align="center">&amp;and;</td>
<td align="center">&amp;#8869;</td>
<td align="center">∨</td>
<td align="center">&amp;or;</td>
<td align="center">&amp;#8870;</td>
<td align="center">∩</td>
<td align="center">&amp;cap;</td>
<td align="center">&amp;#8745;</td>
</tr>
<tr>
<td align="center">∪</td>
<td align="center">&amp;cup;</td>
<td align="center">&amp;#8746;</td>
<td align="center">∫</td>
<td align="center">&amp;int;</td>
<td align="center">&amp;#8747;</td>
<td align="center">∴</td>
<td align="center">&amp;there4;</td>
<td align="center">&amp;#8756;</td>
</tr>
<tr>
<td align="center">∼</td>
<td align="center">&amp;sim;</td>
<td align="center">&amp;#8764;</td>
<td align="center">≅</td>
<td align="center">&amp;cong;</td>
<td align="center">&amp;#8773;</td>
<td align="center">≈</td>
<td align="center">&amp;asymp;</td>
<td align="center">&amp;#8773;</td>
</tr>
<tr>
<td align="center">≠</td>
<td align="center">&amp;ne;</td>
<td align="center">&amp;#8800;</td>
<td align="center">≡</td>
<td align="center">&amp;equiv;</td>
<td align="center">&amp;#8801;</td>
<td align="center">≤</td>
<td align="center">&amp;le;</td>
<td align="center">&amp;#8804;</td>
</tr>
<tr>
<td align="center">≥</td>
<td align="center">&amp;ge;</td>
<td align="center">&amp;#8805;</td>
<td align="center">⊂</td>
<td align="center">&amp;sub;</td>
<td align="center">&amp;#8834;</td>
<td align="center">⊃</td>
<td align="center">&amp;sup;</td>
<td align="center">&amp;#8835;</td>
</tr>
<tr>
<td align="center">⊄</td>
<td align="center">&amp;nsub;</td>
<td align="center">&amp;#8836;</td>
<td align="center">⊆</td>
<td align="center">&amp;sube;</td>
<td align="center">&amp;#8838;</td>
<td align="center">⊇</td>
<td align="center">&amp;supe;</td>
<td align="center">&amp;#8839;</td>
</tr>
<tr>
<td align="center">⊕</td>
<td align="center">&amp;oplus;</td>
<td align="center">&amp;#8853;</td>
<td align="center">⊗</td>
<td align="center">&amp;otimes;</td>
<td align="center">&amp;#8855;</td>
<td align="center">⊥</td>
<td align="center">&amp;perp;</td>
<td align="center">&amp;#8869;</td>
</tr>
<tr>
<td align="center">⋅</td>
<td align="center">&amp;sdot;</td>
<td align="center">&amp;#8901;</td>
<td align="center">⌈</td>
<td align="center">&amp;lceil;</td>
<td align="center">&amp;#8968;</td>
<td align="center">⌉</td>
<td align="center">&amp;rceil;</td>
<td align="center">&amp;#8969;</td>
</tr>
<tr>
<td align="center">⌊</td>
<td align="center">&amp;lfloor;</td>
<td align="center">&amp;#8970;</td>
<td align="center">⌋</td>
<td align="center">&amp;rfloor;</td>
<td align="center">&amp;#8971;</td>
<td align="center">◊</td>
<td align="center">&amp;loz;</td>
<td align="center">&amp;#9674;</td>
</tr>
<tr>
<td align="center">♠</td>
<td align="center">&amp;spades;</td>
<td align="center">&amp;#9824;</td>
<td align="center">♣</td>
<td align="center">&amp;clubs;</td>
<td align="center">&amp;#9827;</td>
<td align="center">♥</td>
<td align="center">&amp;hearts;</td>
<td align="center">&amp;#9829;</td>
</tr>
<tr>
<td align="center">♦</td>
<td align="center">&amp;diams;</td>
<td align="center">&amp;#9830;</td>
<td align="center">空</td>
<td align="center">&amp;nbsp;</td>
<td align="center">&amp;#160;</td>
<td align="center">¡</td>
<td align="center">&amp;iexcl;</td>
<td align="center">&amp;#161;</td>
</tr>
<tr>
<td align="center">¢</td>
<td align="center">&amp;cent;</td>
<td align="center">&amp;#162;</td>
<td align="center">£</td>
<td align="center">&amp;pound;</td>
<td align="center">&amp;#163;</td>
<td align="center">¤</td>
<td align="center">&amp;curren;</td>
<td align="center">&amp;#164;</td>
</tr>
<tr>
<td align="center">¥</td>
<td align="center">&amp;yen;</td>
<td align="center">&amp;#165;</td>
<td align="center">¦</td>
<td align="center">&amp;brvbar;</td>
<td align="center">&amp;#166;</td>
<td align="center">§</td>
<td align="center">&amp;sect;</td>
<td align="center">&amp;#167;</td>
</tr>
<tr>
<td align="center">¨</td>
<td align="center">&amp;uml;</td>
<td align="center">&amp;#168;</td>
<td align="center">©</td>
<td align="center">&amp;copy;</td>
<td align="center">&amp;#169;</td>
<td align="center">ª</td>
<td align="center">&amp;ordf;</td>
<td align="center">&amp;#170;</td>
</tr>
<tr>
<td align="center">«</td>
<td align="center">&amp;laquo;</td>
<td align="center">&amp;#171;</td>
<td align="center">¬</td>
<td align="center">&amp;not;</td>
<td align="center">&amp;#172;</td>
<td align="center">­</td>
<td align="center">&amp;shy;</td>
<td align="center">&amp;#173;</td>
</tr>
<tr>
<td align="center">®</td>
<td align="center">&amp;reg;</td>
<td align="center">&amp;#174;</td>
<td align="center">¯</td>
<td align="center">&amp;macr;</td>
<td align="center">&amp;#175;</td>
<td align="center">°</td>
<td align="center">&amp;deg;</td>
<td align="center">&amp;#176;</td>
</tr>
<tr>
<td align="center">±</td>
<td align="center">&amp;plusmn;</td>
<td align="center">&amp;#177;</td>
<td align="center">²</td>
<td align="center">&amp;sup2;</td>
<td align="center">&amp;#178;</td>
<td align="center">³</td>
<td align="center">&amp;sup3;</td>
<td align="center">&amp;#179;</td>
</tr>
<tr>
<td align="center">´</td>
<td align="center">&amp;acute;</td>
<td align="center">&amp;#180;</td>
<td align="center">µ</td>
<td align="center">&amp;micro;</td>
<td align="center">&amp;#181</td>
<td align="center">“</td>
<td align="center">&amp;quot;</td>
<td align="center">&amp;#34;</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">&amp;lt;</td>
<td align="center">&amp;#60;</td>
<td align="center">&gt;</td>
<td align="center">&amp;gt;</td>
<td align="center">&amp;#62;</td>
<td align="center">‘</td>
<td align="center"></td>
<td align="center">&amp;#39;</td>
</tr>
</tbody></table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">^</span>表示上标，</span><br><span class="line"><span class="keyword">_</span>表示下标，</span><br><span class="line">如果上（下）标内容多于一个字符就需要使用&#123;&#125;，注意不是( ), 因为( )经常是公式本身组成部分，为避免冲突，所以选用了&#123; &#125; 将其包起来<span class="operator">。</span></span><br><span class="line"></span><br><span class="line">示例：<span class="variable">$x</span><span class="operator">^</span>&#123;y<span class="operator">^</span>z&#125;<span class="operator">=</span>(<span class="number">1</span><span class="operator">+</span>e<span class="operator">^</span>x)<span class="operator">^</span>&#123;<span class="operator">-</span>2xy<span class="operator">^</span>w&#125;$</span><br><span class="line"></span><br><span class="line">效果：xyz<span class="operator">=</span>(<span class="number">1</span><span class="operator">+</span>ex)<span class="operator">−</span>2xyw </span><br><span class="line">上面输入的上下标都是在字符的右侧，要想在左侧或者两侧都写上下标，那么需要使用\sideset语法<span class="operator">。</span></span><br><span class="line"></span><br><span class="line">示例：$\sideset&#123;<span class="operator">^</span><span class="number">1_2</span>&#125;&#123;<span class="operator">^</span><span class="number">3_4</span>&#125;\bigotimes$</span><br><span class="line"></span><br><span class="line">效果：<span class="number">12</span><span class="operator">⨂</span><span class="number">34</span> </span><br><span class="line"></span><br><span class="line"><span class="number">3.3</span> 括号和分隔符</span><br><span class="line"></span><br><span class="line">( )和[ ]就是自身了，由于&#123; &#125; 是<span class="type">Tex的元字符，所以表示它自身时需要转义</span><span class="operator">。</span></span><br><span class="line"></span><br><span class="line">示例：<span class="variable">$f</span>(x,y) <span class="operator">=</span> x<span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> y<span class="operator">^</span><span class="number">2</span>, x\epsilon[<span class="number">0</span>,<span class="number">100</span>]$</span><br><span class="line"></span><br><span class="line">效果：f(x,y)<span class="operator">=</span>x2<span class="operator">+</span>y2,xϵ[<span class="number">0</span>,<span class="number">100</span>] </span><br><span class="line">有时候括号需要大号的，普通括号不好看，此时需要使用\left和\right加大括号的大小<span class="operator">。</span></span><br><span class="line"></span><br><span class="line">示例：$(\frac&#123;x&#125;&#123;y&#125;)<span class="operator">^</span><span class="number">8</span>，\left(\frac&#123;x&#125;&#123;y&#125;\right)<span class="operator">^</span><span class="number">8</span>$</span><br><span class="line"></span><br><span class="line">效果：(xy)<span class="number">8</span>，(xy)<span class="number">8</span> </span><br><span class="line">\left和\right必须成对出现，对于不显示的一边可以使用 . 代替<span class="operator">。</span></span><br><span class="line"></span><br><span class="line">示例：$\left.\frac&#123;&#123;\rm d&#125;u&#125;&#123;&#123;\rm d&#125;x&#125; \right<span class="operator">|</span> <span class="keyword">_</span>&#123;x<span class="operator">=</span><span class="number">0</span>&#125;$</span><br><span class="line"></span><br><span class="line">效果：dudx<span class="operator">∣∣</span>x<span class="operator">=</span><span class="number">0</span> </span><br><span class="line"><span class="number">3.4</span> 分数</span><br><span class="line"></span><br><span class="line">使用\frac&#123;分子&#125;&#123;分母&#125;格式，或者 分子\over 分母<span class="operator">。</span></span><br><span class="line"></span><br><span class="line">示例：$\frac&#123;<span class="number">1</span>&#125;&#123;2x<span class="operator">+</span><span class="number">1</span>&#125;或者<span class="number">1</span>\over&#123;2x<span class="operator">+</span><span class="number">1</span>&#125;$</span><br><span class="line"></span><br><span class="line">效果：12x<span class="operator">+</span><span class="number">1</span>或者12x<span class="operator">+</span><span class="number">1</span> </span><br><span class="line"><span class="number">3.5</span> 开方</span><br><span class="line"></span><br><span class="line">示例：$\sqrt[<span class="number">9</span>]&#123;<span class="number">3</span>&#125;和\sqrt&#123;<span class="number">3</span>&#125;$</span><br><span class="line"></span><br><span class="line">效果：<span class="number">3</span><span class="operator">‾‾√</span><span class="number">9</span> 和 <span class="number">3</span><span class="operator">‾‾√</span> </span><br><span class="line"><span class="number">3.6</span> 省略号</span><br><span class="line"></span><br><span class="line">有两种省略号，\ldots 表示语文本底线对其的省略号，\cdots表示与文本中线对其的省略号<span class="operator">。</span></span><br><span class="line"></span><br><span class="line">示例：<span class="variable">$f</span>(x_1, x_2, \ldots, x_n)<span class="operator">=</span>x_1<span class="operator">^</span><span class="number">2</span> <span class="operator">+</span> x_2<span class="operator">^</span><span class="number">2</span><span class="operator">+</span> \cdots <span class="operator">+</span> x_n<span class="operator">^</span><span class="number">2</span>$</span><br><span class="line"></span><br><span class="line">效果：f(x1,x2,<span class="operator">…</span>,xn)<span class="operator">=</span>x21<span class="operator">+</span>x22<span class="operator">+⋯+</span>x2n </span><br><span class="line"><span class="number">3.7</span> 矢量</span><br><span class="line"></span><br><span class="line">示例：$\vec&#123;a&#125; \cdot \vec&#123;b&#125;<span class="operator">=</span><span class="number">0</span>$</span><br><span class="line"></span><br><span class="line">效果: a⃗ <span class="operator">⋅</span>b⃗ <span class="operator">=</span><span class="number">0</span> </span><br><span class="line"><span class="number">3.8</span> 积分</span><br><span class="line"></span><br><span class="line">示例：$\int_0<span class="operator">^</span>1x<span class="operator">^</span><span class="number">2</span>&#123;\rm d&#125;x $</span><br><span class="line"></span><br><span class="line">效果： <span class="operator">∫</span>10x2dx </span><br><span class="line"><span class="number">3.9</span> 极限</span><br><span class="line"></span><br><span class="line">示例：$\lim_&#123;n\rightarrow<span class="operator">+</span>\infty&#125;\frac&#123;<span class="number">1</span>&#125;&#123;n(n<span class="operator">+</span><span class="number">1</span>)&#125;$</span><br><span class="line"></span><br><span class="line">效果： limn<span class="operator">→+∞</span>1n(n<span class="operator">+</span><span class="number">1</span>) </span><br><span class="line"><span class="number">3.10</span> 累加<span class="operator">、</span>累乘</span><br><span class="line"></span><br><span class="line">示例：$\sum_1<span class="operator">^</span>n\frac&#123;<span class="number">1</span>&#125;&#123;x<span class="operator">^</span><span class="number">2</span>&#125;，\prod_&#123;i<span class="operator">=</span><span class="number">0</span>&#125;<span class="operator">^</span>n\frac&#123;<span class="number">1</span>&#125;&#123;x<span class="operator">^</span><span class="number">2</span>&#125;$</span><br><span class="line"></span><br><span class="line">效果：<span class="operator">∑</span>n11x2， <span class="operator">∏</span>ni<span class="operator">=</span>01x2 </span><br><span class="line"><span class="number">3.11</span> 希腊字母</span><br><span class="line"></span><br><span class="line">希腊字符示例：$$\alpha　<span class="type">A</span>　\beta　<span class="type">B</span>　\gamma　\<span class="type">Gamma</span>　\delta　\<span class="type">Delta</span>　\epsilon　<span class="type">E</span> \varepsilon　　\zeta　<span class="type">Z</span>　\eta　<span class="type">H</span>　\theta　\<span class="type">Theta</span>　\vartheta \iota　<span class="type">I</span>　\kappa　<span class="type">K</span>　\lambda　\<span class="type">Lambda</span>　\mu　<span class="type">M</span>　\nu　<span class="type">N</span> \xi　\<span class="type">Xi</span>　o　<span class="type">O</span>　\pi　\<span class="type">Pi</span>　\varpi　　\rho　<span class="type">P</span> \varrho　　\sigma　\<span class="type">Sigma</span>　\varsigma　　\tau　<span class="type">T</span>　\upsilon　\<span class="type">Upsilon</span> \phi　\<span class="type">Phi</span>　\varphi　　\chi　<span class="type">X</span>　\psi　\<span class="type">Psi</span>　\omega　\<span class="type">Omega</span>$$</span><br><span class="line"></span><br><span class="line">效果：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">α　<span class="type">A</span>　β　<span class="type">B</span>　γ　Γ　δ　Δ　ϵ　<span class="type">Eε</span>　　ζ　<span class="type">Z</span>　η　<span class="type">H</span>　θ　Θ　ϑι　<span class="type">I</span>　κ　<span class="type">K</span>　λ　Λ　μ　<span class="type">M</span>　ν　<span class="type">Nξ</span>　Ξ　o　<span class="type">O</span>　π　Π　ϖ　　ρ　<span class="type">Pϱ</span>　　σ　Σ　ς　　τ　<span class="type">T</span>　υ　Υϕ　Φ　φ　　χ　<span class="type">X</span>　ψ　Ψ　ω　Ω</span><br><span class="line"></span><br><span class="line"><span class="number">3.12</span> 数学符号大汇总</span><br><span class="line"><span class="operator">±</span> ：\pm </span><br><span class="line"><span class="operator">×</span> ：\times </span><br><span class="line"><span class="operator">÷</span>：\div </span><br><span class="line"><span class="operator">∣</span>：\mid</span><br><span class="line"></span><br><span class="line"><span class="operator">⋅</span>：\cdot </span><br><span class="line"><span class="operator">∘</span>：\circ </span><br><span class="line"><span class="operator">∗</span>: \ast </span><br><span class="line"><span class="operator">⨀</span>：\bigodot </span><br><span class="line"><span class="operator">⨂</span>：\bigotimes </span><br><span class="line"><span class="operator">⨁</span>：\bigoplus </span><br><span class="line"><span class="operator">≤</span>：\leq </span><br><span class="line"><span class="operator">≥</span>：\geq </span><br><span class="line"><span class="operator">≠</span>：\neq </span><br><span class="line"><span class="operator">≈</span>：\approx </span><br><span class="line"><span class="operator">≡</span>：\equiv </span><br><span class="line"><span class="operator">∑</span>：\sum </span><br><span class="line"><span class="operator">∏</span>：\prod </span><br><span class="line"><span class="operator">∐</span>：\coprod</span><br><span class="line"></span><br><span class="line">集合运算符： </span><br><span class="line"><span class="operator">∅</span>：\emptyset </span><br><span class="line"><span class="operator">∈</span>：\<span class="keyword">in</span> </span><br><span class="line"><span class="operator">∉</span>：\notin </span><br><span class="line"><span class="operator">⊂</span>：\subset </span><br><span class="line"><span class="operator">⊃</span> ：\supset </span><br><span class="line"><span class="operator">⊆</span> ：\subseteq </span><br><span class="line"><span class="operator">⊇</span> ：\supseteq </span><br><span class="line"><span class="operator">⋂</span> ：\bigcap </span><br><span class="line"><span class="operator">⋃</span> ：\bigcup </span><br><span class="line"><span class="operator">⋁</span> ：\bigvee </span><br><span class="line"><span class="operator">⋀</span> ：\bigwedge </span><br><span class="line"><span class="operator">⨄</span> ：\biguplus </span><br><span class="line"><span class="operator">⨆</span>：\bigsqcup</span><br><span class="line"></span><br><span class="line">对数运算符： </span><br><span class="line">log ：\log </span><br><span class="line">lg ：\lg </span><br><span class="line">ln ：\ln</span><br><span class="line"></span><br><span class="line">三角运算符： </span><br><span class="line"><span class="operator">⊥</span>：\bot </span><br><span class="line"><span class="operator">∠</span>：\angle </span><br><span class="line"><span class="number">30</span><span class="operator">∘</span>：<span class="number">30</span><span class="operator">^</span>\circ </span><br><span class="line">sin ：\sin </span><br><span class="line">cos ：\cos </span><br><span class="line">tan ：\tan </span><br><span class="line">cot ：\cot </span><br><span class="line">sec ：\sec </span><br><span class="line">csc ：\csc</span><br><span class="line"></span><br><span class="line">微积分运算符： </span><br><span class="line">y<span class="operator">′</span>x：\prime </span><br><span class="line"><span class="operator">∫</span>：\int </span><br><span class="line"><span class="operator">∬</span> ：\iint </span><br><span class="line"><span class="operator">∭</span> ：\iiint </span><br><span class="line"><span class="operator">⨌</span>：\iiiint </span><br><span class="line"><span class="operator">∮</span> ：\oint </span><br><span class="line">lim ：\lim </span><br><span class="line"><span class="operator">∞</span> ：\infty </span><br><span class="line"><span class="operator">∇</span>：\nabla</span><br><span class="line"></span><br><span class="line">逻辑运算符： </span><br><span class="line"><span class="operator">∵</span>：\because </span><br><span class="line"><span class="operator">∴</span> ：\therefore </span><br><span class="line"><span class="operator">∀</span> ：\forall </span><br><span class="line"><span class="operator">∃</span> ：\exists </span><br><span class="line"><span class="operator">≠</span> ：\not<span class="operator">=</span> </span><br><span class="line"><span class="operator">≯</span>：\not<span class="operator">&gt;</span> </span><br><span class="line"><span class="operator">⊄</span>：\not\subset</span><br><span class="line"></span><br><span class="line">戴帽符号： </span><br><span class="line">ŷ ：\hat&#123;y&#125; </span><br><span class="line">yˇ：\check&#123;y&#125; </span><br><span class="line">y˘：\breve&#123;y&#125;</span><br><span class="line"></span><br><span class="line">连线符号： </span><br><span class="line">a<span class="operator">+</span>b<span class="operator">+</span>c<span class="operator">+</span>d<span class="operator">⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</span>：\overline&#123;a<span class="operator">+</span>b<span class="operator">+</span>c<span class="operator">+</span>d&#125; </span><br><span class="line">a<span class="operator">+</span>b<span class="operator">+</span>c<span class="operator">+</span>d<span class="operator">⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</span>：\underline&#123;a<span class="operator">+</span>b<span class="operator">+</span>c<span class="operator">+</span>d&#125; </span><br><span class="line">a<span class="operator">+</span>b<span class="operator">+</span>c<span class="operator">⏟</span><span class="number">1.0</span><span class="operator">+</span>d<span class="number">2.0</span>：\overbrace&#123;a<span class="operator">+</span>\underbrace&#123;b<span class="operator">+</span>c&#125;<span class="keyword">_</span>&#123;<span class="number">1.0</span>&#125;<span class="operator">+</span>d&#125;<span class="operator">^</span>&#123;<span class="number">2.0</span>&#125;</span><br><span class="line"></span><br><span class="line">箭头符号： </span><br><span class="line"><span class="operator">↑</span>：\uparrow </span><br><span class="line"><span class="operator">↓</span>：\downarrow </span><br><span class="line"><span class="operator">⇑</span> ：\<span class="type">Uparrow</span> </span><br><span class="line"><span class="operator">⇓</span>：\<span class="type">Downarrow</span> </span><br><span class="line"><span class="operator">→</span>：\rightarrow </span><br><span class="line"><span class="operator">←</span> ：\leftarrow </span><br><span class="line"><span class="operator">⇒</span> ：\<span class="type">Rightarrow</span> </span><br><span class="line"><span class="operator">⇐</span> ：\<span class="type">Leftarrow</span> </span><br><span class="line"><span class="operator">⟶</span> ：\longrightarrow </span><br><span class="line"><span class="operator">⟵</span> ：\longleftarrow </span><br><span class="line"><span class="operator">⟹</span>：\<span class="type">Longrightarrow</span> </span><br><span class="line"><span class="operator">⟸</span> ：\<span class="type">Longleftarrow</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.13</span> 需要转义的字符</span><br><span class="line"></span><br><span class="line">要输出字符　空格　#　$　<span class="operator">%</span>　<span class="operator">&amp;</span>　<span class="keyword">_</span>　&#123;　&#125;　，用命令：　\空格　#　\$　\<span class="operator">%</span>　\<span class="operator">&amp;</span>　<span class="keyword">_</span>　&#123;　&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.14</span> 使用指定字体</span><br><span class="line"></span><br><span class="line">&#123;\rm text&#125;如： </span><br><span class="line">使用罗马字体：text text </span><br><span class="line">其他的字体还有： </span><br><span class="line">\rm　　罗马体　　　　　　　\it　　意大利体 </span><br><span class="line">\bf　　黑体　　　　　　　　\cal 　花体 </span><br><span class="line">\sl　　倾斜体　　　　　　　\sf　　等线体 </span><br><span class="line">\mit 　数学斜体　　　　　　\tt　　打字机字体 </span><br><span class="line">\sc　　小体大写字母</span><br></pre></td></tr></table></figure>





<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p>Markdown文档   </p>
<p>网页地址：</p>
<p>[1]	[StackEdit]  <a href="http://xianbai.me/learn-md/article/about/readme.html">http://xianbai.me/learn-md/article/about/readme.html</a></p>
<p>[2]	[Markdown中文文档]  <a href="https://markdown-zh.readthedocs.io/en/latest/">https://markdown-zh.readthedocs.io/en/latest/</a></p>
<p>[3]	[GitHub官方] <a href="https://help.github.com/en/github/writing-on-github/basic-writing-and-formatting-syntax">https://help.github.com/en/github/writing-on-github/basic-writing-and-formatting-syntax</a></p>
<p>[4]    [菜鸟教程  ]<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p>
<p>[5]	[typora官方]<a href="https://typora.io/">https://typora.io/</a></p>
]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Scikit-learn学习</title>
    <url>/archives/67844827.html</url>
    <content><![CDATA[<h1 id="Scikit-learn"><a href="#Scikit-learn" class="headerlink" title="Scikit-learn"></a>Scikit-learn</h1><h2 id="sklearn使用函数的路线图"><a href="#sklearn使用函数的路线图" class="headerlink" title="sklearn使用函数的路线图"></a>sklearn使用函数的路线图</h2><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/sklearn.png" alt="sklearn"></p>
]]></content>
      <categories>
        <category>算法类</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/archives/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>软件类</category>
      </categories>
      <tags>
        <tag>Blog搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>mainim学习2</title>
    <url>/archives/54fadd01.html</url>
    <content><![CDATA[<h1 id="mainim数学动画演示"><a href="#mainim数学动画演示" class="headerlink" title="mainim数学动画演示"></a>mainim数学动画演示</h1><p>上一节我们介绍了关于mainim基础使用，及生成视频的命令简单讲解，和程序的实现。这一节，我们学习更多的实例，进行实例讲解。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] MK成员制作  <a href="https://manim.ml/index.html">https://manim.ml/index.html</a></p>
<p>[2] manim中文教程 <a href="https://github.com/cai-hust/manim-tutorial-CN">https://github.com/cai-hust/manim-tutorial-CN</a></p>
<p>[3] manim官方 <a href="https://github.com/3b1b/manim">https://github.com/3b1b/manim</a></p>
<p>[4] 动画课程<a href="https://github.com/Elteoremadebeethoven/AnimationsWithManim">https://github.com/Elteoremadebeethoven/AnimationsWithManim</a></p>
<p>[5] <em>manim</em>教程 <a href="https://github.com/malhotra5/Manim-Tutorial">https://github.com/malhotra5/Manim-Tutorial</a></p>
]]></content>
      <categories>
        <category>软件类</category>
      </categories>
      <tags>
        <tag>mainim动画</tag>
      </tags>
  </entry>
  <entry>
    <title>mainim</title>
    <url>/archives/22a17072.html</url>
    <content><![CDATA[<h1 id="mainim"><a href="#mainim" class="headerlink" title="mainim"></a>mainim</h1><h2 id="基础安装"><a href="#基础安装" class="headerlink" title="基础安装"></a>基础安装</h2><p>略过…</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里我是使用一位大神的代码进行学习，稍微很多代码会有类似的地方地址放在这里：</p>
<p>(<a href="https://github.com/zimmermant/manim_tutorial/blob/master/manim_tutorial_P37.py">https://github.com/zimmermant/manim_tutorial/blob/master/manim_tutorial_P37.py</a>)   github。</p>
<p>这位大神将动画聚集在一个文件下，但我的学习不会使用它的形式，毕竟视频我是觉得分开先弄弄，减少问题的出现，等熟悉了，在把所有代码放到一起。</p>
<p>若你想使用大神代码学习，形成视频的时候执行<code>python -m manim file_name.py  Class_name -pl</code></p>
<p>file_name.py是代码存放的文件名</p>
<p>Class_name是类函数名</p>
<h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><p>首先，打开  <code>Anaconda Prompt (Anaconda3)</code>右键<em><strong>管理员</strong></em>运行，cd到 manim 根目录：</p>
<p> <code>cd C:\Kuai8Games\manim\manim-master\manim-master</code></p>
<h2 id="测试命令解析"><a href="#测试命令解析" class="headerlink" title="测试命令解析"></a>测试命令解析</h2><h3 id="python-m-manim-manim-example-py-Class-name-pl"><a href="#python-m-manim-manim-example-py-Class-name-pl" class="headerlink" title="python -m manim manim_example.py Class_name -pl"></a><code>python -m manim manim_example.py Class_name -pl</code></h3><p>参数一	<code>python</code>			   调用python编译器进行编译；</p>
<p>参数二	<code>-m</code>					   处理模块，所有依赖都会在延缓队列中执行</p>
<p>参数三	<code>manim</code>				 执行manim.py的文件，不用<code>.py</code> ,-m就可以执行他</p>
<p>参数四  	<code>manim_example.py</code> 	是用来编写图形动画的脚本文件，该参数是需要.py 后缀的；</p>
<p>参数五 	<code>Class_name</code>		定义的一个类的类名；</p>
<p>参数六 	<code>-pl</code> 					更多参数下面命令可查看大全，这里为快速预览p(play播放)   低画质l(low)</p>
<h3 id="参数查看"><a href="#参数查看" class="headerlink" title="参数查看"></a>参数查看</h3><p>​	参数的设置查看：</p>
<p>​		<code>python -m manim --help</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">python -m manim --help</span><br><span class="line">##输出：</span><br><span class="line">usage: manim.py [-h] [-p] [-w] [-s] [-l] [-m] [--high_quality] [-g] [-i] [-f]</span><br><span class="line">                [-t] [-q] [-a] [-o FILE_NAME] [-n START_AT_ANIMATION_NUMBER]</span><br><span class="line">                [-r RESOLUTION] [-c COLOR] [--sound] [--leave_progress_bars]</span><br><span class="line">                [--media_dir MEDIA_DIR]</span><br><span class="line">                [--video_dir VIDEO_DIR | --video_output_dir VIDEO_OUTPUT_DIR]</span><br><span class="line">                [--tex_dir TEX_DIR]</span><br><span class="line">                file [scene_names [scene_names ...]]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  file                  path to file holding the python code for the scene</span><br><span class="line">  scene_names           Name of the Scene class you want to see</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -p, --preview         Automatically open the saved file once its done</span><br><span class="line">  -w, --write_to_movie  Render the scene as a movie file</span><br><span class="line">  -s, --save_last_frame</span><br><span class="line">                        Save the last frame</span><br><span class="line">  -l, --low_quality     Render at a low quality (for faster rendering)</span><br><span class="line">  -m, --medium_quality  Render at a medium quality</span><br><span class="line">  --high_quality        Render at a high quality</span><br><span class="line">  -g, --save_pngs       Save each frame as a png</span><br><span class="line">  -i, --save_as_gif     Save the video as gif</span><br><span class="line">  -f, --show_file_in_finder</span><br><span class="line">                        Show the output file in finder</span><br><span class="line">  -t, --transparent     Render to a movie file with an alpha channel</span><br><span class="line">  -q, --quiet</span><br><span class="line">  -a, --write_all       Write all the scenes from a file</span><br><span class="line">  -o FILE_NAME, --file_name FILE_NAME</span><br><span class="line">                        Specify the name of the output file, ifit should be</span><br><span class="line">                        different from the scene class name</span><br><span class="line">  -n START_AT_ANIMATION_NUMBER, --start_at_animation_number START_AT_ANIMATION_NUMBER</span><br><span class="line">                        Start rendering not from the first animation, butfrom</span><br><span class="line">                        another, specified by its index. If you passin two</span><br><span class="line">                        comma separated values, e.g. &quot;3,6&quot;, it will endthe</span><br><span class="line">                        rendering at the second value</span><br><span class="line">  -r RESOLUTION, --resolution RESOLUTION</span><br><span class="line">                        Resolution, passed as &quot;height,width&quot;</span><br><span class="line">  -c COLOR, --color COLOR</span><br><span class="line">                        Background color</span><br><span class="line">  --sound               Play a success/failure sound</span><br><span class="line">  --leave_progress_bars</span><br><span class="line">                        Leave progress bars displayed in terminal</span><br><span class="line">  --media_dir MEDIA_DIR</span><br><span class="line">                        directory to write media</span><br><span class="line">  --video_dir VIDEO_DIR</span><br><span class="line">                        directory to write file tree for video</span><br><span class="line">  --video_output_dir VIDEO_OUTPUT_DIR</span><br><span class="line">                        directory to write video</span><br><span class="line">  --tex_dir TEX_DIR     directory to write tex</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">##翻译：</span><br><span class="line">用途：manim.py [-h] [-p] [-w] [-s] [-l] [-m] [-高质量] [-g] [-i] [-f)</span><br><span class="line">                [-t] [-q] [-a] [-o 文件名] [-n 开始于动画编号]</span><br><span class="line">                [-r分辨率] [-c颜色] [-声音] [--留下进度条]</span><br><span class="line">                [--media dir MEDIA DIR]</span><br><span class="line">                [--video dir VIDEO DIR |--video output dir VIDEO OUTPUT DIR]</span><br><span class="line">                [--tex dir TEX DIR]</span><br><span class="line">                文件 [scene_names [场景名称...]]</span><br><span class="line"></span><br><span class="line">位置参数。</span><br><span class="line">  file存放场景的python代码的文件路径</span><br><span class="line">  scene_names 您要查看的场景类的名称。</span><br><span class="line"></span><br><span class="line">可选参数。</span><br><span class="line">  -h, --help 显示帮助信息并退出。</span><br><span class="line">  -p, --preview 保存的文件完成后自动打开。</span><br><span class="line">  -w, --write_to_movie 将场景渲染成电影文件。</span><br><span class="line">  -s，-save_last_frame，-save_last_frame。</span><br><span class="line">                        保存最后一帧</span><br><span class="line">  -l, --low_quality 以较低的质量进行渲染（为了更快的渲染）。</span><br><span class="line">  -m, --medium_quality 以中等质量进行渲染。</span><br><span class="line">  --high_quality 高质量渲染。</span><br><span class="line">  -g, --save_pngs 将每一帧画面保存为png格式。</span><br><span class="line">  -i, -save_as_gif 将视频保存为gif格式。</span><br><span class="line">  -f, --show_file_in_finder。</span><br><span class="line">                        在finder中显示输出文件</span><br><span class="line">  -t, --透明 渲染成带有alpha通道的电影文件。</span><br><span class="line">  -q, --安静</span><br><span class="line">  -a, --write_all 从文件中写入所有场景。</span><br><span class="line">  -o FILE_NAME, --file_name FILE_NAME。</span><br><span class="line">                        指定输出文件的名称，如果应该是</span><br><span class="line">                        与场景类名称不同</span><br><span class="line">  -n START_AT_ANIMATION_NUMBER, --start_at_animation_number START_AT_ANIMATION_NUMBER。</span><br><span class="line">                        不是从第一段动画开始渲染，而是从第二段动画开始渲染。</span><br><span class="line">                        另一个，由其索引指定。如果你传入两个</span><br><span class="line">                        逗号分隔的值，例如 &quot;3,6&quot;，它将结束于 &quot;3&quot;。</span><br><span class="line">                        在第二个值上呈现</span><br><span class="line">  -r RESOLUTION, --resolution RESOLUTION(决议)</span><br><span class="line">                        决议，以 &quot;高度、宽度 &quot;通过</span><br><span class="line">  -c COLOR, --color COLOR。</span><br><span class="line">                        背景色</span><br><span class="line">  --播放成功/失败的声音。</span><br><span class="line">  --leave_progress_bars</span><br><span class="line">                        让进度条在终端显示</span><br><span class="line">  --media_dir MEDIA_DIR</span><br><span class="line">                        介质目录</span><br><span class="line">  --video_dir VIDEO_DIR</span><br><span class="line">                        编写视频文件树的目录</span><br><span class="line">  --video_output_dir VIDEO_OUTPUT_DIR</span><br><span class="line">                        写视频的目录</span><br><span class="line">  --tex_dir TEX_DIR目录下写入tex的内容。</span><br></pre></td></tr></table></figure>



<h2 id="代码思路结构与制作"><a href="#代码思路结构与制作" class="headerlink" title="代码思路结构与制作"></a>代码思路结构与制作</h2><h3 id="代码实践一"><a href="#代码实践一" class="headerlink" title="代码实践一"></a>代码实践一</h3><p>文件命名为：first.py，保存到 manim-master 根目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用from 导入模块  </span></span><br><span class="line"><span class="keyword">from</span> manimlib.imports <span class="keyword">import</span> *  <span class="comment">#最重要的文件，manim的最核心的库文件</span></span><br><span class="line"><span class="keyword">import</span> os  						<span class="comment">#系统导入文件</span></span><br><span class="line"><span class="keyword">import</span> pyclbr    		<span class="comment">#可用于确定有关模块中定义的类，方法和顶级函数的一些有限信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类函数，主要是用于 封装、继承、多态</span></span><br><span class="line"><span class="comment">#封装：隐藏对象的属性和实现细节，只对外提供必要的方法。</span></span><br><span class="line"><span class="comment">#继承：(代码复用)，减少重复代码。</span></span><br><span class="line"><span class="comment">#多态：同一个方法调用，由于对象不同可能会产生不同的行为。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chang</span>(<span class="title class_ inherited__">Scene</span>):		<span class="comment">##Scene-&gt;场景，使用继承的方法，继承作者写好的空场景代码。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">##定义一个方法，输入本身为参数，python建议学一点点类。</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self</span>):	<span class="comment">#构建函数</span></span><br><span class="line">    circle = Circle()	<span class="comment">#定义一个圆</span></span><br><span class="line">    square = Square()  <span class="comment">#定义一个方</span></span><br><span class="line">    line=Line(np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]),np.array([<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>]))<span class="comment">#定义线  				</span></span><br><span class="line">    triangle=Polygon(np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]),np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]),np.array([<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>]))</span><br><span class="line">     <span class="comment">#定义一个三角</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">#实例化对象的方法</span></span><br><span class="line">     self.add(line)  						<span class="comment">#添加线段到场景中</span></span><br><span class="line">     self.play(ShowCreation(square))  		<span class="comment">#绘图出圆  &#123;这里很像PPT的制作&#125;</span></span><br><span class="line">     self.play(FadeOut(square))		  		<span class="comment">#淡出圆   </span></span><br><span class="line">     self.play(GrowFromCenter(circle))  	<span class="comment">#中心扩张生成正方形</span></span><br><span class="line">     self.play(Transform(square,triangle))	<span class="comment">#正方形到三角形</span></span><br><span class="line">                      </span><br><span class="line"><span class="comment">#注：我这里为了排版好看，缩进放为两个空格，若你要试试，那便将缩进改为4个空格，或按“Tab”。</span></span><br></pre></td></tr></table></figure>



<h3 id="使用Anaconda-Prompt-将代码变为视频"><a href="#使用Anaconda-Prompt-将代码变为视频" class="headerlink" title="使用Anaconda Prompt 将代码变为视频"></a>使用<code>Anaconda Prompt </code>将代码变为视频</h3><p>打开  <code>Anaconda Prompt (Anaconda3)</code>右键<em><strong>管理员</strong></em>运行，cd到 manim 根目录：</p>
<p> <code>cd C:\Kuai8Games\manim\manim-master\manim-master</code></p>
<p>然后<code>python -m manim first.py Chang -pl</code></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>代码编写有点像PPT的制作。</p>
<p>首先python少不了的库引用，几乎不会改变。</p>
<p>其次，使用类继承空场景的方法，创建一个场景。</p>
<p>然后，定义一个方法，“初始化素材”。先准备好要用的图像</p>
<p>接着，ppt就是准备好素材，组装，然后素材的出现，然后消失。</p>
<p>最后，通过命令将文件输出</p>
<p>代码的结构基本如此，大同小异。不过要更加精彩的话，我们慢慢学。</p>
<h2 id="实践代码与讲解"><a href="#实践代码与讲解" class="headerlink" title="实践代码与讲解"></a>实践代码与讲解</h2><h3 id="代码实践二"><a href="#代码实践二" class="headerlink" title="代码实践二"></a>代码实践二</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MoreShapes</span>(<span class="title class_ inherited__">Scene</span>):</span><br><span class="line">    <span class="comment">#解锁更多的形状  ————依旧先先使用继承，获取</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self</span>):</span><br><span class="line">        circle = Circle(color=PURPLE_A)</span><br><span class="line">        square = Square(fill_color=GOLD_B, fill_opacity=<span class="number">1</span>, color=GOLD_A)</span><br><span class="line">        square.move_to(UP+LEFT)</span><br><span class="line">        circle.surround(square)</span><br><span class="line">        rectangle = Rectangle(height=<span class="number">2</span>, width=<span class="number">3</span>)</span><br><span class="line">        ellipse=Ellipse(width=<span class="number">3</span>, height=<span class="number">1</span>, color=RED)</span><br><span class="line">        ellipse.shift(<span class="number">2</span>*DOWN+<span class="number">2</span>*RIGHT)</span><br><span class="line">        pointer = CurvedArrow(<span class="number">2</span>*RIGHT,<span class="number">5</span>*RIGHT,color=MAROON_C)</span><br><span class="line">        arrow = Arrow(LEFT,UP)</span><br><span class="line">        arrow.next_to(circle,DOWN+LEFT)</span><br><span class="line">        rectangle.next_to(arrow,DOWN+LEFT)</span><br><span class="line">        ring=Annulus(inner_radius=<span class="number">.5</span>, outer_radius=<span class="number">1</span>, color=BLUE)</span><br><span class="line">        ring.next_to(ellipse, RIGHT)</span><br><span class="line"></span><br><span class="line">        self.add(pointer)</span><br><span class="line">        self.play(FadeIn(square))</span><br><span class="line">        self.play(Rotating(square),FadeIn(circle))</span><br><span class="line">        self.play(GrowArrow(arrow))</span><br><span class="line">        self.play(GrowFromCenter(rectangle), GrowFromCenter(ellipse), GrowFromCenter(ring))</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>软件类</category>
      </categories>
      <tags>
        <tag>mainim动画</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn PyTorch—张量</title>
    <url>/archives/bea8daa3.html</url>
    <content><![CDATA[<h1 id="Learn-PyTorch—张量"><a href="#Learn-PyTorch—张量" class="headerlink" title="Learn PyTorch—张量"></a>Learn PyTorch—张量</h1><blockquote>
<p>​张量如同数组和矩阵一样, 是一种特殊的数据结构。在<code>PyTorch</code>中, 神经网络的输入、输出以及网络的参数等数据, 都是使用张量来进行描述。</p>
</blockquote>
<h2 id="张量初始化"><a href="#张量初始化" class="headerlink" title="张量初始化"></a>张量初始化</h2><h3 id="1-直接生成张量"><a href="#1-直接生成张量" class="headerlink" title="1. 直接生成张量"></a><strong>1. 直接生成张量</strong></h3><p>由原始数据直接生成张量, 张量类型由原始数据类型决定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">x_data = torch.tensor(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-通过Numpy数组来生成张量"><a href="#2-通过Numpy数组来生成张量" class="headerlink" title="2. 通过Numpy数组来生成张量"></a><strong>2. 通过Numpy数组来生成张量</strong></h3><p>由已有的<code>Numpy</code>数组来生成张量。张量与Numpy可以相互转化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np_array = np.array(data)</span><br><span class="line">x_np = torch.from_numpy(np_array)</span><br></pre></td></tr></table></figure>



<h3 id="3-通过已有的张量来生成新的张量"><a href="#3-通过已有的张量来生成新的张量" class="headerlink" title="3. 通过已有的张量来生成新的张量"></a><strong>3. 通过已有的张量来生成新的张量</strong></h3><p>新的张量将继承已有张量的数据属性(结构、类型), 也可以重新指定新的数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_ones = torch.ones_like(x_data)   <span class="comment"># 保留 x_data 的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;x_ones&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">x_rand = torch.rand_like(x_data, dtype=torch.<span class="built_in">float</span>)   <span class="comment"># 重写 x_data 的数据类型</span></span><br><span class="line">                                                      <span class="comment"># int -&gt; float</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;x_rand&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ones Tensor:</span><br><span class="line"> tensor([[1, 1],</span><br><span class="line">         [1, 1]])</span><br><span class="line"></span><br><span class="line">Random Tensor:</span><br><span class="line"> tensor([[0.0381, 0.5780],</span><br><span class="line">         [0.3963, 0.0840]])</span><br></pre></td></tr></table></figure>



<h3 id="4-通过指定数据维度来生成张量"><a href="#4-通过指定数据维度来生成张量" class="headerlink" title="4. 通过指定数据维度来生成张量"></a><strong>4. 通过指定数据维度来生成张量</strong></h3><p><code>shape</code>是元组类型, 用来描述张量的维数, 下面3个函数通过传入</p>
<p><code>shape</code>来指定生成张量的维数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shape = (<span class="number">2</span>,<span class="number">3</span>,)</span><br><span class="line">rand_tensor = torch.rand(shape)</span><br><span class="line">ones_tensor = torch.ones(shape)</span><br><span class="line">zeros_tensor = torch.zeros(shape)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Zeros Tensor: \n <span class="subst">&#123;zeros_tensor&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Random Tensor:</span><br><span class="line"> tensor([[0.0266, 0.0553, 0.9843],</span><br><span class="line">         [0.0398, 0.8964, 0.3457]])</span><br><span class="line"></span><br><span class="line">Ones Tensor:</span><br><span class="line"> tensor([[1., 1., 1.],</span><br><span class="line">         [1., 1., 1.]])</span><br><span class="line"></span><br><span class="line">Zeros Tensor:</span><br><span class="line"> tensor([[0., 0., 0.],</span><br><span class="line">         [0., 0., 0.]])</span><br></pre></td></tr></table></figure>



<h2 id="张量属性"><a href="#张量属性" class="headerlink" title="张量属性"></a>张量属性</h2><p>得到张量的维数、数据类型以及它们所存储的设备(CPU或GPU)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor = torch.rand(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Shape of tensor: <span class="subst">&#123;tensor.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Datatype of tensor: <span class="subst">&#123;tensor.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Device tensor is stored on: <span class="subst">&#123;tensor.device&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shape of tensor: torch.Size([3, 4])   # 维数</span><br><span class="line">Datatype of tensor: torch.float32     # 数据类型</span><br><span class="line">Device tensor is stored on: cpu       # 存储设备</span><br></pre></td></tr></table></figure>



<h2 id="张量运算"><a href="#张量运算" class="headerlink" title="张量运算"></a>张量运算</h2><p>这些运算都可以在GPU上运行(相对于CPU来说可以达到更高的运算速度)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断当前环境GPU是否可用, 然后将tensor导入GPU内运行</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">  tensor = tensor.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="1-张量的索引和切片"><a href="#1-张量的索引和切片" class="headerlink" title="1.张量的索引和切片"></a><strong>1.张量的索引和切片</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor = torch.ones(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">tensor[:,<span class="number">1</span>] = <span class="number">0</span>            <span class="comment"># 将第1列(从0开始)的数据全部赋值为0</span></span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br></pre></td></tr></table></figure>



<h3 id="2-张量的拼接"><a href="#2-张量的拼接" class="headerlink" title="2. 张量的拼接"></a><strong>2. 张量的拼接</strong></h3><p>通过<code>torch.cat</code>方法将一组张量按照指定的维度进行拼接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = torch.cat([tensor, tensor, tensor], dim=<span class="number">1</span>)   <span class="comment"># dim=1 为横向拼接</span></span><br><span class="line">t2 = torch.cat([tensor, tensor, tensor], dim=<span class="number">0</span>)   <span class="comment"># dim=0 为纵向拼接</span></span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(t2)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([[1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.]])</span><br><span class="line">        </span><br><span class="line">tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br></pre></td></tr></table></figure>



<h3 id="3-张量的乘积和矩阵乘法"><a href="#3-张量的乘积和矩阵乘法" class="headerlink" title="3. 张量的乘积和矩阵乘法"></a><strong>3. 张量的乘积和矩阵乘法</strong></h3><h4 id="逐个元素相乘"><a href="#逐个元素相乘" class="headerlink" title="逐个元素相乘"></a>逐个元素相乘</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 逐个元素相乘结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;tensor.mul(tensor): \n <span class="subst">&#123;tensor.mul(tensor)&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价写法:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;tensor * tensor: \n <span class="subst">&#123;tensor * tensor&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor.mul(tensor):</span><br><span class="line"> tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br><span class="line"></span><br><span class="line">tensor * tensor:</span><br><span class="line"> tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br></pre></td></tr></table></figure>



<h4 id="张量与张量的矩阵乘法"><a href="#张量与张量的矩阵乘法" class="headerlink" title="张量与张量的矩阵乘法"></a>张量与张量的矩阵乘法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;tensor.matmul(tensor.T): \n <span class="subst">&#123;tensor.matmul(tensor.T)&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="comment"># 等价写法:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;tensor @ tensor.T: \n <span class="subst">&#123;tensor @ tensor.T&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor.matmul(tensor.T):</span><br><span class="line"> tensor([[3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.]])</span><br><span class="line"></span><br><span class="line">tensor @ tensor.T:</span><br><span class="line"> tensor([[3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.]])</span><br></pre></td></tr></table></figure>



<h3 id="4-自动赋值运算"><a href="#4-自动赋值运算" class="headerlink" title="4. 自动赋值运算"></a><strong>4. 自动赋值运算</strong></h3><p>自动赋值运算通常在方法后有 <code>_</code> 作为后缀, 例如: <code>x.copy_(y)</code>, <code>x.t_()</code>操作会改变 <code>x</code> 的取值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tensor, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">tensor.add_(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br><span class="line"></span><br><span class="line">tensor([[6., 5., 6., 6.],</span><br><span class="line">        [6., 5., 6., 6.],</span><br><span class="line">        [6., 5., 6., 6.],</span><br><span class="line">        [6., 5., 6., 6.]])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自动赋值运算虽然可以节省内存, 但在求导时会因为丢失了中间过程而导致一些问题。</p>
</blockquote>
<h2 id="Tensor与Numpy的转化"><a href="#Tensor与Numpy的转化" class="headerlink" title="Tensor与Numpy的转化"></a>Tensor与Numpy的转化</h2><p>张量和<code>Numpy array</code>数组在CPU上可以共用一块内存区域, <code>改变其中一个另一个也会随之改变</code>。</p>
<h3 id="1-由张量变换为Numpy-array数组"><a href="#1-由张量变换为Numpy-array数组" class="headerlink" title="1. 由张量变换为Numpy array数组"></a><strong>1. 由张量变换为Numpy array数组</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = torch.ones(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line">n = t.numpy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t: tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">n: [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br></pre></td></tr></table></figure>



<p>修改张量的值，则<code>Numpy array</code>数组值也会随之改变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t.add_(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t: tensor([<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>])</span><br><span class="line">n: [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br></pre></td></tr></table></figure>



<h2 id="2-由Numpy-array数组转为张量"><a href="#2-由Numpy-array数组转为张量" class="headerlink" title="2. 由Numpy array数组转为张量"></a><strong>2. 由Numpy array数组转为张量</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = np.ones(<span class="number">5</span>)</span><br><span class="line">t = torch.from_numpy(n)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t:tensor([1., 1., 1., 1., 1.], dtype=torch.float64)</span><br><span class="line">t:[1. 1. 1. 1. 1.]</span><br></pre></td></tr></table></figure>



<p>修改<code>Numpy array</code>数组的值，则张量值也会随之改变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.add(n, <span class="number">1</span>, out=n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t: tensor([2., 2., 2., 2., 2.], dtype=torch.float64)</span><br><span class="line">n: [2. 2. 2. 2. 2.]</span><br></pre></td></tr></table></figure>







<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1>]]></content>
      <categories>
        <category>算法类</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>torch.autograd 的简要介绍</title>
    <url>/archives/90c0b5a1.html</url>
    <content><![CDATA[<h1 id="torch-autograd-的简要介绍"><a href="#torch-autograd-的简要介绍" class="headerlink" title="torch.autograd 的简要介绍"></a>torch.autograd 的简要介绍</h1><p><code>torch.autograd</code>是 PyTorch 的自动差分引擎，可为神经网络训练提供支持。</p>
<p>神经网络（NN）是在某些输入数据上执行的嵌套函数的集合。 这些函数由<em>参数</em>（由权重和偏差组成）定义，这些参数在 PyTorch 中存储在张量中。</p>
<blockquote>
<p>训练 NN 分为两个步骤：</p>
<ol>
<li><strong>正向传播</strong>：在正向传播中，NN 对正确的输出进行最佳猜测。 它通过其每个函数运行输入数据以进行猜测。</li>
<li><strong>反向传播</strong>：在反向传播中，NN 根据其猜测中的误差调整其参数。 它通过从输出向后遍历，收集有关函数参数（<em>梯度</em>）的误差导数并使用梯度下降来优化参数来实现。</li>
</ol>
</blockquote>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>首先，需要加载数据，利用<code>torchvision</code>加载准备训练的<code>resnet18</code>模型。</p>
<p>其次，创建一个随机数据张量，具有 3 个通道的单个图像，高度&amp;宽度为 64，其对应的<code>label</code>初始化为一些随机值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch, torchvision	<span class="comment">#引入训练库</span></span><br><span class="line">model = torchvision.models.resnet18(pretrained=<span class="literal">True</span>) <span class="comment">#引入模型</span></span><br><span class="line">data = torch.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>) 	<span class="comment">#创建一个随机张量</span></span><br><span class="line">labels = torch.rand(<span class="number">1</span>, <span class="number">1000</span>)		<span class="comment">#设置随机labels标签</span></span><br></pre></td></tr></table></figure>

<p>接着利用<code>正向传播</code>进行预测。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prediction = model(data) <span class="comment"># forward pass</span></span><br></pre></td></tr></table></figure>

<p>接着我们利用预测的模型和对应标签计算误差<code>loss</code>。进行<code>反向传播</code>此误差。<code>.backward()</code>进行反向传播时，<code>Autograd </code>会为每个模型参数计算梯度并将其存储在参数的<code>.grad</code>属性中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = (prediction - labels).<span class="built_in">sum</span>()</span><br><span class="line">loss.backward() <span class="comment"># backward pass</span></span><br></pre></td></tr></table></figure>

<p>加载一个优化器，使用 梯度下降法(SGD) ，学习率为 0.01，步长为 0.9。 然后在优化器中注册模型的所有参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optim = torch.optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>

<p>然后再调用 <code>.step()</code>启动 梯度下降 模型，优化器利用<code>.grad</code>中存储的梯度来进行调整参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optim.step() <span class="comment">#gradient descent</span></span><br></pre></td></tr></table></figure>

<p>于是便具备训练神经网络的所需数据。</p>
<h2 id="Autograd-的微分"><a href="#Autograd-的微分" class="headerlink" title="Autograd 的微分"></a>Autograd 的微分</h2><p>观察<code>autograd</code>如何收集梯度。利用<code>requires_grad=True</code>创建两个张量<code>a</code>和<code>b</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.tensor([<span class="number">2.</span>, <span class="number">3.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.tensor([<span class="number">6.</span>, <span class="number">4.</span>], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>利用a和b创建张量Q。<br>$$<br>Q&#x3D;3a^3-b^2<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Q = <span class="number">3</span>*a**<span class="number">3</span> - b**<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>设<code>a</code>和<code>b</code>是神经网络的参数，<code>Q</code>是误差。在NN训练中，我们要Q分别对a、b的梯度<br>$$<br>\begin{cases}<br>    \frac{\partial Q}{\partial a} &#x3D; 9a^2<br> \<br> \ \frac{\partial Q}{\partial b} &#x3D; -2b</p>
<p>\end{cases}<br>$$<br><code>Q</code>上调用<code>.backward()</code>时，Autograd 将计算这些梯度并将其存储在各个张量的<code>.grad</code>属性中。</p>
<p>在<code>Q.backward()</code>中显式传递<code>gradient梯度</code>参数，因为它是向量，也就是说梯度反向传播时，会将公式变成矩阵形式进行运算。 <code>gradient梯度</code>是与<code>Q</code>形状相同的张量，它表示<code>Q</code>相对于本身的梯度，即<br>$$<br>\frac{\partial Q}{\partial Q} &#x3D; 1<br>$$<br>我们也可以将<code>Q</code>聚合为一个标量，然后隐式地向后调用，例如<code>Q.sum().backward()</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">external_grad = torch.tensor([<span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">Q.backward(gradient=external_grad)</span><br></pre></td></tr></table></figure>

<p>梯度现在沉积在<code>a.grad</code>和<code>b.grad</code>中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># check if collected gradients are correct</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">9</span>*a**<span class="number">2</span> == a.grad)</span><br><span class="line"><span class="built_in">print</span>(-<span class="number">2</span>*b == b.grad)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([True, True])</span><br><span class="line">tensor([True, True])</span><br></pre></td></tr></table></figure>





<h2 id="使用-autograd-的向量微积分"><a href="#使用-autograd-的向量微积分" class="headerlink" title="使用 autograd 的向量微积分"></a>使用 autograd 的向量微积分</h2><p>$$<br>\begin{cases}<br>    \vec{y}&#x3D;f(\vec{x})……（\mathcal{1}）\<br>    l&#x3D;g(\vec{y})……（\mathcal{2}）</p>
<p>\end{cases}<br>$$</p>
<p>由公式1，我们可以知道    向量y相对于向量x的雅可比矩阵有J：<br>$$<br>J&#x3D;<br>\begin{pmatrix}<br> \frac{\partial y}{\partial x_{1}}  &amp; \dots &amp;\frac{\partial y}{\partial x_{n}}<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br> \frac{\partial y_{1}}{\partial x_{1}} &amp; \dots  &amp; \frac{\partial y_{1}}{\partial x_{n}} \<br> \vdots 							   &amp; \ddots &amp; \vdots								\<br> \frac{\partial y_{m}}{\partial x_{1}} &amp; \dots  &amp; \frac{\partial y_{m}}{\partial x_{n}}<br>\end{pmatrix}<br>$$<br>如果<code>v</code>恰好是标量函数的梯度:<br>$$<br>\vec{v}<br>&#x3D;<br>\begin{pmatrix}<br> \frac{\partial l}{\partial y_{1}}  &amp; \dots &amp;\frac{\partial l}{\partial y_{m}}<br>\end{pmatrix} ^T<br>$$</p>
<p><code>torch.autograd </code> 是用于计算向量雅可比积的引擎。 也就是说，给定任何<code>向量v</code>，计算乘积<code>J^T · v</code></p>
<p>也就是 <code> l 相对于 向量x 的 梯度</code>：<br>$$<br>\frac{\partial l}{\partial \vec{x} }</p>
<h1 id="x3D-J-T-cdot-vec-v"><a href="#x3D-J-T-cdot-vec-v" class="headerlink" title="&#x3D;J^T \cdot \vec{v} "></a>&#x3D;J^T \cdot \vec{v} </h1><p>\begin{pmatrix}<br> \frac{\partial y_{1}}{\partial x_{1}} &amp; \dots  &amp; \frac{\partial y_{1}}{\partial x_{n}} \<br> \vdots 							   &amp; \ddots &amp; \vdots								\<br> \frac{\partial y_{m}}{\partial x_{1}} &amp; \dots  &amp; \frac{\partial y_{m}}{\partial x_{n}}<br>\end{pmatrix}</p>
<p>\begin{pmatrix}<br>\frac{\partial l}{\partial y_{1}} \<br>\vdots  \<br>\frac{\partial l}{\partial y_{m}}<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br>\frac{\partial l}{\partial x_{1}} \<br>\vdots  \<br>\frac{\partial l}{\partial x_{n}}<br>\end{pmatrix}<br>$$<br><code>external_grad</code>表示<code>v</code></p>
<h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><p>Autograd 在由函数对象组成的有向无环图（DAG）中记录数据（张量）和所有已执行的操作（以及由此产生的新张量）。</p>
<p>在正向传播中，Autograd 同时执行两项操作：</p>
<ul>
<li>运行请求的操作以计算结果张量，并且</li>
<li>在 DAG 中维护操作的<em>梯度函数</em>。</li>
</ul>
<p>当在 DAG 根目录上调用<code>.backward()</code>时，后退通道开始。 <code>autograd</code>然后：</p>
<ul>
<li>从每个<code>.grad_fn</code>计算梯度，</li>
<li>将它们累积在各自的张量的<code>.grad</code>属性中，然后</li>
<li>使用链式规则，一直传播到叶子张量。</li>
</ul>
<p><img src="https://pytorch.apachecn.org/docs/1.7/img/1270bde38f2cfccd4900a5df8ac70a7d.png" alt="../../_img/dag_autograd.png"></p>
<p>箭头指向前进的方向。</p>
<p>节点代表正向传播中每个操作的反向函数。 </p>
<p>蓝色的叶节点代表我们的叶张量<code>a</code>和<code>b</code>。</p>
<p>可以修改属性从而达到将齐排除在DAG中：</p>
<blockquote>
<p><code>torch.autograd</code>跟踪所有将其<code>requires_grad</code>标志设置为<code>True</code>的张量的操作。 对于不需要梯度的张量，将此属性设置为<code>False</code>会将其从梯度计算 DAG 中排除。</p>
</blockquote>
<p>所以可以修改  <code>requires_grad</code>的属性为 “False” ，从而达到不进行梯度运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">y = torch.rand(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">z = torch.rand((<span class="number">5</span>, <span class="number">5</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">a = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Does `a` require gradients? : <span class="subst">&#123;a.requires_grad&#125;</span>&quot;</span>)</span><br><span class="line">b = x + z</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Does `b` require gradients?: <span class="subst">&#123;b.requires_grad&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Does `a` require gradients? : False</span><br><span class="line">Does `b` require gradients?: True</span><br></pre></td></tr></table></figure>

<p>在 NN 中，不计算梯度的参数通常称为<strong>冻结参数</strong>。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>将部分参数进行冻结的话，会达到不需要的函数不会进行梯度运算，从而达到减少自动梯度计算，这会带来性能优势。</p>
<p>在微调中，我们冻结了大部分模型，通常仅修改分类器层以对新标签进行预测。</p>
<p>和上面一样，先加载模型并将所有参数进行冻结。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"></span><br><span class="line">model = torchvision.models.resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Freeze all the parameters in the network</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">    param.requires_grad = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>假设我们要在具有 10 个标签的新数据集中微调模型。 在 resnet 中，分类器是最后一个线性层<code>model.fc</code>。 我们可以简单地将其替换为充当我们的分类器的新线性层（默认情况下未冻结）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.fc = nn.Linear(<span class="number">512</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>除了<code>model.fc</code>的参数外，模型中的所有参数都将冻结。 计算梯度的唯一参数是<code>model.fc</code>的权重和偏差。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Optimize only the classifier</span></span><br><span class="line">optimizer = optim.SGD(model.fc.parameters(), lr=<span class="number">1e-2</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>

<p>因此分类器的权重和偏差会在梯度下降运算中进行调整。</p>
]]></content>
      <categories>
        <category>算法类</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch 学习网站</title>
    <url>/archives/3f74665c.html</url>
    <content><![CDATA[<h1 id="pytorch-学习网站"><a href="#pytorch-学习网站" class="headerlink" title="pytorch 学习网站"></a>pytorch 学习网站</h1><p>官网：<a href="https://pytorch.org/">https://pytorch.org/</a></p>
<p>教程官网：<a href="https://pytorch.org/tutorials/">https://pytorch.org/tutorials/</a></p>
<p>中文教程：<a href="https://pytorch.apachecn.org/#/">https://pytorch.apachecn.org/#/</a></p>
<p><a href="https://www.latexlive.com/">在线LaTeX公式编辑器-编辑器 (latexlive.com)</a></p>
]]></content>
      <categories>
        <category>算法类</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>中断程序</title>
    <url>/archives/b25d1379.html</url>
    <content><![CDATA[<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断就是某种原因，使得主程序先执行其他程序。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk40.png" alt="pk40"></p>
<h2 id="中断的允许控制位"><a href="#中断的允许控制位" class="headerlink" title="中断的允许控制位"></a>中断的允许控制位</h2><table>
<thead>
<tr>
<th>IE</th>
<th>D7</th>
<th>D6</th>
<th>D5</th>
<th>D4</th>
<th>D3</th>
<th>D2</th>
<th>D1</th>
<th>D0</th>
</tr>
</thead>
<tbody><tr>
<td>A8H</td>
<td>EA</td>
<td></td>
<td>ET2</td>
<td>ES</td>
<td>ET1</td>
<td>EX1</td>
<td>ET0</td>
<td>EX0</td>
</tr>
</tbody></table>
<p>EA    :中断的总控制位。EA&#x3D;0 屏蔽所有中断请求，EA&#x3D;1，开放中断</p>
<p>ET2  :定时器&#x2F;计数器T2的溢出中断允许位    				 1开启，0屏蔽</p>
<p>ES    :串行口中断的允许位											  1开启，0屏蔽</p>
<p>ET1  :定时器&#x2F;计数器T1的溢出中断允许位					 1开启，0屏蔽</p>
<p>EX1  :外部中断INT1的中断允许位。							  1开启，0屏蔽</p>
<p>ET0  :定时器&#x2F;计数器T0的溢出中断允许位  				   1开启，0屏蔽</p>
<p>EX0 :外部中断INT0的中断允许位。							   1开启，0屏蔽</p>
<h2 id="优先权控制"><a href="#优先权控制" class="headerlink" title="优先权控制"></a>优先权控制</h2><table>
<thead>
<tr>
<th>IP</th>
<th>D7</th>
<th>D6</th>
<th>D5</th>
<th>D4</th>
<th>D3</th>
<th>D2</th>
<th>D1</th>
<th>D0</th>
</tr>
</thead>
<tbody><tr>
<td>B8H</td>
<td></td>
<td></td>
<td>PT2</td>
<td>PS</td>
<td>PT1</td>
<td>PX1</td>
<td>PT0</td>
<td>PX0</td>
</tr>
</tbody></table>
<p>PT2  :定时&#x2F;计数器T2的中断优先权控制位。  52系列才有	  1高优先级，0低优先级</p>
<p>PS    :串行口中断优先级控制位									 			1高优先级，0低优先级</p>
<p>PT1  :定时器&#x2F;计数器T1的中断优先权控制位						    1高优先级，0低优先级</p>
<p>PX1  :外部中断INT1的中断优先权控制位							     1高优先级，0低优先级</p>
<p>PT0  :定时器&#x2F;计数器T0的中断优先权控制位  				   	   1高优先级，0低优先级</p>
<p>PX0  :外部中断INT0的中断优先权控制位							     1高优先级，0低优先级</p>
<h3 id="默认顺序"><a href="#默认顺序" class="headerlink" title="默认顺序"></a>默认顺序</h3><p>​		中断源												优先级顺序</p>
<p>外部中断0														高</p>
<p>定时计数器T0中断										   |</p>
<p>外部中断0														 |</p>
<p>定时计数器T1中断										    |</p>
<p>串行口中断														|</p>
<p>定时计数器T2中断（52的）					   	低</p>
<h2 id="各中断服务程序入口编号-interrupt-number"><a href="#各中断服务程序入口编号-interrupt-number" class="headerlink" title="各中断服务程序入口编号 interrupt [number]"></a>各中断服务程序入口编号 interrupt [number]</h2><p>​		中断源												入口编号</p>
<p>外部中断0（P3.2）											0</p>
<p>定时计数器0										   			 1</p>
<p>外部中断0（P3.3）											 2</p>
<p>定时计数器1										    			 3</p>
<p>串行口中断														   4</p>
<h2 id="定时-x2F-计数器-的方式寄存器-TCON"><a href="#定时-x2F-计数器-的方式寄存器-TCON" class="headerlink" title="定时&#x2F;计数器 的方式寄存器 TCON"></a>定时&#x2F;计数器 的方式寄存器 TCON</h2><table>
<thead>
<tr>
<th align="center">TCON</th>
<th>D7</th>
<th>D6</th>
<th>D5</th>
<th>D4</th>
<th>D3</th>
<th>D2</th>
<th>D1</th>
<th>D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">88H</td>
<td>TF1</td>
<td>TR1</td>
<td>TF0</td>
<td>TR0</td>
<td>IE1</td>
<td>IT1</td>
<td>IE0</td>
<td>IT0</td>
</tr>
</tbody></table>
<p>  TF   定时&#x2F;计数器溢出位,超出上限值就会置1,若进入中断自动清0  定时&#x2F;计数器范围（0—-2<sup>几位定时</sup>-1）</p>
<p>  TR   设置定时计数器是否启动</p>
<p>  IE    外部中断请求标志位</p>
<p>  IT    外部中断的触发方式位   &#x3D;&#x3D;0 电平触发      &#x3D;&#x3D;1边缘触发</p>
<p>$$<br>外部中断\ \ \ \ \  \ \overline{\text{INT0}}\ \ 和  \ \ \overline{\text{INT1}}<br>$$<br>​		加了上划线，则代表为  低电平触发  或者  下降沿触发</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line">sbit ex=P3^<span class="number">2</span>;</span><br><span class="line"><span class="type">char</span> s[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>&#125;;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">initex</span><span class="params">()</span>		<span class="comment">//外部中断0</span></span><br><span class="line">&#123;</span><br><span class="line">	IT0=<span class="number">1</span>;			<span class="comment">//下降沿触发</span></span><br><span class="line">	EX0=<span class="number">1</span>;			<span class="comment">//外部中断INT0的中断允许位开启</span></span><br><span class="line">	EA=<span class="number">1</span>;			<span class="comment">//开启中断总控制位</span></span><br><span class="line">	ex=<span class="number">1</span>;			<span class="comment">//设置外部中断P3.2口下降沿触发，开始要高电位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	P2=s[num];</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		num=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	initex();  		<span class="comment">//外部中断初始化</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>硬件类</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>串行口通信</title>
    <url>/archives/bd38da92.html</url>
    <content><![CDATA[<h1 id="串行口通信"><a href="#串行口通信" class="headerlink" title="串行口通信"></a>串行口通信</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk42.png" alt="pk42"></p>
<p>波特率发生器由定时器1产生。</p>
<p>发送接收用的是一个寄存器</p>
<p>RXD 接外设的 TXD、TXD 接外设的RXD</p>
<p>TI 发送标志位  TI&#x3D;1 发送完成   TI&#x3D;0 允许发送(需要手动清0)</p>
<p>RI 接收标志位  RI&#x3D;1 接收完成   RI&#x3D;0 允许接收(需要手动清0)</p>
<h2 id="串行口控制寄存器SCON"><a href="#串行口控制寄存器SCON" class="headerlink" title="串行口控制寄存器SCON"></a>串行口控制寄存器SCON</h2><table>
<thead>
<tr>
<th>SCON</th>
<th>D7</th>
<th>D6</th>
<th>D5</th>
<th>D4</th>
<th>D3</th>
<th>D2</th>
<th>D1</th>
<th>D0</th>
</tr>
</thead>
<tbody><tr>
<td>98H</td>
<td>SM0</td>
<td>SM1</td>
<td>SM2</td>
<td>REN</td>
<td>TB8</td>
<td>RB8</td>
<td>TI</td>
<td>RI</td>
</tr>
</tbody></table>
<p> SM0、SM1：串行口工作方式选择位</p>
<table>
<thead>
<tr>
<th>SM0</th>
<th>SM1</th>
<th>方式</th>
<th>功能</th>
<th>波特率</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>移位寄存器方式</td>
<td>f&#x2F;12</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>8位异步通信方式</td>
<td>可变</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>2</td>
<td>8位异步通信方式</td>
<td>f&#x2F;32或f&#x2F;64</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>3</td>
<td>9位异步通信方式</td>
<td>可变</td>
</tr>
</tbody></table>
<p>SM2:多机通信控制位</p>
<p>REN :   REN&#x3D;1 允许接收 ；  REN&#x3D;0  禁止接收</p>
<p>TB8  :  发送数据第9位</p>
<p>RB8  :  接收数据第9位</p>
<p>TI      :  发送中断标志位</p>
<p>RI      :  接收中断标志位</p>
<h2 id="电源控制寄存器PCON"><a href="#电源控制寄存器PCON" class="headerlink" title="电源控制寄存器PCON"></a>电源控制寄存器PCON</h2><table>
<thead>
<tr>
<th>PCON</th>
<th>D7</th>
<th>D6</th>
<th>D5</th>
<th>D4</th>
<th>D3</th>
<th>D2</th>
<th>D1</th>
<th>D0</th>
</tr>
</thead>
<tbody><tr>
<td>87H</td>
<td>SMOD</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>当SMOD 为1时，波特率加倍</p>
<h2 id="八位异步通信方式"><a href="#八位异步通信方式" class="headerlink" title="八位异步通信方式"></a>八位异步通信方式</h2><p>RXD 接外设的 TXD、TXD 接外设的RXD</p>
<p>TXD：发送数据端     RXD：接收数据段</p>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>1位起始位（0）,SUBD 的8位数据位（低位在前高位在后）和一位停止位（1）</p>
<h3 id="波特率计算"><a href="#波特率计算" class="headerlink" title="波特率计算"></a>波特率计算</h3><p>波特率(只能由T1产生，所以要回到定时计数器，且为8位可重载的方式产生)</p>
<p>波特率：2<sup>SMOD</sup> *（T1的溢出率）&#x2F; 32 </p>
<p>T1的溢出率 &#x3D; f &#x2F; （12*（256-初值））  256为八位的，所以是2^8&#x3D;256.</p>
<p>T1的初值&#x3D;256 - [f * 2<sup>SMOD</sup> &#x2F; ( 12 * 波特率 *32 )]</p>
<h4 id="12MHz-x3D-12000000"><a href="#12MHz-x3D-12000000" class="headerlink" title="12MHz &#x3D; 12000000"></a>12MHz &#x3D; 12000000</h4><p>有小数，误差很多 &#x3D; 256 - [ 12000000 * 2<sup>0</sup> &#x2F; 12 &#x2F; ( 12 * 9600 * 32 )] </p>
<h4 id="11-0592MHz-x3D-11059200"><a href="#11-0592MHz-x3D-11059200" class="headerlink" title="11.0592MHz &#x3D; 11059200"></a>11.0592MHz &#x3D; 11059200</h4><p> 是整数，所以保证通信不会出错  256 - [ 11059200 * 2<sup>0</sup> &#x2F; 12 &#x2F; ( 12 * 9600 * 32 )] &#x3D; 3 </p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>（1）发送</p>
<p>条件：TI &#x3D; 0 </p>
<p>结果： 发送完毕，TI 置 1   TI 不会自动清0，需要手动清0</p>
<p>（2） 接收</p>
<p>条件：RI &#x3D; 0  , REN(SCON.4) 置 1</p>
<p>结果： 8位的数据存入缓存器SBUF中，同时，RI 置 1 ，向CPU申请中断</p>
<h3 id="串行口初始化编程"><a href="#串行口初始化编程" class="headerlink" title="串行口初始化编程"></a>串行口初始化编程</h3><p>1.串行口控制寄存器SCON位的确定。</p>
<ul>
<li>根据工作方式确定SM0,SM1 位。</li>
<li>方式2，3确定SM2位</li>
<li>如果接收端，则允许接收 使得 REN&#x3D;1</li>
<li>方式2，3发送数据，则发送数据的第9位写入TB8中</li>
</ul>
<p>2.设置波特率</p>
<p>波特率(只能由T1产生，所以要回到定时计数器，且为8位可重载的方式产生)</p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recdat=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initscon</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	SCON=<span class="number">0x50</span>; <span class="comment">//串口通信:0101 0000    串行口控制寄存器SCON位的确定</span></span><br><span class="line">	TMOD=<span class="number">0x20</span>; <span class="comment">//串口通信:0010 0000    设置波特率，只能由T1产生，回到定时计数器，8位可重载的方式产生</span></span><br><span class="line">	TH1=<span class="number">256</span><span class="number">-3</span>;</span><br><span class="line">	TL1=<span class="number">256</span><span class="number">-3</span>;</span><br><span class="line">	ES=<span class="number">1</span>;	<span class="comment">//中断：串行口中断的允许位</span></span><br><span class="line">	EA=<span class="number">1</span>;	<span class="comment">//中断：开启总中断</span></span><br><span class="line">	TR1=<span class="number">1</span>;  <span class="comment">//定时器：设置定时计数器1启动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">senddat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	SBUF=recdat;	<span class="comment">//发送接收的数据</span></span><br><span class="line">	<span class="keyword">while</span>(!TI);		<span class="comment">//判断是否发送完成，完成TI置1</span></span><br><span class="line">	TI=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	initscon();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			senddat();</span><br><span class="line">			flag=<span class="number">0</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">scon_isr</span><span class="params">()</span> interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">	recdat=SBUF;<span class="comment">//读取数据</span></span><br><span class="line">	RI=<span class="number">0</span>;		<span class="comment">//清0标志位，继续接收</span></span><br><span class="line">	flag=<span class="number">1</span>;     <span class="comment">//表示接收完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>硬件类</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>独立按键</title>
    <url>/archives/2537ab1f.html</url>
    <content><![CDATA[<h1 id="仿真电路四-独立按键"><a href="#仿真电路四-独立按键" class="headerlink" title="仿真电路四-独立按键"></a>仿真电路四-独立按键</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line">sbit key=P0^<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> num[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>&#125;;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">500</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">keyfun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(key==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		delay(<span class="number">50</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==<span class="number">0</span>)</span><br><span class="line">			n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">10</span>)</span><br><span class="line">		n=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	P2=num[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		keyfun();</span><br><span class="line">		smg();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line">sbit key=P0^<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> num[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>&#125;;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>,sign=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">500</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">keyfun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(key==<span class="number">0</span>&amp;&amp;sign==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		delay(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==<span class="number">0</span>&amp;&amp;sign==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sign=<span class="number">1</span>;</span><br><span class="line">			n++;</span><br><span class="line">		&#125;			</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;sign==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		delay(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;sign==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sign=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">10</span>)</span><br><span class="line">		n=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	P2=num[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		keyfun();</span><br><span class="line">		smg();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>硬件类</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>仿真电路三-数码管</title>
    <url>/archives/bacfcaba.html</url>
    <content><![CDATA[<h1 id="仿真电路三-数码管"><a href="#仿真电路三-数码管" class="headerlink" title="仿真电路三-数码管"></a>仿真电路三-数码管</h1><h2 id="用到的材料"><a href="#用到的材料" class="headerlink" title="用到的材料"></a>用到的材料</h2><p>AT89c51、7seg数码管、led灯</p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>上一节我们讲过控制LED灯的程序。这一节讲个类似的-&gt;数码管。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk27.png" alt="pk27"></p>
<p>将电路变换，8个LED灯便组成了一个数码管.(这里虽然数码管的排列有些乱，但总的意思是数码管链接不变，仅仅改变了摆放位置，使得能够做成简单的数码管LED。)<img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk30.png" alt="pk30"></p>
<p>下面便是官方将摆放好的LED做成专门的器件。这里有一个引脚没有使用，是因为在实际的数码管中，还会携带一个小数点在数字的右下角。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk32.png" alt="pk32"></p>
<p>这便是数码管一步步改进组成新的器件的过程。</p>
<h2 id="数码管一：静态数码管"><a href="#数码管一：静态数码管" class="headerlink" title="数码管一：静态数码管"></a>数码管一：静态数码管</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk33.png" alt="pk33"></p>
<p>这里的上拉电位和下拉电位一定要分清楚，不同的器件改变了电位会使得程序也有所改变。</p>
<p>这里我们通过程序控制他运行。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk34.png" alt="pk34"></p>
<h3 id="实战-程序"><a href="#实战-程序" class="headerlink" title="实战+程序"></a>实战+程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数码管的静态显示</span></span><br><span class="line"><span class="comment">//共阳极和共阴级</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> num[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>&#125;;</span><br><span class="line"><span class="comment">//共阴极</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">500</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	P0=<span class="number">0x3F</span>;     <span class="comment">//0011 1111  显示0</span></span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		P0=~num[i];	 <span class="comment">//共阳</span></span><br><span class="line">		P2=num[i];   <span class="comment">//共阴</span></span><br><span class="line">		delay(<span class="number">50</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		smg();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实很像我们曾经写过的LED程序。只是这里使用了一个数组，让整个程序显示从1-9的数字。（共阳极和共阴极取反，就可以保证相同了。）</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk35.png" alt="pk35"></p>
<p>列出显示字符的代码。<img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk31.png" alt="pk31"></p>
<h2 id="数码管二：动态数码管"><a href="#数码管二：动态数码管" class="headerlink" title="数码管二：动态数码管"></a>数码管二：动态数码管</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>动态数码管虽然说是动态的，但实际却是静态的组合。依靠视觉暂留的效应，使得数码管能够持续显示动画。</p>
<p>这里举个例子，在许多的LED广告牌中，你感觉他的广告牌是动画移动的，但是单独拿出来看，却是相近的几个LED灯顺序闪烁罢了，这里也要使用这个东西。<img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk36.png" alt="pk36"></p>
<h3 id="段码与位码"><a href="#段码与位码" class="headerlink" title="段码与位码"></a>段码与位码</h3><p>这里分为段码与位码。</p>
<p>段码即每个数字的一段，并且要强调的是，这里每个数字的段码都是链接在一起的，就是表明，当位码全部接通时，段码只要显示一段，每一个数字的相同一段都会亮，这便是段码。</p>
<p>位码即选择要亮的一个数字，即当我选择第一个数字接通，其他的数字不管段码怎么样都不会亮，只有第一个数字才会亮。位码选择了要亮的数字，这便是位码。</p>
<h3 id="实战-代码"><a href="#实战-代码" class="headerlink" title="实战+代码"></a>实战+代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//数码管的动态显示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;reg51.h&quot;</span><br><span class="line">char duan[]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F&#125;; //段码  显示什么</span><br><span class="line">char wei[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;  //位码  哪一位显示</span><br><span class="line"></span><br><span class="line">void delay(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	for(i=0;i&lt;n;i++)</span><br><span class="line">		for(j=0;j&lt;120;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void smg()</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0;i&lt;8;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		P3=wei[i];</span><br><span class="line">		P2=~duan[i];</span><br><span class="line">		delay(500);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		smg();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数码管在这八位上循环显示。位码控制第几个数码管亮，段码控制显示什么数字。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk37.png" alt="pk37"></p>
]]></content>
      <categories>
        <category>硬件类</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>定时/计数器</title>
    <url>/archives/3c1196df.html</url>
    <content><![CDATA[<h1 id="定时-x2F-计数器"><a href="#定时-x2F-计数器" class="headerlink" title="定时&#x2F;计数器"></a>定时&#x2F;计数器</h1><h2 id="一、定时-x2F-计数器-的方式寄存器-TMOD"><a href="#一、定时-x2F-计数器-的方式寄存器-TMOD" class="headerlink" title="一、定时&#x2F;计数器 的方式寄存器 TMOD"></a>一、定时&#x2F;计数器 的方式寄存器 TMOD</h2><table>
<thead>
<tr>
<th align="center">TMOD</th>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(89H)</td>
<td align="center">GATE</td>
<td align="center">C&#x2F;T</td>
<td align="center">M1</td>
<td align="center">M0</td>
<td align="center">GATE</td>
<td align="center">C&#x2F;T</td>
<td align="center">M1</td>
<td align="center">M0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">定时器1</td>
<td align="center">定时器1</td>
<td align="center">定时器1</td>
<td align="center">定时器1</td>
<td align="center">定时器0</td>
<td align="center">定时器0</td>
<td align="center">定时器0</td>
<td align="center">定时器0</td>
</tr>
</tbody></table>
<h3 id="M1-M0-定时计数器的方式"><a href="#M1-M0-定时计数器的方式" class="headerlink" title="M1  M0 定时计数器的方式"></a>M1  M0 定时计数器的方式</h3><p>T0的4个工作方式、T1的3个工作方式:</p>
<table>
<thead>
<tr>
<th align="center">M1</th>
<th align="center">M0</th>
<th align="center">工作方式</th>
<th align="center">方式说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">13位定时计数器</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">16位定时计数器</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">8位自动重置定时计数器</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">两个8位自动重置定时计数器  (仅T0有)</td>
</tr>
</tbody></table>
<h3 id="C-x2F-T-定时-或-计数器"><a href="#C-x2F-T-定时-或-计数器" class="headerlink" title="C&#x2F;T  定时  或  计数器"></a>C&#x2F;T  定时  或  计数器</h3><p>C&#x2F;T  &#x3D;  1   计数方式</p>
<p>C&#x2F;T  &#x3D;  0   定时方式</p>
<h3 id="GATE"><a href="#GATE" class="headerlink" title="GATE"></a>GATE</h3><p>  门控位，用于定时或计数是否受外部中断请求信号的影响。</p>
<h2 id="二、定时-x2F-计数器-的方式寄存器-TCON"><a href="#二、定时-x2F-计数器-的方式寄存器-TCON" class="headerlink" title="二、定时&#x2F;计数器 的方式寄存器 TCON"></a>二、定时&#x2F;计数器 的方式寄存器 TCON</h2><table>
<thead>
<tr>
<th align="center">TCON</th>
<th>D7</th>
<th>D6</th>
<th>D5</th>
<th>D4</th>
<th>D3</th>
<th>D2</th>
<th>D1</th>
<th>D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">88H</td>
<td>TF1</td>
<td>TR1</td>
<td>TF0</td>
<td>TR0</td>
<td>IE1</td>
<td>IT1</td>
<td>IE0</td>
<td>IT0</td>
</tr>
</tbody></table>
<p>  TF   定时&#x2F;计数器溢出位,超出上限值就会置1,若进入中断自动清0  定时&#x2F;计数器范围（0—-2<sup>几位定时</sup>-1）</p>
<p>  TR   设置定时计数器是否启动</p>
<p>  IE    外部中断请求标志位</p>
<p>  IT    外部中断的触发方式位   &#x3D;&#x3D;0 电平触发      &#x3D;&#x3D;1边缘触发</p>
<p>初值保存在TH&#x2F;L  高八位：TH0&#x2F;1  和 低八位：TL0&#x2F;1</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="定时器工作方式计算"><a href="#定时器工作方式计算" class="headerlink" title="定时器工作方式计算"></a>定时器工作方式计算</h3><p>（单片机的定时器是微秒 um）1000000um&#x3D;1000ms&#x3D;1s</p>
<p>f： 晶振频率  51单片机有  12MHz  或者   11.0592MHz（用于通信）</p>
<h4 id="方式0：-13位定时器"><a href="#方式0：-13位定时器" class="headerlink" title="方式0：  13位定时器"></a>方式0：  13位定时器</h4><p>计数值  N：要获得的时间（微秒um） </p>
<p>初值  X &#x3D; 8192 - N &#x2F; ( 12 &#x2F; f )          2<sup>13</sup>&#x3D; 8192</p>
<p>数值保存在：<strong>高八位：TH0&#x2F;1  和 低八位：TL0&#x2F;1</strong></p>
<p>计数完后，计数器值为0，重新计数要重置初值</p>
<h4 id="方式1：-16位定时器"><a href="#方式1：-16位定时器" class="headerlink" title="方式1：  16位定时器"></a>方式1：  16位定时器</h4><p>计数值  N：计数的时间（微秒um） </p>
<p>初值  X &#x3D; 65536- N &#x2F; ( 12 &#x2F; f )          2<sup>16</sup>&#x3D; 65536</p>
<p>数值保存在： 高八位：TH0&#x2F;1  和 低八位：TL0&#x2F;1</p>
<p>计数完后，计数器值为0，重新计数要重置初值</p>
<h4 id="方式2：8位自动重置定时器"><a href="#方式2：8位自动重置定时器" class="headerlink" title="方式2：8位自动重置定时器"></a>方式2：8位自动重置定时器</h4><p>自动装填，保持上次的初值，不需要重复赋初值。</p>
<p>初值  X &#x3D; 256- N &#x2F; ( 12 &#x2F; f )          2<sup>8</sup>&#x3D; 256</p>
<h4 id="方式3：只有T0才有"><a href="#方式3：只有T0才有" class="headerlink" title="方式3：只有T0才有"></a>方式3：只有T0才有</h4><p>自动装填，保持上次的初值，不需要重复赋初值。</p>
<p>初值  X &#x3D; 256- N &#x2F; ( 12 &#x2F; f )          2<sup>8</sup>&#x3D; 256</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> s[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>&#125;;</span><br><span class="line"><span class="type">char</span> count=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用定时器0 所以高四位设置为0，低四位配置。使用16位，定时器 所以第四位为：0001</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inittimer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	TMOD=<span class="number">0x01</span>;					<span class="comment">// TMOD: 0000 0001</span></span><br><span class="line">	TH0=(<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>;		<span class="comment">// 这里是高八位</span></span><br><span class="line">	TL0=(<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;		<span class="comment">// 取余是低八位</span></span><br><span class="line">	ET0=<span class="number">1</span>;						<span class="comment">// 开启定时器0的中断</span></span><br><span class="line">	EA=<span class="number">1</span>;						<span class="comment">// 开启总中断</span></span><br><span class="line">	TR0=<span class="number">1</span>;						<span class="comment">// 启动定时器0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	P2=s[num];</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		num=<span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	inittimer();		<span class="comment">// 初始化寄存器</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)			</span><br><span class="line">	&#123;</span><br><span class="line">		display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入中断</span></span><br><span class="line"><span class="comment">// 0表示外部中断0；1表示定时器中断0 ；2表示外部中断1； 3表示定时器中断1； 4表示串口中断；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_isr</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">	TH0=(<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>;  	<span class="comment">// 这里要重新赋初值</span></span><br><span class="line">	TL0=(<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;</span><br><span class="line">	count++;</span><br><span class="line">	<span class="keyword">if</span>(count==<span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line">		count=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="定时器工作方式计算-1"><a href="#定时器工作方式计算-1" class="headerlink" title="定时器工作方式计算"></a>定时器工作方式计算</h3><h4 id="方式0：-13位计数器"><a href="#方式0：-13位计数器" class="headerlink" title="方式0：  13位计数器"></a>方式0：  13位计数器</h4><p>计数值  N：要获得的时间（微秒um） </p>
<p>初值  X &#x3D; 8192 - N           2<sup>13</sup>&#x3D; 8192</p>
<p>计数完后，计数器值为0，重新计数要重置初值</p>
<h4 id="方式1：-16位计数器"><a href="#方式1：-16位计数器" class="headerlink" title="方式1：  16位计数器"></a>方式1：  16位计数器</h4><p>计数值  N：计数的时间（微秒um） </p>
<p>初值  X &#x3D; 65536- N           2<sup>16</sup>&#x3D; 65536</p>
<p>计数完后，计数器值为0，重新计数要重置初值</p>
<h4 id="方式2：8位自动重置计数器"><a href="#方式2：8位自动重置计数器" class="headerlink" title="方式2：8位自动重置计数器"></a>方式2：8位自动重置计数器</h4><p>自动装填，保持上次的初值，不需要重复赋初值。</p>
<p>初值  X &#x3D; 256- N           2<sup>8</sup>&#x3D; 256</p>
<h4 id="方式3：只有T0才有-1"><a href="#方式3：只有T0才有-1" class="headerlink" title="方式3：只有T0才有"></a>方式3：只有T0才有</h4><p>自动装填，保持上次的初值，不需要重复赋初值。</p>
<p>初值  X &#x3D; 256- N          2<sup>8</sup>&#x3D; 256</p>
<h3 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&quot;reg51.h&quot;</span><br><span class="line"></span><br><span class="line">char s[]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F&#125;; //段码</span><br><span class="line">int num=0;</span><br><span class="line"></span><br><span class="line">void initcounter()  //初始化计数器</span><br><span class="line">&#123;</span><br><span class="line">	TMOD=0x06; // 0000 0110</span><br><span class="line">	TH0=256-3;  </span><br><span class="line">	TL0=256-3;</span><br><span class="line">	ET0=1;</span><br><span class="line">	EA=1;</span><br><span class="line">	TR0=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">	P2=s[num];</span><br><span class="line">	if(num==10)</span><br><span class="line">		num=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	initcounter(); </span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		display();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void counter_isr() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">	num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>硬件类</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 HEXO</title>
    <url>/archives/55b8db93.html</url>
    <content><![CDATA[<h2 id="安装-HEXO"><a href="#安装-HEXO" class="headerlink" title="安装 HEXO"></a>安装 HEXO</h2><p>首先先创建一个文件夹，我创建文件夹 blog1</p>
<p>然后进入博客文件夹 </p>
<h3 id="创建github账户"><a href="#创建github账户" class="headerlink" title="创建github账户"></a>创建github账户</h3><p><a href="https://github.com/join?source=header-home">https://github.com/join?source=header-home</a></p>
<h3 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h3><p>下载网页    <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
<p>安装win对应版本</p>
<h4 id="设置npm淘宝镜像站"><a href="#设置npm淘宝镜像站" class="headerlink" title="设置npm淘宝镜像站"></a>设置npm淘宝镜像站</h4><blockquote>
<p>npm config set registry “<a href="https://registry.npm.taobao.org&quot;/">https://registry.npm.taobao.org&quot;</a></p>
</blockquote>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p><a href="https://git-scm.com/">Git (git-scm.com)</a></p>
<h4 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h4><p>打开blog1文件夹，右键打开git bash终端。</p>
<p>设置user.name和user.email。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的GitHub用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="将公匙添加到github上"><a href="#将公匙添加到github上" class="headerlink" title="将公匙添加到github上"></a>将公匙添加到github上</h4><p>用户头像→Settings→SSH and GPG keys→New SSH key→将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮。</p>
<h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装hexo</span></span><br><span class="line">npm install hexo-cli g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化博客文件夹</span></span><br><span class="line">hexo init blog1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到该路径</span></span><br><span class="line"><span class="built_in">cd</span> blog1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装hexo的扩展插件</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装其它插件</span></span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-admin --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态页面</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启本地服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>



<h2 id="安装-Butterfly-主题"><a href="#安装-Butterfly-主题" class="headerlink" title="安装 Butterfly 主题"></a>安装 Butterfly 主题</h2><p>首先进入 blog1 目录下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>



<h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>修改 Hexo 根目录下的 ，把主题改为_config.ymlbutterfly</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>



<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>



<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>在 hexo 的根目录创建一个文件，并把主题目录的内容复制到 去。 （ 注意： 复制的是<code>主题的 _config.yml</code> ，而不是 <code>hexo 的 _config.yml _config.butterfly.yml _config.yml_config.butterfly.yml</code>)</p>
<blockquote>
<p>注意： 以后只需要在 进行配置就行。<br>如果使用了 ， 配置主题的 将不会有效果。_config.butterfly.yml _config.butterfly.yml _config.yml</p>
</blockquote>
<p>Hexo会自动合并主题中的和里的配置，如果存在同名配置，会使用的配置，其优先度较高。</p>
<p>_config.yml &gt;_config.butterfly.yml &gt;_config.butterfly.yml</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hexo clean   	<span class="comment">#清除编译</span></span><br><span class="line">$ hexo g		<span class="comment">#编译</span></span><br><span class="line">$ hexo s		<span class="comment">#展示</span></span><br><span class="line">$ hexo d 		<span class="comment">#上传git</span></span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>软件类</category>
      </categories>
      <tags>
        <tag>Blog搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模</title>
    <url>/archives/a66872a2.html</url>
    <content><![CDATA[<h1 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h1><h1 id="数学建模学习"><a href="#数学建模学习" class="headerlink" title="数学建模学习"></a>数学建模学习</h1><h3 id="建模方法："><a href="#建模方法：" class="headerlink" title="建模方法："></a>建模方法：</h3><p>模型假设-建模与求-模型评价-模型改进-模型检验</p>
<h3 id="微分方程建模方法"><a href="#微分方程建模方法" class="headerlink" title="微分方程建模方法"></a>微分方程建模方法</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p>1.要根据问题确定要研究的量，设好所有用到的变量（自变量、未知变量、必要参数），确定坐标系等方法。</p>
<p>2.找到量所满足的基本规律。</p>
<p>3.运用规律列出方程和确定解  使用到导数</p>
<h4 id="1-按规律直接列方程"><a href="#1-按规律直接列方程" class="headerlink" title="1.    按规律直接列方程"></a><strong>1.</strong>    <strong>按规律直接列方程</strong></h4><p>例题1：</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo.png" alt="shumo"></p>
<p>牛顿冷却定律：温度高于周围环境的物体向周围媒质传递热量逐渐冷却时所遵循的规律。当物体表面与周围存在温度差时，单位时间从单位面积散失的热量与温度差成正比，比例系数称为热传递系数。牛顿冷却定律是牛顿在1701年用实验确定的，在强制对流时与实际符合较好，在自然对流时只在温度差不太大时才成立。 是传热学的基本定律之一，用于计算对流热量的多少。<br>$$<br>设物体在t时刻温度为u&#x3D;u(t),牛顿冷却定律得:\frac{du}{dt}&#x3D;-\frac{u(t)-u(t_\infty )}{\tau }&#x3D;-k(u-\widetilde{u})   \ \ 其中\widetilde{u}为常温的温度 \ \ k&gt;0  \ 令\widetilde{u}&#x3D;24 \ \ 且(u-\widetilde{u})&gt;0<br>$$<br>则：<br>$$<br>\frac{du}{u-24}&#x3D;-k \ dt \ &#x3D;&#x3D;&gt; \frac{d(u-24)}{u-24}&#x3D;-k \ dt 这里用了积分的性质，积分号里面不变\<br>求微分：<br>\int_{150}^{u}\frac{d(u-24)}{u-24}&#x3D;\int_{0}^{t}-k \ dt \ \ \ \<br>得：ln(u-24)|<em>{150}^{u} &#x3D; -kt|</em>{t}^{0} \ \ \<br>u&#x3D;24+126e^{-kt}\ \ 带入t&#x3D;0，u_0&#x3D;150 \ \ 与 \ \ t&#x3D;10,u&#x3D;100 \<br>得k&#x3D;0.0506  \ \ \ \ 所以u&#x3D;24+126e^{-0.0506t}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line">sp.var(<span class="string">&#x27;t,k&#x27;</span>)					<span class="comment">#设置变量t和k</span></span><br><span class="line">u=sp.var(<span class="string">&#x27;u&#x27;</span>,cls=sp.Function)   <span class="comment">#设置cls参数为Function表示它是数学函数的符号。</span></span><br><span class="line">eq=sp.diff(u(t),t)+k*(u(t)-<span class="number">24</span>)  <span class="comment">#建立等式 u(t)对t求积分=-k(u-24)</span></span><br><span class="line">uu=sp.dsolve(eq,ics=&#123;u(<span class="number">0</span>):<span class="number">150</span>&#125;)	<span class="comment">#求符号方程的解  这里相当于微分后u(0):150--&gt;u:150-u  t:0-t.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;微分方程的符号解为：&#x27;</span>,uu)	<span class="comment">#输出方程</span></span><br><span class="line"></span><br><span class="line">kk=sp.solve(uu,k) 				<span class="comment">#这里是求解k的所有符合的值</span></span><br><span class="line"><span class="built_in">print</span>(kk,<span class="string">&#x27;= 0&#x27;</span>)</span><br><span class="line">k0=kk[<span class="number">0</span>].subs(&#123;t:<span class="number">10.0</span>,u(t):<span class="number">100</span>&#125;)<span class="comment">#得到</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k0 =&#x27;</span>,k0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k的值为：&#x27;</span>,k0.evalf())    <span class="comment">#k0.evalf()表示转化为浮点数</span></span><br><span class="line">u1=uu.args[<span class="number">1</span>]                   <span class="comment">#提出符号表达式24 + 126*exp(-k*t)</span></span><br><span class="line"><span class="comment">#print(u1)</span></span><br><span class="line">u0=u1.subs(&#123;t:<span class="number">20</span>,k:k0&#125;)         <span class="comment">#代入具体值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;20分钟后的温度为：&#x27;</span>,u0)</span><br></pre></td></tr></table></figure>



<h4 id="2-微元分析法"><a href="#2-微元分析法" class="headerlink" title="2.    微元分析法"></a><strong>2.</strong>    <strong>微元分析法</strong></h4><p>例题2：</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shuxue0.png" alt="shuxue0"></p>
<img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo1.png" alt="shumo1" style="zoom: 50%;" />

<p>设流量为Q  通过孔的水的体积V  时间t   g为重力加速度（9.8m&#x2F;s<sup>2</sup>）  0.62为流量系数  h为高cm  S为孔的面积cm<sup>2</sup></p>
<p>流量系数：是指单位时间内、在测试条件中管道保持恒定的压力，管道介质流经阀门的体积流量，或是质量流量。 即阀门的流通能力。 流量系数值越大说明流体流过阀门时的压力损失越小。</p>
<p>得到公式为：<br>$$<br>Q&#x3D;\frac{dV}{dt}&#x3D;0.62S\sqrt{2gh}<br>$$<br>同一单位后：<br>$$<br>dV&#x3D;0.000062S\sqrt{2gh}\ dt<br>$$<br>在微小的一段时间里面：[t , t+dt ] 内，高度变化 [ h , h+dh ] ( dh&lt;0 ) , 容器中水的体积的改变：<br>$$<br>dV &#x3D; - \pi r^2 \ dh \<br>r为液面的半径\ \ \ \ R为球的半径\ \ \ \ h 为液面的高度 \<br>r^2 &#x3D; [R^2-(R-h)^2]&#x3D;2h-h^2<br>$$</p>
<p>所以带入r<sup>2</sup>&#x3D;2h-h<sup>2</sup><br>$$<br>0.000062 \sqrt{2gh}\ dt &#x3D; -\pi (2h-h^2)\ dh<br>$$<br>回到题目求 高度h 与 时间t 的变化：<br>$$<br>\begin{equation}<br>\left{<br>             \begin{array}{lr}<br>              \frac{dt}{dh}&#x3D;\frac{-\pi (2h-h^2)}{0.000062 \sqrt{2gh}} \<br>              h(0)&#x3D;1<br>             \end{array}<br>\right.<br>\end{equation} \<br>$$</p>
<p>$$<br>{\color{Red}eq} &#x3D; \frac{dt}{dh}-\frac{-\pi (2h-h^2)}{0.000062 \sqrt{2gh}}&#x3D;\color{Red}\frac{dt}{dh}-\frac{1000000\pi (h^{\frac{3}{2}}-2h^{\frac{1}{2}})}{62 \sqrt{2g}}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line">sp.var(<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">sp.var(<span class="string">&#x27;t&#x27;</span>,cls=sp.Function)</span><br><span class="line">g  = <span class="number">9.8</span></span><br><span class="line">eq=t(h).diff(h)-<span class="number">10000</span>*sp.pi/<span class="number">0.62</span>/sp.sqrt(<span class="number">2</span>*g)*(h**(<span class="number">3</span>/<span class="number">2</span>)-<span class="number">2</span>*h**(<span class="number">1</span>/<span class="number">2</span>)) <span class="comment">#求解等式</span></span><br><span class="line">t=sp.dslove(eq,ics=&#123;t(<span class="number">1</span>):<span class="number">0</span>&#125;)						  <span class="comment">#带入初始值求符号解</span></span><br><span class="line">t=sp.simplify(t)													</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;符号解为：&#x27;</span>,t)									<span class="comment">#输出符号解</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;方程的解为：&#x27;</span>,t.args[<span class="number">1</span>].evalf())				   <span class="comment">#将方程的解的系数用实数值表示 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以方程的解为：<br>$$<br>\color{Red}t(h)&#x3D;-15260.5042h^{\frac{3}{2}}+4578.1513h^{\frac{5}{2}}+10682.3530<br>$$</p>
<h4 id="3-模拟近似法"><a href="#3-模拟近似法" class="headerlink" title="3.    模拟近似法"></a><strong>3.</strong>    模拟近似法</h4><p><strong>例3</strong> （交通管理问题）在交通十字路口，都会设置红绿灯。为了让那些正行驶在交叉路口太近而无法停下的车辆通过路口，红绿灯转换中间还要亮起一段时间的黄灯。那么，黄灯应亮多长时间才最为合理？</p>
<p>首先考虑问的是黄灯亮多长时间，则要考虑：司机反应时间+刹车距离的时间+车通过交叉入口的时间。</p>
<p>首先设：v<sub>0</sub>是法定速度      I是交通路口长度     L是车长   </p>
<p>则：车通过路口的正常时间为：(I+L)&#x2F;v<sub>0</sub></p>
<p>求 开始刹车到速度为0 的距离。</p>
<p>设： W 为汽车的重量   μ为摩擦系数     所以摩擦力为f&#x3D;μW   方向与运动方向相反<br>$$<br>f&#x3D;μW  \ \ \ \ \ W&#x3D;mg \ \ \ \ \ f&#x3D;-ma&#x3D;-m\frac{dv}{dt}&#x3D;-\frac{W}{g}\frac{d^2 x}{dt^2} \<br>μmg&#x3D;-\frac{W}{g}\frac{d^2 x}{dt^2}\<br>{\color{Red}-μg&#x3D;\frac{d^2 x}{dt^2}}\<br>$$<br>所以得到：<br>$$<br>\begin{equation}<br>\left{<br>             \begin{array}{lr}<br>              -μg&#x3D;\frac{d^2 x}{dt^2} \<br>              x|<em>{t&#x3D;0}&#x3D;0, \ \frac{dx}{dt}|</em>{t&#x3D;0}&#x3D;v_0<br>             \end{array}<br>\right.<br>\end{equation} \<br>$$</p>
<p>化简并积分<br>$$<br>d^2 x&#x3D;-μgdt^2 \ \</p>
<p> \int_{0}^{x} d^2 x &#x3D; \int_{0}^{t}-μgdt^2<br>$$<br>得：<br>$$<br>\frac{dx}{dt}&#x3D;-μgt+v_0 \ \ \<br>$$<br>二次积分：<br>$$<br>\int_{0}^{x}dx  &#x3D;  \int_{0}^{t}(-μgt+v_0)dt\<br>$$<br>得：<br>$$<br>{\color{Red}x(t)&#x3D;-\frac{1}{2}μgt^2+v_0t}<br>$$</p>
<p>当利用前面的公式：<br>$$<br>\frac{dx}{dt}&#x3D;0 \ \ \ \ \ \ 和 \ \ \ \ \ \frac{dx}{dt}&#x3D;-μgt+v_0<br>$$<br>得到：<br>$$<br>-μgt+v_0&#x3D;0<br>$$<br>所以    刹车所用时间为：<br>$$<br>t_0&#x3D;\frac{v_0}{μg}<br>$$<br>然后将时间带入x(t)的公式：<br>$$<br>x(t_0)&#x3D;-\frac{1}{2}μgt^2 |_{t_0&#x3D;\frac{v_0}{μg}}<br>$$<br>所以刹车距离为：<br>$$<br>{\color{Red}x(t_0)&#x3D;}-\frac{1}{2}μg\frac{v_0^2}{μ^2g^2}&#x3D;\color{Red}-\frac{v_0^2}{2μg}<br>$$<br>计算黄灯的时间T：黄灯的时间<br>$$<br>T&#x3D;\frac{x(t_0)+I+L}{v_0}+T_0<br>$$<br>总路程为x(t<sub>0</sub>)+I+L   +  T<sub>0</sub> 反应时间   x（t<sub>0</sub>） 得：<br>$$<br>T&#x3D;\frac{I+L}{v_0}+T_0+\frac{v_0}{2μg}<br>$$<br>取<strong>μ&#x3D;0.7   T<sub>0</sub>&#x3D;1s   L&#x3D;4.5m  I&#x3D;9m    令：v<sub>0</sub> &#x3D;45km&#x2F;h     65km&#x2F;h      80km&#x2F;h</strong></p>
<table>
<thead>
<tr>
<th>v<sub>0</sub>  &#x2F;  (km&#x2F;h)</th>
<th>45</th>
<th>65</th>
<th>80</th>
</tr>
</thead>
<tbody><tr>
<td>T   &#x2F;   s</td>
<td>4.58</td>
<td>5.95</td>
<td>7.00</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line">v0 = array([<span class="number">45</span>,<span class="number">65</span>,<span class="number">80</span>])   	<span class="comment"># v0向量</span></span><br><span class="line">T0 = <span class="number">1</span>						<span class="comment"># T0反应时间</span></span><br><span class="line">L  = <span class="number">4.5</span>					<span class="comment"># L是车长4.5m</span></span><br><span class="line">I  = <span class="number">9</span>						<span class="comment"># 交通路口长度9m</span></span><br><span class="line">mu = <span class="number">0.7</span>					<span class="comment"># 摩擦系数0.7</span></span><br><span class="line">g  = <span class="number">9.8</span>					<span class="comment"># 重力加速度</span></span><br><span class="line">T = v0/(<span class="number">2</span>*mu*g)+(I+L)/v0+T0 <span class="comment"># 黄灯时间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当速度分别是45、65、80(km/s)时黄灯的时长为&#x27;</span>,T)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Lorenz模型的混沌效应"><a href="#Lorenz模型的混沌效应" class="headerlink" title="Lorenz模型的混沌效应"></a>Lorenz模型的混沌效应</h3><p>Lorenz模型是由美国气象学家Lorenz在研究大气运动时，通过简化对流模型，只保留3个变量提出的一个完全确定性的一阶自治常微分方程组（不显含时间变量），其方程为<br>$$<br>\begin{cases}<br> &amp; \overset{.}{x}&#x3D; \sigma(y-x)\<br> &amp; \overset{.}{y}&#x3D; \rho x-y-xz\<br> &amp; \overset{.}{z}&#x3D; xy-\beta z<br>\end{cases}<br>$$<br>其中，参数&amp;sigma; 为Prandtl数，&amp;rho;为Rayleigh数，&amp;beta;为方向比.</p>
<p>第一个混沌吸引子——Lorenz吸引子也是在这个系统中被发现的. 系统中三个参数的选择对系统会不会进入混沌状态其着重要的作用.</p>
<p>蝴蝶效应：  &amp;sigma; &#x3D; 10            &amp;rho; &#x3D; 28              &amp;beta; &#x3D; 8&#x2F;3</p>
<p>给出了系统从两个靠得很近的初值出发（相差仅0.0001）后，解的偏差演化曲线. 随着时间的增大，可以看到两个解的差异越来越大，这正是动力学系统对初值敏感性的直观表现，由此可断定此系统的这种状态为混沌态. 混沌运动是确定性系统中存在随机性，它的运动轨道对初始条件极端敏感.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> odeint</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lorenz</span>(<span class="params">w,t</span>):<span class="comment">#定义求解函数</span></span><br><span class="line">    sigma=<span class="number">10</span></span><br><span class="line">    rho=<span class="number">28</span></span><br><span class="line">    beta=<span class="number">8</span>/<span class="number">3</span></span><br><span class="line">    x,y,z=w</span><br><span class="line">    <span class="keyword">return</span> np.array([sigma*(y-x),rho*x-y-x*z,x*y-beta*z])</span><br><span class="line"></span><br><span class="line">t=np.arange(<span class="number">0</span>,<span class="number">50</span>,<span class="number">0.01</span>) <span class="comment">#创建时间点</span></span><br><span class="line">sol1=odeint(lorenz,[<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>],t) <span class="comment">#第一个初值问题求解</span></span><br><span class="line">sol2=odeint(lorenz,[<span class="number">0.0</span>,<span class="number">1.0001</span>,<span class="number">0.0</span>],t) <span class="comment">#第二个初值问题求解</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sol1:\n&#x27;</span>,sol1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sol2:\n&#x27;</span>,sol2)</span><br><span class="line"></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,family=<span class="string">&#x27;SimHei&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">plt.rc(<span class="string">&#x27;axes&#x27;</span>,unicode_minus=<span class="literal">False</span>) <span class="comment">#用来正常显示负号</span></span><br><span class="line"></span><br><span class="line">ax1=plt.subplot(<span class="number">121</span>,projection=<span class="string">&#x27;3d&#x27;</span>,title=<span class="string">&#x27;图a&#x27;</span>)</span><br><span class="line">ax2=plt.subplot(<span class="number">122</span>,projection=<span class="string">&#x27;3d&#x27;</span>,title=<span class="string">&#x27;图b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax1.plot(sol1[:,<span class="number">0</span>],sol1[:,<span class="number">1</span>],sol1[:,<span class="number">2</span>],<span class="string">&#x27;r&#x27;</span>) <span class="comment">#r表示红色</span></span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;$y$&#x27;</span>)</span><br><span class="line">ax1.set_zlabel(<span class="string">&#x27;$z$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(sol1[:,<span class="number">0</span>]-sol2[:,<span class="number">0</span>],sol1[:,<span class="number">1</span>]-sol2[:,<span class="number">1</span>],sol1[:,<span class="number">2</span>]-sol2[:,<span class="number">2</span>],<span class="string">&#x27;g&#x27;</span>) <span class="comment">#g表示绿色</span></span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;$y$&#x27;</span>)</span><br><span class="line">ax2.set_zlabel(<span class="string">&#x27;$z$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个初值问题的解sol1=&#x27;</span>,sol1)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个初值问题的解sol2=&#x27;</span>,sol2)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;解的偏差sol1-sol2=&#x27;</span>,sol1-sol2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Malthus模型"><a href="#Malthus模型" class="headerlink" title="Malthus模型"></a>Malthus<strong>模型</strong></h3><p>1789年，英国神父Malthus在分析了一百多年人口统计资料之后，提出了Malthus模型.</p>
<h4 id="1-模型假设"><a href="#1-模型假设" class="headerlink" title="1.模型假设"></a>1.模型假设</h4><ul>
<li>设x（t）表示t时刻的人口数，并且x（t）连续且可微</li>
<li>设人口的增长率r是常数（增长率 &#x3D; 出生率 - 死亡率）</li>
<li>人口的变化封闭，人口数量的增加与减少只取决于人口中个体的生育和死亡，且每一个体都具有同样的生育能力与死亡率。</li>
</ul>
<h4 id="2-建模与求解"><a href="#2-建模与求解" class="headerlink" title="2.建模与求解"></a><strong>2.建模与求解</strong></h4><p>设：t-&gt;t+&amp;Delta;t    人口的增量为：x(t+&amp;Delta;t) - x(t)  &#x3D;  r x(t) &amp;Delta;t<br>$$<br>\begin{cases}<br> &amp; \frac{dx}{dt}&#x3D;rx \ \ \ \ \ \ 增长的人数&#x3D;增长率*总人口\<br> &amp; x(0)&#x3D;x_0       \ \ \  初始人口为一定值<br>\end{cases}<br>$$<br>求解：<br>$$<br>\int_{0}^{x}\frac{1}{x}dx&#x3D;\int_{0}^{t}r\ dt<br>$$<br>所以：<br>$$<br>lnx|_0^x&#x3D;rt|^t_0<br>$$<br>解的：<br>$$<br>lnx-lnx_0&#x3D;ln\frac{x}{x0}&#x3D;rt<br>$$<br>所以：<br>$$<br>\frac{x}{x_0}&#x3D;e^{rt}<br>$$<br>方程的解为：<br>$$<br>x(t)&#x3D;x_0\ e^{rt}<br>$$</p>
<h4 id="3-模型评价"><a href="#3-模型评价" class="headerlink" title="3.模型评价"></a>3.模型评价</h4><p>考虑二百多年来人口增长的实际情况，1961年世界人口总数为3.06x10<sup>9</sup>,在1961~1970年这段时间内，每年平均人口自然增长率为2%，则带入上式有：<br>$$<br>x(t)&#x3D;3.06\times 10^9\cdot e^{0.02(t-1961)}<br>$$<br>因为在这期间地球人口大约每35年增加1倍，而(3) 式算出每34.6年增加1倍.短期内，计算结果相当符合事实。但当t&#x3D;2670年时，x(t)&#x3D;4.4x10<sup>15</sup>,即4400万亿，相当于地球没平方米容纳至少20人。显然是不对的， 误差的原因是增长率r的估计过高，由此，可以队r这个常数提出假设。</p>
<h4 id="4-模型改进"><a href="#4-模型改进" class="headerlink" title="4.模型改进"></a>4.模型改进</h4><p><strong>一、</strong> <strong>当增长率不是常数时的模型</strong>**</p>
<p>因为地球资源是有限的，他只提供一定量的生命生存所需的条件。人口增加，自然资源、环境资源等会对人口再增长的限制越来月显著。当人过少时，可以r看为常数，但一定量后，r随着人口的增加而减少，即增长率r表示为x(t)的函数r(x(t))，记为r(x)，且r(x)为x的减函数。</p>
<h5 id="模型再次假设"><a href="#模型再次假设" class="headerlink" title="模型再次假设"></a>模型再次假设</h5><ul>
<li>设r（x）为x的线性函数，r（x）&#x3D;  r - sx  (工程署原则，首先用线性)</li>
<li>自然资源与环境条件所能容纳的最大人口数为x<sub>m</sub>,当x&#x3D;x<sub>m</sub>时，增长率r（x<sub>m</sub>）&#x3D; 0</li>
</ul>
<h5 id="模型建立与求解"><a href="#模型建立与求解" class="headerlink" title="模型建立与求解"></a>模型建立与求解</h5><p>由公式这个：<br>$$<br>\frac{dx}{dt}&#x3D;rx<br>$$<br>可以想到斜率会是s型。那么：<br>$$<br>令r(x)&#x3D;r(1-\frac{x}{x_m}) \ 保证了x大于x_m时会负增长 \ x&#x3D;x_m时0增长 \<br>而且增长率虽人口增加而减少<br>$$<br>假设了一个增长率函数，然后求解：<br>$$<br>\begin{cases}<br> &amp; \frac{dx}{dt}&#x3D;r(1-\frac{x}{x_m})x \<br> &amp; x(t_0)&#x3D;x_0<br>\end{cases}<br>$$<br>对第一个求积分并化简<br>$$<br>\int_{0}^{x}\frac{1}{(1-\frac{x}{x_m})x}dx&#x3D;\int_{0}^{x}\frac{x_m}{xx_m-x^2}dx&#x3D;\int_{0}^{t}r\ dt  \ \ \ \ \ \ \  \ \ \ \ \   (x_m为定值)<br>$$<br>求解：<br>$$<br>x(t)&#x3D;\frac{x_m}{1+(\frac{x_m}{x_0}-1)e^{-r(t-t_0)}}<br>$$<br>这个就是<strong>Logistic模型</strong></p>
<h5 id="模型检验"><a href="#模型检验" class="headerlink" title="模型检验"></a>模型检验</h5><p>$$<br>\frac{dx}{dt}求导得：\frac{d^2x}{dt^2}&#x3D;r^2(1-\frac{x}{x^m})(1-\frac{2x}{x_m})x<br>$$</p>
<p>人口总数x(t)有如下规律：<br>$$<br>\lim_{t\rightarrow\infty}x(t)&#x3D;x_m \ \ \ \ \ \ \ \ \ \ \ \ 即无论人口初值  如何，人口总数以  为极限.<br>$$</p>
<p>$$<br>当0&lt;x_0&lt;x_m时，\frac{dx}{dt}&#x3D;r(1-\frac{x}{x_m})x &gt; 0 \ \ \ 说明x(t)是单调增加的；<br>$$</p>
<p>$$<br>当x&lt;\frac{x_m}{2}时，\frac{d^2x}{dt^2}&gt;0,x&#x3D;x(t)为凹函数<br>$$</p>
<p>$$<br>当x&gt;\frac{x_m}{2}时，\frac{d^2x}{dt^2}&lt;0,x&#x3D;x(t)为凸函数<br>$$</p>
<p>$$<br>人口变化率\frac{dx}{dt}在x&#x3D;\frac{x_m}{2}时取最大值 \即人口总数达到极限值一半以前是加速生长，过了这一点后，会逐渐减小，最终达到0。<br>$$</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>利用下表给出的近两个世纪的美国人口统计数据（以百万为单位），建立人口预测模型，最后用它估计2010年美国的人口。</p>
<center>数据</center>

<table>
<thead>
<tr>
<th>年份</th>
<th>1790</th>
<th>1800</th>
<th>1810</th>
<th>1820</th>
<th>1830</th>
</tr>
</thead>
<tbody><tr>
<td>人口</td>
<td>3.9</td>
<td>5.3</td>
<td>7.2</td>
<td>9.6</td>
<td>12.9</td>
</tr>
<tr>
<td>年份</td>
<td>1840</td>
<td>1850</td>
<td>1860</td>
<td>1870</td>
<td>1880</td>
</tr>
<tr>
<td>人口</td>
<td>17.1</td>
<td>23.2</td>
<td>31.4</td>
<td>38.6</td>
<td>50.2</td>
</tr>
<tr>
<td>年份</td>
<td>1890</td>
<td>1900</td>
<td>1910</td>
<td>1920</td>
<td>1930</td>
</tr>
<tr>
<td>人口</td>
<td>62.9</td>
<td>76.0</td>
<td>92.0</td>
<td>106.5</td>
<td>123.2</td>
</tr>
<tr>
<td>年份</td>
<td>1940</td>
<td>1950</td>
<td>1960</td>
<td>1970</td>
<td>1980</td>
</tr>
<tr>
<td>人口</td>
<td>131.7</td>
<td>150.7</td>
<td>179.3</td>
<td>204.0</td>
<td>226.5</td>
</tr>
<tr>
<td>年份</td>
<td>1990</td>
<td>2000</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>人口</td>
<td>251.4</td>
<td>281.4</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="建立模型与求解"><a href="#建立模型与求解" class="headerlink" title="建立模型与求解"></a>建立模型与求解</h5><p>记x（t）为第t年的人口数量，设人口年增长率r(x)为x的线性函数，r(x) &#x3D; r - sx , 自然资源与环境条件所容纳的最大人口数为x<sub>m</sub>，即当x &#x3D; x<sub>m</sub>时，增长率r(x<sub>m</sub>) &#x3D; 0 ，得<br>$$<br>r(x)&#x3D;r(1-\frac{x}{x_m})<br>$$<br>建立 Logistic 人口模型：<br>$$<br>\begin{cases}<br> &amp; \frac{dx}{dt}&#x3D;r(1-\frac{x}{x_m})x \<br> &amp; x(t_0)&#x3D;x_0<br>\end{cases}<br>$$<br>解的：<br>$$<br>x(t)&#x3D;\frac{x_m}{1+(\frac{x_m}{x_0}-1)e^{-r(t-t_0)}}<br>$$</p>
<h5 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h5><h6 id="非线性最小二乘法"><a href="#非线性最小二乘法" class="headerlink" title="非线性最小二乘法"></a>非线性最小二乘法</h6><p>将第一个数据为初始条件，用余下的数据来拟合 Logistic 函数的参数x<sub>m</sub>和r 。解的r&#x3D;0.0274，x<sub>m</sub>&#x3D;342.4419</p>
<p>带入公式得：<br>$$<br>x(t)&#x3D;\frac{342.4419}{1+(\frac{342.4419}{x_0}-1)e^{-0.0274(t-t_0)}}<br>$$<br>将数据2010年的数据带入预测值为：2010—-282.6798（百万）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#非线性最小二乘法</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"></span><br><span class="line">a=[]</span><br><span class="line">b=[]</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取文件，一行一行读取，偶数行为年份，奇数行为数量</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡14.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s=f.read().splitlines()  </span><br><span class="line"><span class="built_in">print</span>(s,<span class="string">&#x27;\n&#x27;</span>)    </span><br><span class="line"><span class="comment">#print(len(s))  s=6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取年份</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s),<span class="number">2</span>):</span><br><span class="line">    d1 = s[i].split(<span class="string">&#x27;\t&#x27;</span>) 		<span class="comment">#将年份数据按&#x27;\t&#x27;分割</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(d1)):   	<span class="comment">#将分割开的年份数据用append的方法放到列表</span></span><br><span class="line">        <span class="keyword">if</span> d1[j]!=<span class="string">&#x27;&#x27;</span>:			<span class="comment">#判断是否为空</span></span><br><span class="line">            a.append(<span class="built_in">eval</span>(d1[j]))</span><br><span class="line"><span class="built_in">print</span>(a,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s),<span class="number">2</span>):		<span class="comment">#同样的道理分割数量的数据</span></span><br><span class="line">    d2=s[i].split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(d2)):</span><br><span class="line">        <span class="keyword">if</span> d2[j]!=<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            b.append(<span class="built_in">eval</span>(d2[j]))</span><br><span class="line"><span class="built_in">print</span>(b,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c=np.vstack((a,b))</span><br><span class="line">np.savetxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡14_例1_数据.txt&#x27;</span>,c) </span><br><span class="line"></span><br><span class="line">x0=<span class="number">3.9</span></span><br><span class="line">t0=<span class="number">1790</span></span><br><span class="line">x=<span class="keyword">lambda</span> t,r,xm:xm/(<span class="number">1</span>+(xm/x0-<span class="number">1</span>)*np.exp(-r*(t-t0)))</span><br><span class="line">bd=((<span class="number">0</span>,<span class="number">200</span>),(<span class="number">0.1</span>,<span class="number">1000</span>))  <span class="comment">#约束两个参数的下界和上界</span></span><br><span class="line">popt,pcov=curve_fit(x,a[<span class="number">1</span>:],b[<span class="number">1</span>:],bounds=bd)</span><br><span class="line"><span class="comment"># 参数r与xm的估计值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;返回参数r与xm的值&#x27;</span>,popt,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2010年的预测值为：&#x27;</span>,x(<span class="number">2010</span>,*popt))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="线性最小二乘法"><a href="#线性最小二乘法" class="headerlink" title="线性最小二乘法"></a>线性最小二乘法</h6><p>简单的线性最小二乘估计这个模型的参数 x<sub>m</sub> 和 r ，把Logistic方程表示为：<br>$$<br>\frac{1}{x}\frac{dx}{dt}&#x3D;r-sx \ \ \ \ ,\ \  \ s&#x3D;\frac{r}{x_m}<br>$$<br>记1790,1800，…… ，2000年分别用 k &#x3D; 1，2，3，……，21  表示，利用向前差分，得到差分方程：<br>$$<br>\frac{1}{x(k)}\cdot \frac{x(k+1)-x(k)}{\Delta t}&#x3D;r-sx(k)\ \ \ \ \ ,\ \ \ \ \ \ k&#x3D;1,2,3,…,21<br>$$<br>其中步长&amp;Delta;t&#x3D;10。拟合数据，求得r&#x3D;0.0325，x(m)&#x3D;294.3860 ，再求得2010年人口预测值为277.9634百万。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#线性最小二乘法</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">d=np.loadtxt(<span class="string">&#x27;暑假打卡14_例1_数据.txt&#x27;</span>) <span class="comment">#加载文件中的数据</span></span><br><span class="line"><span class="built_in">print</span>(d)					<span class="comment"># 观察完数据可注释掉</span></span><br><span class="line">t0=d[<span class="number">0</span>] 					<span class="comment"># 提取年代数据</span></span><br><span class="line">x0=d[<span class="number">1</span>] 					<span class="comment"># 提取对应的人口数据</span></span><br><span class="line"><span class="built_in">print</span>(t0)</span><br><span class="line"><span class="built_in">print</span>(x0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(x0[:-<span class="number">1</span>]) 				<span class="comment"># 获取数据除去最后一位</span></span><br><span class="line">b=np.diff(x0)/<span class="number">10</span>/x0[:-<span class="number">1</span>]	<span class="comment"># 构造线性方程组的常数项列</span></span><br><span class="line">a=np.vstack([np.ones(<span class="built_in">len</span>(x0)-<span class="number">1</span>),-x0[:-<span class="number">1</span>]]).T <span class="comment">#构造线性方程组系数矩阵</span></span><br><span class="line">rs=np.linalg.pinv(a)@b </span><br><span class="line"><span class="comment">#pinv表示矩阵a的伪逆pinv(X) ，此处不懂可百度最小二乘法的公式以及伪逆。</span></span><br><span class="line"><span class="comment">#这里的@指矩阵的乘法</span></span><br><span class="line">r=rs[<span class="number">0</span>]</span><br><span class="line">xm=r/rs[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;人口增长率r和人口最大值xm的拟合值分别为&#x27;</span>,np.<span class="built_in">round</span>([r,xm],<span class="number">4</span>)) <span class="comment">#round函数表示四舍五入，此处4表示保留4位小数</span></span><br><span class="line">xhat=xm/(<span class="number">1</span>+(xm/<span class="number">3.9</span>-<span class="number">1</span>)*np.exp(-r*(<span class="number">2010</span>-<span class="number">1790</span>))) <span class="comment">#求预测值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2010年的预测值为：&#x27;</span>,<span class="built_in">round</span>(xhat,<span class="number">4</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="传染病模型"><a href="#传染病模型" class="headerlink" title="传染病模型"></a>传染病模型</h3><p> 传染病动力学是用数学模型研究某种传染病在某的一地区是否蔓延下去，成为当地的“地方病”，或最终该病将被消除. 下面以Kermack和Mckendrick 提出的阈值模型为例说明传染病动力学模型的建模过程。</p>
<h4 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h4><ol>
<li><p>被研究人群是封闭的，总人数为 n 。s(t) , i(t) , r(t) 分别代表：t 时刻  易感染着、已感染着、免疫者。  起始条件：s<sub>0</sub>个易感染者 ， i<sub>0</sub> 个感染者 ，n-s<sub>0 </sub>- i<sub>0</sub> 个</p>
</li>
<li><p>易感染人数的变化率与当时的易感染人数和感染人数之积成正比 ， 系数为  &amp;lambda;。</p>
</li>
<li><p>免疫者人数的变化率与当时的感染者人数成正比，比例系数为 &amp;mu; 。</p>
</li>
<li><p>三类人总的变化率代数和为零.</p>
</li>
</ol>
<h4 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h4><p>根据上述假设，可以建立如下模型：</p>
<p>$$<br>\begin{cases}<br> &amp; \frac{ds}{dt}&#x3D;  -\lambda si\<br> &amp; \frac{dr}{dt}&#x3D;  \mu i\<br> &amp; \frac{di}{dt}+\frac{ds}{dt}+\frac{dr}{dt}&#x3D;0  \<br> &amp; \frac{di}{dt}&#x3D;  \lambda si-\mu i\<br> &amp; s(t)+i(t)+r(t)&#x3D;n<br>\end{cases}<br>$$<br>模型又称Kermack-Mckendrick方程</p>
<h4 id="模型求解与分解"><a href="#模型求解与分解" class="headerlink" title="模型求解与分解"></a>模型求解与分解</h4><p>上面的方程无法求解出任何一个  s(t) , i(t) , r(t) 的解析解。转到平面 s-i 讨论解的性质。<br>$$<br>由 得：\begin{cases}<br>\frac{di}{ds}&#x3D;\frac{1}{\sigma s}-1\<br>\sigma&#x3D;\frac{\lambda}{\mu}\<br>i|_{s&#x3D;s_0}&#x3D;i_0 \<br>\end{cases}<br>$$</p>
<p>$$<br>\mu是易感人数的变化率系数、\lambda是免疫者人数的变化率系数、\sigma则为一个传染期内每个患者有效接触的平均人数<br>$$</p>
<p>则&amp;sigma;为接触数.</p>
<p>分离变量法求解：<br>$$<br>di&#x3D;(\frac{1}{\sigma s}-1)ds<br>$$<br>然后对两边积分：<br>$$<br>\int_{i_0}^{i}di&#x3D;\int_{s_0}^{s}(\frac{1}{\sigma s}-1)ds<br>$$<br>得：<br>$$<br>i|<em>{i_0}^{i}&#x3D;(\frac{1}{\sigma}lns-s)|</em>{s_0}^{s}<br>$$<br>所以：<br>$$<br>i-i_0 &#x3D;\frac{1}{\sigma}lns-s-\frac{1}{\sigma}lns_0+s_0<br>$$<br>化简：<br>$$<br>i&#x3D;i_0+s_0-s+\frac{1}{\sigma}(lns-lns_0)<br>$$<br>解的：<br>$$<br>i&#x3D;i_0+s_0-s+\frac{1}{\sigma}(ln\frac{s}{s_0})<br>$$<br>由公式得知：</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo3.png" alt="shumo3"></p>
<ul>
<li><p>当初始值s<sub>0</sub> &amp;le; 1&#x2F; &amp;sigma; 时，患者人数会增加，传染病开始蔓延，健康者的人数在减少。</p>
</li>
<li><p>当初始值s(t) 减少至 1&#x2F; &amp;sigma; 时,患者在人群中的比例达到最大值，然后患者数逐渐减少至零</p>
</li>
<li><p>1&#x2F; &amp;sigma; 是阈值，所以要想控制传染病的流行，应控制s<sub>0</sub> 使之小于阈值.</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>提高卫生和医疗水平，卫生水平越高，使传染性接触率 &amp;lambda; 就越小；医疗水平越高，恢复系数 &amp;mu;  就越大。</li>
</ol>
<p>这样子就提高了1&#x2F; &amp;sigma; 阈值 。提高卫生和医疗水平有助于控制传染病的蔓延</p>
<ol start="2">
<li>降低s<sub>0</sub>来控制传染病的蔓延. 由 s<sub>0 </sub>+ i<sub>0 </sub>+ r<sub>0</sub> &#x3D; n  可知道，减少s<sub>0</sub>可以通过提高r<sub>0</sub> 来实现。</li>
</ol>
<h4 id="参数估计-1"><a href="#参数估计-1" class="headerlink" title="参数估计"></a>参数估计</h4><p>参数&amp;sigma; 的值可由实际的数据估计得：<br>$$<br>令s_\infty 与 i_\infty 分别是传染病流行结束后的 健康者人数 和 患者人数。<br>$$<br>当流行结束后，患者都将转化为免疫者<br>$$<br>i_\infty &#x3D; 0 \ ;\ \therefore i_\infty&#x3D;i_0+s_0-s_\infty+\frac{1}{\sigma}(ln\frac{s_\infty}{s_0}),<br>$$<br>解的：<br>$$<br>\sigma&#x3D;-\frac{lns_0-lns_\infty}{s_\infty-i_0-s_0}<br>$$<br>于是，当已知某地区某种传染病流行结束后的 $s_\infty$ 时，则可以算出 $\sigma$ ， $\sigma$ 值可再今后同种传染病和同类地区的研究中使用。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>1950年上海市某全托幼儿所发生的一起水痘流行过程中各代病例数、易感染者数及间隔时间如下，应用K-M模型进行模拟，并对模拟结果进行讨论. 该所儿童总人数n 为196人；既往患过水痘而此次未感染者40人，查不出水痘患病史而本次流行期间感染水痘者96人，既往无明确水痘史，本次又未感染的幸免者60人. 全部流行期间79人，病例成代出现，每代间隔约15人. </p>
<center>表1 某全托幼儿所水痘流行过程中各代病例数


<table>
<thead>
<tr>
<th>代</th>
<th>病例数</th>
<th>易感染者</th>
<th>间隔时间&#x2F;天</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>155</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>153</td>
<td>15</td>
</tr>
<tr>
<td>3</td>
<td>14</td>
<td>139</td>
<td>32</td>
</tr>
<tr>
<td>4</td>
<td>38</td>
<td>101</td>
<td>46</td>
</tr>
<tr>
<td>5</td>
<td>34</td>
<td>67</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>33</td>
<td></td>
</tr>
<tr>
<td>合计</td>
<td>96</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>以初始值s<sub>0</sub>，$s_\infty$代入$\sigma&#x3D;-\frac{lns_0-lns_\infty}{s_\infty-i_0-s_0}$ 可得  $ \sigma&#x3D;0.0099 $ . </p>
<p>将代入$i&#x3D;i_0+s_0-s+\frac{1}{\sigma}(ln\frac{s}{s_0})$ 可得该流行过程的模拟结果如下表2.</p>
<center>表2 用K-M模型模拟水痘流行过程的数值解 


<table>
<thead>
<tr>
<th>易感染者</th>
<th>155</th>
<th>153</th>
<th>139</th>
<th>101</th>
</tr>
</thead>
<tbody><tr>
<td>病例数i</td>
<td>1</td>
<td>1.7</td>
<td>6.0</td>
<td>11.7</td>
</tr>
</tbody></table>
<h5 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s0=<span class="number">155</span></span><br><span class="line">i0=<span class="number">1.0</span></span><br><span class="line">s_inf=<span class="number">60.0</span></span><br><span class="line"></span><br><span class="line">sigma=(np.log(s0)-np.log(s_inf))/(s0+i0-s_inf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sigma=&#x27;</span>,sigma,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">S=np.array([<span class="number">155</span>,<span class="number">153</span>,<span class="number">139</span>,<span class="number">101</span>])</span><br><span class="line">I=(s0+i0)-S+<span class="number">1</span>/sigma * np.log(S/s0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;所求的解为：&#x27;</span>, I)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="插值与拟合"><a href="#插值与拟合" class="headerlink" title="插值与拟合"></a>插值与拟合</h3><p>​        在数学建模过程中，通常要处理由试验、测量得到的大量数据或一些过于复杂而不方便计算的函数表达式，针对此情况，很自然的想法就是，构造一个简单的函数作为要考察数据或复杂函数的近似. 插值和拟合就可以解决这样的问题</p>
<p>​        给定一组数据，需要确定满足特定要求的曲线（或曲面），如果所求曲线通过所给定的有限个数据点，这就是<strong>插值</strong>. 有时由于给定的数据存在测量误差，往往具有一定的随机性. 因而，通过所有数据点求曲线不现实也不必要. 如果不要求曲线通过所有数据点，而是要求它反映对象整体的变化态势，得到简单实用的近似函数，这就是<strong>拟合</strong>.</p>
<h4 id="拟合函数的选择"><a href="#拟合函数的选择" class="headerlink" title="拟合函数的选择"></a>拟合函数的选择</h4><p>数据拟合时，首要也是最关键的一步就是恰当的拟合函数. 如果能够根据问题的背景通过机理分析得到变量之间的函数关系，那么只需估计相应的参数即可. 但很多情况下，问题的机理并不清楚. 此时，一个较为自然的方法是先做出<strong>数据的散点图</strong>，从直观上判断应选用什么样的拟合函数.</p>
<ul>
<li><p>如果数据分布<strong>接近于直线</strong>，则拟合函数宜选用<strong>线性函数</strong> $f(x)&#x3D;a_1x+a_2$ ;</p>
</li>
<li><p>如果数据分布接近于<strong>抛物线</strong>，则拟合函数宜选用二次多项式  $f(x)&#x3D;a_1x^2+a_2x+a_3$ ;</p>
</li>
<li><p>如果数据分布特点是开始上升较快随后逐渐变缓，则宜选用双曲线型函数或指数型函数，即用 $f(x)&#x3D;\frac{x}{a_1x+a_2}$ 或  $ f(x)&#x3D;a_1e^{-\frac{a_2}{x}}$ ; </p>
</li>
<li><p>如果数据分布特点是开始下降较快随后逐渐变缓，则宜选用$f(x)&#x3D;\frac{1}{a_1x+a_2}$,$f(x)&#x3D;\frac{1}{a_1x^2+a_2}$ , $f(x)&#x3D;a_1e^{-a_2x}$</p>
</li>
<li><p>常被选用的非线性拟合函数有$y&#x3D;a_1+a_2\ lnx$  ，S形曲线函数为$y&#x3D;\frac{1}{a+be^{-x}}$</p>
</li>
</ul>
<h4 id="数据拟合python程序实现："><a href="#数据拟合python程序实现：" class="headerlink" title="数据拟合python程序实现："></a>数据拟合python程序实现：</h4><p>python中有多个模块的多种方法可以进行拟合未知参数. </p>
<p>Numpy中的多项式拟合函数polyfit</p>
<p>Scipy.optimize中的leastsq（最小二乘）、curve_fit</p>
<h5 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h5><p>对下表1的数据进行拟合，并求当x&#x3D;0.25 ,0.35 时, y的预测值.</p>
<center>表1 待拟合数据


<table>
<thead>
<tr>
<th>x</th>
<th>0</th>
<th>0.1</th>
<th>0.2</th>
<th>0.3</th>
<th>0.4</th>
<th>0.5</th>
<th>0.6</th>
<th>0.7</th>
<th>0.8</th>
<th>0.9</th>
<th>1.0</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>-0.447</td>
<td>1.978</td>
<td>3.28</td>
<td>6.16</td>
<td>7.08</td>
<td>7.34</td>
<td>7.66</td>
<td>9.56</td>
<td>9.48</td>
<td>9.30</td>
<td>11.2</td>
</tr>
</tbody></table>
<p>解:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示点</span></span><br><span class="line"><span class="keyword">import</span> numpy  <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x=np.arange(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0.1</span>)</span><br><span class="line"><span class="comment">#print(x)</span></span><br><span class="line">y=np.array([-<span class="number">0.447</span>,<span class="number">1.978</span>,<span class="number">3.28</span>,<span class="number">6.16</span>, <span class="number">7.08</span>, <span class="number">7.34</span>, <span class="number">7.66</span>, <span class="number">9.56</span>, <span class="number">9.48</span>, <span class="number">9.30</span>, <span class="number">11.2</span>])</span><br><span class="line">plt.plot(x,y,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo4.png" alt="shumo4"></p>
<p>可以看出,接近于直线或抛物线.这里抛物线更加准确.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy  <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x0=np.arange(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0.1</span>) <span class="comment">#设置初始为0,末尾1.1以前,步长0.1</span></span><br><span class="line">y0=np.array([-<span class="number">0.447</span>,<span class="number">1.978</span>,<span class="number">3.28</span>,<span class="number">6.16</span>, <span class="number">7.08</span>, <span class="number">7.34</span>, <span class="number">7.66</span>, <span class="number">9.56</span>, <span class="number">9.48</span>, <span class="number">9.30</span>, <span class="number">11.2</span>])</span><br><span class="line">p=np.polyfit(x0,y0,<span class="number">2</span>) <span class="comment">#拟合二次多项式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合二次多项式的从高次幂到低次幂系数分别为：&#x27;</span>,p)</span><br><span class="line">yhat=np.polyval(p,[<span class="number">0.25</span>,<span class="number">0.35</span>])  <span class="comment">#令x= 0.25,0.35 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测值分别为：&#x27;</span>,yhat)</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">plt.plot(x0,y0,<span class="string">&#x27;*&#x27;</span>,x0,np.polyval(p,x0),<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo5.png" alt="shumo5"></p>
<p>拟合二次多项式的从高次幂到低次幂系数分别为： [-9.81083916 20.12929371 -0.03167133]<br>预测值分别为： [4.38747465 5.81175367]</p>
<h5 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h5><p>对例1的数据用  <strong>curve_fit 函数</strong>拟合二次多项式，并求预测值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">y=<span class="keyword">lambda</span> x,a,b,c: a*x**<span class="number">2</span>+b*x+c</span><br><span class="line">x0=np.arange(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0.1</span>)</span><br><span class="line">y0=np.array([-<span class="number">0.447</span>,<span class="number">1.978</span>,<span class="number">3.28</span>,<span class="number">6.16</span>, <span class="number">7.08</span>, <span class="number">7.34</span>, <span class="number">7.66</span>, <span class="number">9.56</span>, <span class="number">9.48</span>, <span class="number">9.30</span>, <span class="number">11.2</span>])</span><br><span class="line"></span><br><span class="line">popt,pcov=curve_fit(y,x0,y0) <span class="comment">#返回值popt是拟合的参数，pcov是参数的协方差矩阵</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合的参数值为：&#x27;</span>,popt)</span><br><span class="line"><span class="comment">#此处*popt是序列解包，就是把列表popt的包装解开，得到几个元素，作为y的参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x=0.25时的预测值为：&#x27;</span>,y(<span class="number">0.25</span>,*popt)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x=0.35时的预测值为：&#x27;</span>,y(<span class="number">0.35</span>,*popt))</span><br><span class="line"></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>,family=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.plot(x0,y0,<span class="string">&#x27;*&#x27;</span>,x0,y(x0,*popt))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h5 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h5><p>用下标数据拟合二元函数  :  $z&#x3D;ae^{bx}+cy^2$ </p>
<table>
<thead>
<tr>
<th>x</th>
<th>6</th>
<th>2</th>
<th>6</th>
<th>7</th>
<th>4</th>
<th>2</th>
<th>5</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>4</td>
<td>9</td>
<td>5</td>
<td>3</td>
<td>8</td>
<td>5</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>z</td>
<td>5</td>
<td>2</td>
<td>1</td>
<td>9</td>
<td>7</td>
<td>4</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"></span><br><span class="line">x0=np.array([<span class="number">6</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>])</span><br><span class="line">y0=np.array([<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>])</span><br><span class="line">z0=np.array([<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">xy0=np.vstack((x0,y0))  <span class="comment"># 将x和y变为二维数组</span></span><br><span class="line"><span class="comment">#print(xy0)</span></span><br><span class="line"></span><br><span class="line">z_fun=<span class="keyword">lambda</span> t,a,b,c: a*np.exp(b*t[<span class="number">0</span>]) + c*t[<span class="number">1</span>]**<span class="number">2</span></span><br><span class="line">popt,pcov=curve_fit(z_fun,xy0,z0) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a,b,c的拟合值为：&#x27;</span>,popt)</span><br></pre></td></tr></table></figure>



<h5 id="例题四"><a href="#例题四" class="headerlink" title="例题四"></a>例题四</h5><p>利用模拟数据拟合曲面 $z&#x3D;e^{-\frac{(x-\mu_1)^2+(y-\mu_2)^2}{2\sigma^2}}$ , 并画出拟合曲面的图形</p>
<p>其中$\mu_1&#x3D;1$,$\mu_2 &#x3D;2$,$\sigma&#x3D;3$，生成加噪声的模拟数据$\mu_1&#x3D;1.0097$,$\mu_2 &#x3D;1.9968$,$\sigma&#x3D;3.0028$</p>
<p>画出拟合曲面:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">m=<span class="number">200</span></span><br><span class="line">n=<span class="number">300</span></span><br><span class="line">x=np.linspace(-<span class="number">6</span>,<span class="number">6</span>,m)  	<span class="comment">#生成200个点</span></span><br><span class="line">y=np.linspace(-<span class="number">8</span>,<span class="number">8</span>,n)  	<span class="comment">#生成300个点</span></span><br><span class="line">x2,y2=np.meshgrid(x,y) 	<span class="comment">#相当于在xoy平面生成所有的网格点</span></span><br><span class="line"></span><br><span class="line">x3=np.reshape(x2,(<span class="number">1</span>,-<span class="number">1</span>)) <span class="comment">#把x2的数据转换成一行，1表示1行，-1是通配符</span></span><br><span class="line">y3=np.reshape(y2,(<span class="number">1</span>,-<span class="number">1</span>)) </span><br><span class="line">xy=np.vstack((x3,y3)) 	<span class="comment">#叠加成两行的数组</span></span><br><span class="line"><span class="comment">#print(&#x27;xy=&#x27;,xy) #不懂vstack函数时可以用print输出观察，然后再注释掉</span></span><br><span class="line"></span><br><span class="line">pfun=<span class="keyword">lambda</span> t,mu1,mu2,sigma: np.exp(-((t[<span class="number">0</span>]-mu1)**<span class="number">2</span>+(t[<span class="number">1</span>]-mu2)**<span class="number">2</span>)/(<span class="number">2</span>*sigma**<span class="number">2</span>))</span><br><span class="line">z=pfun(xy,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">zr=z+<span class="number">0.2</span>*np.random.normal(size=z.shape) <span class="comment">#加了噪声的数据</span></span><br><span class="line"></span><br><span class="line">popt,pcov=curve_fit(pfun,xy,zr) <span class="comment">#拟合参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;三个参数的拟合值分别为：&#x27;</span>,popt)</span><br><span class="line">zn=pfun(xy,*popt) <span class="comment">#计算拟合函数的值</span></span><br><span class="line"></span><br><span class="line">zn2=np.reshape(zn,x2.shape)</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">ax=plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>) <span class="comment">#创建一个三维坐标轴对象</span></span><br><span class="line">ax.plot_surface(x2,y2,zn2,cmap=<span class="string">&#x27;gist_rainbow&#x27;</span>) <span class="comment">#gist_rainbow是曲面颜色参数</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo6.png" alt="shumo6"></p>
<h3 id="数学建模之回归分析"><a href="#数学建模之回归分析" class="headerlink" title="数学建模之回归分析"></a>数学建模之回归分析</h3><h4 id="多元线性回归模型"><a href="#多元线性回归模型" class="headerlink" title="多元线性回归模型"></a>多元线性回归模型</h4><p>通过对变量实际观测的分析、计算，建立一个变量与另一组变量的定量关系即回归方程，经统计检验认为回归效果显著后，可用于<strong>预测与控制</strong></p>
<p>设随机变量 $y$ 与变量 $x_1,x_2,…,x_m$ 有关则其 $m$ 元线性回归模型为：<br>$$<br>y&#x3D;\beta_0+\beta_1x_1+…+\beta_mx_m+\varepsilon<br>$$<br>$\varepsilon$是随机误差服从正态分布  $N(0,\sigma^2)$  ,$\beta_0,\beta_1,…,\beta_m$ 为回归系数。</p>
<h4 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h4><h5 id="由观察确定回归系数"><a href="#由观察确定回归系数" class="headerlink" title="由观察确定回归系数"></a>由观察确定回归系数</h5><p>$\beta_0,\beta_1,…,\beta_m$  的估计值  $b_0,b_1,…,b_m$</p>
<p>将 $n$ 组数据  $(y_i,x_{i1},..,x_{im})$  ,$i&#x3D;1,…,n (n&gt;m)$  带入 $y&#x3D;\beta_0+\beta_1x_1+…+\beta_mx_m+\varepsilon$ 有<br>$$<br>y_i&#x3D;\beta_0+\beta_1x_{i1}+…+\beta_mx_{im}+\varepsilon_i<br>$$</p>
<p>$$<br>记\ \ X&#x3D;<br>\begin{bmatrix}<br>1	   &amp; x_{11} &amp; x_{12} &amp; \cdots  &amp; x_{1m}\<br>1	   &amp; x_{21} &amp; x_{22} &amp; \cdots  &amp; x_{2m}\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>1	   &amp; x_{n1} &amp; x_{n2} &amp; \cdots  &amp; x_{nm}<br>\end{bmatrix},</p>
<p>Y&#x3D;<br>\begin{bmatrix}<br>y_{1} \<br>y_{2} \<br>\vdots \<br>y_{n}<br>\end{bmatrix},</p>
<p>\varepsilon&#x3D;<br>\begin{bmatrix}<br>\varepsilon_1 \ \varepsilon_2 \ \cdots \varepsilon_n<br>\end{bmatrix}^T,</p>
<p>\beta&#x3D;<br>\begin{bmatrix}<br>\beta_1 \ \beta_2 \ \cdots \beta_n<br>\end{bmatrix}^T.<br>$$</p>
<p> 则正规方程组为：$Y&#x3D;X \ \beta + \varepsilon$ , 正规方程组的回归系数的最小二乘法估计 $\hat{\beta}$ 为：<br>$$<br>\hat{\beta} &#x3D; (X^TX)^{-1}X^TY<br>$$<br>将$\hat{\beta}&#x3D;[b_0,b_1,…,b_m]$ 带入$y&#x3D;\beta_0+\beta_1x_1+…+\beta_mx_m+\varepsilon$   得到方程：<br>$$<br>y&#x3D;b_0+b_1x_1+…+b_mx_m<br>$$<br>将数据代入，则得 $y$ 的估计值:<br>$$<br>\hat{y} &#x3D; b_0+b_1x_1+…+b_mx_m<br>$$<br>估计值的残差平方和为:<br>$$<br>SSE&#x3D;\sum_{i&#x3D;1}^{n}e_i^2&#x3D;\sum_{i&#x3D;1}^{n}(y_i-\hat{y_i})^2<br>$$<br>回归平方和为:<br>$$<br>SSR&#x3D;\sum_{i&#x3D;1}^{n}(\overline{y}-\hat{y_i})^2<br>$$</p>
<h5 id="对线性关系、自变量的显著性进行统计检验"><a href="#对线性关系、自变量的显著性进行统计检验" class="headerlink" title="对线性关系、自变量的显著性进行统计检验"></a>对线性关系、自变量的显著性进行统计检验</h5><p>上面完美建立的线性回归方程是假定了变量$y$与$x_1,x_2,…,x_m$ 是有关系的，但真的是否有线性关系吗？需要做统计检验。</p>
<p>首先，因变量 $y$ 与 自变量$x_1,x_2,…,x_m$ 之间关系的检验方式，令原假设成立：<br>$$<br>H_0:\beta_1&#x3D;\beta_2&#x3D;…&#x3D;\beta_m&#x3D;0<br>$$<br>选择统计量$F&#x3D;\frac{SSR&#x2F;m}{SSE&#x2F;(n-m-1)}&#x3D;\frac{SSR\cdot(n-m-1)}{SSE\cdot  m}$~$F(m,n-m-1)$ 进行假设检验，对显著性水平$\alpha$ 和上分位数$F_\alpha(m,n-m-1)$ ,检验准则为：</p>
<ul>
<li><p>若 $ F&gt;F_\alpha(m,n-m-1)$,回归方程显著。</p>
</li>
<li><p>若 $ F&lt;F_\alpha(m,n-m-1)$,回归方程效果不显著。</p>
</li>
</ul>
<p>也可以采用复判定系数(也称拟合优度) $R^2&#x3D;\frac{SSR}{SSR+SSE}$ 作为权衡  $y$ 与 $x_1,x_2,…,x_m$ 相关程度的指标，$R&#x3D;\sqrt{R^2}$成为复相关系数，R越大，  $y$ 与 $x_1,x_2,…,x_m$ 相关关系越密切，通常R&gt;0.8&#x2F;0.9才认为相关关系成立。</p>
<h5 id="利用回归方程进行预测"><a href="#利用回归方程进行预测" class="headerlink" title="利用回归方程进行预测"></a>利用回归方程进行预测</h5><p>对于给定的$x_1^{(0)},x_2^{(0)},…,x_m^{(0)},$ 代入回归方程: $y&#x3D;b_0+b_1x_1+…+b_mx_m $ 得：<br>$$<br>\hat{y_0} &#x3D; b_0+b_1x_1^{(0)}+…+b_mx_m^{(0)},<br>$$<br>用 $\hat{y_0}$做 $y$ 在点$x_1^{(0)},x_2^{(0)},…,x_m^{(0)}$ 的预测值。</p>
<p>也可以进行区间的估计，记$s&#x3D;\sqrt{\frac{SSE}{n-m-1}} ， x_0&#x3D;[1,x_1^{(0)},x_	2^{(0)},…,x_m^{(0)}]$ , 则$y_0$的置信度为$1-\alpha$ 的车预测区间为：<br>$$<br>(\ \hat{y}-t_{1-\alpha&#x2F;2}(n-m-1)s\sqrt{1+x_0^T(X^TX)^{-1}x_0}\ ,\ \hat{y}+t_{1-\alpha&#x2F;2}(n-m-1)s\sqrt{1+x_0^T(X^TX)^{-1}x_0}\ )<br>$$</p>
<h4 id="例题一："><a href="#例题一：" class="headerlink" title="例题一："></a>例题一：</h4><p>水泥凝固时放出的热量 y 与水泥中两种主要化学分成 x<sub>1</sub>,x<sub>2</sub> 有关，今测得一组数据如表1所示，试确定一个线性回归模型$y&#x3D;a_0+a_1x_1+a_2x_2$.</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$y$</th>
<th>序号</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$y$</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>7</td>
<td>26</td>
<td>78.5</td>
<td>8</td>
<td>1</td>
<td>31</td>
<td>72.5</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>29</td>
<td>74.3</td>
<td>9</td>
<td>2</td>
<td>54</td>
<td>93.1</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>56</td>
<td>104.3</td>
<td>10</td>
<td>21</td>
<td>47</td>
<td>115.9</td>
</tr>
<tr>
<td>4</td>
<td>11</td>
<td>31</td>
<td>87.6</td>
<td>11</td>
<td>1</td>
<td>40</td>
<td>83.8</td>
</tr>
<tr>
<td>5</td>
<td>7</td>
<td>52</td>
<td>95.9</td>
<td>12</td>
<td>11</td>
<td>66</td>
<td>113.3</td>
</tr>
<tr>
<td>6</td>
<td>11</td>
<td>55</td>
<td>109.2</td>
<td>13</td>
<td>10</td>
<td>68</td>
<td>109.4</td>
</tr>
<tr>
<td>7</td>
<td>3</td>
<td>71</td>
<td>102.7</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="程序一：利用模块sklearn-linear-model中的函数LinearRegression求解"><a href="#程序一：利用模块sklearn-linear-model中的函数LinearRegression求解" class="headerlink" title="程序一：利用模块sklearn.linear_model中的函数LinearRegression求解"></a>程序一：利用模块sklearn.linear_model中的函数LinearRegression求解</h5><p>解：求得回归模型为<br>$$<br>y&#x3D;52.5773+1.4683x_1+0.6623x_2<br>$$<br>模型的拟合优度$R^2&#x3D;0.9787$,说明拟合效果很好.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">a = np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡17_例2.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">md = LinearRegression().fit(a[:,:<span class="number">2</span>],a[:,<span class="number">2</span>]) <span class="comment">#构建并拟合模型</span></span><br><span class="line"><span class="comment">#上行切片表示用数据的所有行、前两列数据作自变量，所有行、最后一列的数据作因变量</span></span><br><span class="line">y=md.predict(a[:,:<span class="number">2</span>])   <span class="comment">#求预测值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测值为&#x27;</span>,y)      <span class="comment">#输出拟合好后的预测值</span></span><br><span class="line">b0=md.intercept_        <span class="comment">#输出回归模型中的常数项</span></span><br><span class="line">b12=md.coef_            <span class="comment">#输出回归模型的回归系数（常数项以外）</span></span><br><span class="line">R2=md.score(a[:,:<span class="number">2</span>],a[:,<span class="number">2</span>]) <span class="comment">#计算R^2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;回归模型的常数项为&#x27;</span>,b0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;回归模型的自变量系数为&#x27;</span>,b12)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度R^2=&#x27;</span>,R2)</span><br></pre></td></tr></table></figure>



<h4 id="线性回归模型的正则化求解"><a href="#线性回归模型的正则化求解" class="headerlink" title="线性回归模型的正则化求解"></a>线性回归模型的正则化求解</h4><p>在多元线性回归中，解释变量$x_1,x_2,…,x_m$之间出现严重的多重线性时，普通的最小二乘法估计模型参数，往往参数估计方差太大，使普通最小二乘法的效果很不理想. 为改进线性回归模型，采用线性回归正则化方法，岭回归和Lasso回归是其中的两种方法</p>
<p>这里我认为是机器学习中次方过大，导致过拟合，于是得到的函数干扰太大拟合效果不好。</p>
<h5 id="法一：岭回归"><a href="#法一：岭回归" class="headerlink" title="法一：岭回归"></a>法一：岭回归</h5><h6 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h6><p>Malinvand于1966年提出的研究法国经济问题的一组数据，如下表1. 所考虑的因变量为进口总额<strong>y</strong> , 三个解释变量分别为：国内总产值<strong>x<sub>1</sub><strong>、储存量</strong>x<sub>2</sub><strong>、总消费</strong>x<sub>3</sub></strong>(单位均为10亿法郎). 建立<strong>y与x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub>的关系</strong></p>
<table>
<thead>
<tr>
<th align="center">年份</th>
<th align="center">$x_1$</th>
<th align="center">$x_2$</th>
<th align="center">$x_3$</th>
<th align="center">$y$</th>
<th align="center">年份</th>
<th align="center">$x_1$</th>
<th align="center">$x_2$</th>
<th align="center">$x_3$</th>
<th align="center">$y$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1949</td>
<td align="center">149.3</td>
<td align="center">4.2</td>
<td align="center">108.1</td>
<td align="center">15.9</td>
<td align="center">1955</td>
<td align="center">202.1</td>
<td align="center">2.1</td>
<td align="center">146.0</td>
<td align="center">22.7</td>
</tr>
<tr>
<td align="center">1950</td>
<td align="center">171.5</td>
<td align="center">4.1</td>
<td align="center">114.8</td>
<td align="center">16.4</td>
<td align="center">1956</td>
<td align="center">212.4</td>
<td align="center">5.6</td>
<td align="center">154.1</td>
<td align="center">26.5</td>
</tr>
<tr>
<td align="center">1951</td>
<td align="center">175.5</td>
<td align="center">3.1</td>
<td align="center">123.2</td>
<td align="center">19.0</td>
<td align="center">1957</td>
<td align="center">226.1</td>
<td align="center">5.0</td>
<td align="center">162.3</td>
<td align="center">28.1</td>
</tr>
<tr>
<td align="center">1952</td>
<td align="center">180.8</td>
<td align="center">3.1</td>
<td align="center">126.9</td>
<td align="center">19.1</td>
<td align="center">1958</td>
<td align="center">231.9</td>
<td align="center">5.1</td>
<td align="center">164.3</td>
<td align="center">27.6</td>
</tr>
<tr>
<td align="center">1953</td>
<td align="center">190.7</td>
<td align="center">1.1</td>
<td align="center">132.1</td>
<td align="center">18.8</td>
<td align="center">1959</td>
<td align="center">239.0</td>
<td align="center">0.7</td>
<td align="center">167.6</td>
<td align="center">26.3</td>
</tr>
<tr>
<td align="center">1954</td>
<td align="center">202.1</td>
<td align="center">2.2</td>
<td align="center">137.7</td>
<td align="center">20.4</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h6 id="用最小二乘估计建立模型"><a href="#用最小二乘估计建立模型" class="headerlink" title="用最小二乘估计建立模型"></a>用最小二乘估计建立模型</h6><p>对于上述问题，可以直接用普通的最小二乘估计建立$y$关于三个解释变量x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub> 的回归方程为$y&#x3D;-8.6203-0.0742x_1+0.5104x_2+0.3116x_3$ , 并且模型的统计检验指标都相当好，但是$x_1$的系数为负数，这是不符合经济意义的，因为法国是一个原材料进口国，当国内总产值$x_1$增大时，进口总额$y$肯定也会增加，所以符号应该时正的。原因可能是三个自变量x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub> 之间存在多重共线性。</p>
<p>计算$x_1,x_2,x_3$的相关系数矩阵为：<br>$$<br>R&#x3D;<br>\begin{pmatrix}<br>1		&amp;  -0.0329	&amp; 0.9869\<br>-0.0329 &amp;  1		&amp; 0.0357\<br>0.9869	&amp;  0.0357	&amp; 1<br>\end{pmatrix}<br>$$<br>可以看到$x_1\text{与}x_2$的相关系数高达0.9869，说明$x_1与x_3$基本线性相关，若将$x_3$看为因变量，$x_1$看作解释变量，那么$x_3$关于$x_1$的一元线性回归方程为：<br>$$<br>x_3&#x3D;-4.9632+0.7297x_1<br>$$<br>说明$x_3与x_1$之间存在着多重共线性关系。</p>
<h6 id="利用statsmodels库求解线性回归分析"><a href="#利用statsmodels库求解线性回归分析" class="headerlink" title="利用statsmodels库求解线性回归分析"></a>利用statsmodels库求解线性回归分析</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">基于数组构建并拟合模型的调用格式为:</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line">sm.OLS(y,X).fit()</span><br></pre></td></tr></table></figure>

<p>程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line">a=np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡18_例1.txt&#x27;</span>)</span><br><span class="line"><span class="comment">#print(a)</span></span><br><span class="line"><span class="comment">#print(a[:5])</span></span><br><span class="line">x=a[:,:<span class="number">3</span>] <span class="comment">#提取自变量观察值矩阵</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">XG=sm.add_constant(x) <span class="comment">#增加第一列全部元素为1得到增广矩阵</span></span><br><span class="line"><span class="built_in">print</span>(XG)</span><br><span class="line"></span><br><span class="line">md=sm.OLS(a[:,<span class="number">3</span>],XG).fit()<span class="comment">#构建并拟合模型</span></span><br><span class="line">b=md.params <span class="comment">#提取所有回归系数</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;$&#x27;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">y=md.predict(XG) <span class="comment">#求已知自变量值的预测值</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;$&#x27;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(md.summary()) <span class="comment"># 输出模型的所有结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;相关系数矩阵：\n&#x27;</span>,np.corrcoef(x.T))</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成新的矩阵，第1列全部是1，第2列是a的第1列数据</span></span><br><span class="line">X1=sm.add_constant(a[:,<span class="number">0</span>])</span><br><span class="line"><span class="comment">#print(X1)</span></span><br><span class="line">md1=sm.OLS(a[:,<span class="number">2</span>],X1).fit() <span class="comment">#构建并拟合模型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;回归系数为：&#x27;</span>,md1.params)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ print(md.summary()) #这一步中输出为：</span><br><span class="line"></span><br><span class="line">UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=11</span><br><span class="line">warnings.warn(&quot;kurtosistest only valid for n&gt;=20 ... continuing &quot;</span><br><span class="line">                   </span><br><span class="line">                   OLS Regression Results              </span><br><span class="line">====================================================================</span><br><span class="line">Dep. Variable:			y         R-squared:                  0.996</span><br><span class="line">Model:				  OLS         Adj. R-squared:             0.994</span><br><span class="line">Method:     Least Squares         F-statistic:                542.0</span><br><span class="line">Date:    Wed, 12 Aug 2020         Prob (F-statistic):      1.20e-08</span><br><span class="line">Time:            11:52:08         Log-Likelihood:           -1.7480</span><br><span class="line">No. Observations:      11         AIC:                        11.50</span><br><span class="line">Df Residuals:           7         BIC:                        13.09</span><br><span class="line">Df Model:               3                                         </span><br><span class="line">Covariance Type:nonrobust    </span><br><span class="line"></span><br><span class="line">#本人注释：1. Method: Least Squares(最小二乘法)  </span><br><span class="line">		 2.	R-squared: 0.996(复判定系数或叫拟合优度R^2,越高拟合越好)</span><br><span class="line"></span><br><span class="line">====================================================================</span><br><span class="line">          coef    std err      t       P&gt;|t|      [0.025      0.975]</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">const    -8.6203    0.897    -9.611     0.000    -10.741     -6.499</span><br><span class="line">x1       -0.0742    0.028    -2.691     0.031    -0.139      -0.009</span><br><span class="line">x2        0.5104    0.075     6.781     0.000     0.332       0.688</span><br><span class="line">x3        0.3116    0.037     8.357     0.000     0.223       0.400</span><br><span class="line">====================================================================</span><br><span class="line">Omnibus:           5.258        Durbin-Watson:              2.400</span><br><span class="line">Prob(Omnibus):     0.072        Jarque-Bera (JB):           2.250</span><br><span class="line">Skew:              1.080        Prob(JB):                   0.325</span><br><span class="line">Kurtosis:          3.495        Cond. No.                2.05e+03</span><br><span class="line"></span><br><span class="line">#本人注释：1.coef所对应的那一列 拟合系数</span><br><span class="line"></span><br><span class="line">====================================================================</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line">[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</span><br><span class="line">[2] The condition number is large, 2.05e+03. This might indicate that there are</span><br><span class="line">strong multicollinearity or other numerical problems.</span><br><span class="line"></span><br><span class="line">相关系数矩阵：</span><br><span class="line"> [[ 1.         -0.03291436  0.98690551]---&gt;&gt;0.9869很高x1与x2相关性很大</span><br><span class="line"> [-0.03291436  1.          0.03567322]</span><br><span class="line"> [ 0.98690551  0.03567322  1.        ]]</span><br><span class="line"> </span><br><span class="line">回归系数为： [-4.96322784  0.72966696]  ---&gt; x3=-4.963+0.72967*x1</span><br></pre></td></tr></table></figure>



<h5 id="改进的模型：岭回归方程"><a href="#改进的模型：岭回归方程" class="headerlink" title="改进的模型：岭回归方程"></a>改进的模型：岭回归方程</h5><p>为了消除变量之间的多重共线性关系的影响，即消除最小二乘解的参数估计$\hat{\beta} &#x3D; (X^TX)^{-1}X^TY中X^TY的奇异性$，采用岭回归模型，即参数估计为：<br>$$<br>\hat{\beta} (k)&#x3D; (X^TX+kI)^{-1}X^TY<br>$$<br>其中，k是岭参数.   岭参数的选择有岭迹法和均方误差法.</p>
<p>求上面那道例题的岭回归方程：</p>
<p>我们可以解得k&#x3D;0.15时，取得较好的拟合效果。对应的标准化岭回归方程为：<br>$$<br>\hat{y}^*&#x3D;0.0610x_1+0.2179x_2+0.8926x_3<br>$$<br>将标准化的回归方程还原后得:<br>$$<br>\hat{y}&#x3D;-9.5320+0.0410x_1+0.6231x_2+0.1520x_3<br>$$<br>拟合优度为 0.9899</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge,RidgeCV</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> zscore</span><br><span class="line"></span><br><span class="line">a=np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡18_例1.txt&#x27;</span>)</span><br><span class="line">n=a.shape[<span class="number">1</span>]-<span class="number">1</span>  <span class="comment">#设置自变量的总个数</span></span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line">aa=zscore(a) <span class="comment">#数据的标准化</span></span><br><span class="line">x=aa[:,:n]   <span class="comment">#提出自变量观察值矩阵 取前三列x1\x2\x3</span></span><br><span class="line">y=aa[:,n]    <span class="comment">#提出因变量矩阵      取最后一列y</span></span><br><span class="line">b=[]         <span class="comment">#用于存储回归系数的空列表</span></span><br><span class="line"></span><br><span class="line">kk=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)  <span class="comment">#设置的不同k值</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> kk:              <span class="comment">#循环迭代的不同k值</span></span><br><span class="line">    md=Ridge(alpha=k).fit(x,y)</span><br><span class="line">    b.append(md.coef_)    <span class="comment">#系数保存在列表中</span></span><br><span class="line"></span><br><span class="line">st=[<span class="string">&#x27;s-r&#x27;</span>,<span class="string">&#x27;*-k&#x27;</span>,<span class="string">&#x27;p-b&#x27;</span>]       <span class="comment">#下面画图的控制字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.plot(kk,np.array(b)[:,i],st[i]) <span class="comment">#作图</span></span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>,<span class="string">&#x27;x3&#x27;</span>],fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">mdcv=RidgeCV(alphas=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)).fit(x,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优alpha=&#x27;</span>,mdcv.alpha_)</span><br><span class="line"></span><br><span class="line"><span class="comment">#md0=Ridge(mdcv.alpha_).fit(x,y) #构建并拟合模型.先选择此行命令，得到最佳k值，但拟合出的x1的系数是负</span></span><br><span class="line">md0=Ridge(<span class="number">0.15</span>).fit(x,y)  <span class="comment">#x1的系数是负，所以这里主观选择k=0.15时得到的拟合优度高，而且变量的拟合系数都是正的</span></span><br><span class="line">cs0=md0.coef_ <span class="comment">#提取标准化数据的回归系数b1,b2,b3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准化数据的所有回归系数为：&#x27;</span>,cs0)</span><br><span class="line"></span><br><span class="line">mu=np.mean(a,axis=<span class="number">0</span>) <span class="comment">#计算所有指标的均值</span></span><br><span class="line">s=np.std(a,axis=<span class="number">0</span>,ddof=<span class="number">1</span>)  <span class="comment">#计算所有的标准差</span></span><br><span class="line">params=[mu[-<span class="number">1</span>]-s[-<span class="number">1</span>]*<span class="built_in">sum</span>(cs0*mu[:-<span class="number">1</span>]/s[:-<span class="number">1</span>]),s[-<span class="number">1</span>]*cs0/s[:-<span class="number">1</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数据的回归系数为：&#x27;</span>,params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度为&#x27;</span>,md0.score(x,y))</span><br></pre></td></tr></table></figure>



<h4 id="lasson-回归"><a href="#lasson-回归" class="headerlink" title="lasson  回归"></a>lasson  回归</h4><h5 id="数学原理简介"><a href="#数学原理简介" class="headerlink" title="数学原理简介"></a>数学原理简介</h5><p>多元回归中的普通最小二乘法是拟合参数向量$\beta$，使得$\left |X\beta-Y \right |^2_2$达到最小值. 岭回归是选择了合适的参数$k\geq 0$ ,拟合参数向量$\beta$ ,使得$\left |X\beta-Y \right |^2_2-\left |k\beta \right |^2_2$达到最小值，解决了$X^TX$不可逆的问题. Lasso回归，是选择合适的参数$k\geq 0$ ,拟合参数向量$\beta$ ,使得<br>$$<br>J(\beta)&#x3D;\left |X\beta-Y \right |^2_2-\left |k\beta \right |_1<br>$$<br>达到最小值，$\left |k\beta \right |_1$为目标函数的惩罚项，k为惩罚系数</p>
<p>lasson回归</p>
<p>由于拟合Lasso回归模型参数时，使用的损失函数（机器学习中的用语）中包含惩罚系数k,因此在计算模型回归系数之前，仍然需要得到最理想的k值，与岭回归模型类似，k值的确定可以通过定性的可视化方法.</p>
<h6 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h6><p>用此方法求解：（上面题的Lasso回归的题目）</p>
<p>Malinvand于1966年提出的研究法国经济问题的一组数据，如下表1. 所考虑的因变量为进口总额<strong>y</strong> , 三个解释变量分别为：国内总产值<strong>x<sub>1</sub><strong>、储存量</strong>x<sub>2</sub><strong>、总消费</strong>x<sub>3</sub></strong>(单位均为10亿法郎). 建立<strong>y与x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub>的关系</strong></p>
<table>
<thead>
<tr>
<th align="center">年份</th>
<th align="center">$x_1$</th>
<th align="center">$x_2$</th>
<th align="center">$x_3$</th>
<th align="center">$y$</th>
<th align="center">年份</th>
<th align="center">$x_1$</th>
<th align="center">$x_2$</th>
<th align="center">$x_3$</th>
<th align="center">$y$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1949</td>
<td align="center">149.3</td>
<td align="center">4.2</td>
<td align="center">108.1</td>
<td align="center">15.9</td>
<td align="center">1955</td>
<td align="center">202.1</td>
<td align="center">2.1</td>
<td align="center">146.0</td>
<td align="center">22.7</td>
</tr>
<tr>
<td align="center">1950</td>
<td align="center">171.5</td>
<td align="center">4.1</td>
<td align="center">114.8</td>
<td align="center">16.4</td>
<td align="center">1956</td>
<td align="center">212.4</td>
<td align="center">5.6</td>
<td align="center">154.1</td>
<td align="center">26.5</td>
</tr>
<tr>
<td align="center">1951</td>
<td align="center">175.5</td>
<td align="center">3.1</td>
<td align="center">123.2</td>
<td align="center">19.0</td>
<td align="center">1957</td>
<td align="center">226.1</td>
<td align="center">5.0</td>
<td align="center">162.3</td>
<td align="center">28.1</td>
</tr>
<tr>
<td align="center">1952</td>
<td align="center">180.8</td>
<td align="center">3.1</td>
<td align="center">126.9</td>
<td align="center">19.1</td>
<td align="center">1958</td>
<td align="center">231.9</td>
<td align="center">5.1</td>
<td align="center">164.3</td>
<td align="center">27.6</td>
</tr>
<tr>
<td align="center">1953</td>
<td align="center">190.7</td>
<td align="center">1.1</td>
<td align="center">132.1</td>
<td align="center">18.8</td>
<td align="center">1959</td>
<td align="center">239.0</td>
<td align="center">0.7</td>
<td align="center">167.6</td>
<td align="center">26.3</td>
</tr>
<tr>
<td align="center">1954</td>
<td align="center">202.1</td>
<td align="center">2.2</td>
<td align="center">137.7</td>
<td align="center">20.4</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso, LassoCV</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> zscore</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">a=np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡18_例1.txt&#x27;</span>)</span><br><span class="line">n=a.shape[<span class="number">1</span>]-<span class="number">1</span>              <span class="comment">#自变量的总个数</span></span><br><span class="line">aa=zscore(a)                <span class="comment">#数据标准化</span></span><br><span class="line">x=aa[:,:n]                  <span class="comment">#提取自变量观测值矩阵</span></span><br><span class="line">y=aa[:,n]                   <span class="comment">#提取因变量观察值矩阵</span></span><br><span class="line">b=[]                        <span class="comment">#用于存储回归系数的空列表</span></span><br><span class="line"></span><br><span class="line">kk=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)    <span class="comment">#生成从10的a次方到10的b次方之间按对数等分的n个元素的行向量</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> kk:                <span class="comment">#循环迭代的不同k值</span></span><br><span class="line">    md=Lasso(alpha=k).fit(x,y)</span><br><span class="line">    b.append(md.coef_)</span><br><span class="line"></span><br><span class="line">st=[<span class="string">&#x27;s-r&#x27;</span>,<span class="string">&#x27;*-k&#x27;</span>,<span class="string">&#x27;p-b&#x27;</span>]      <span class="comment">#下面画图的控制字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.plot(kk,np.array(b)[:,i],st[i])</span><br><span class="line">plt.legend([<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>,<span class="string">&#x27;x3&#x27;</span>],fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">mdcv=LassoCV(alphas=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)).fit(x,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优alpha=&#x27;</span>,mdcv.alpha_)</span><br><span class="line"></span><br><span class="line"><span class="comment">#md0=Lasso(mdcv.alpha_).fit(x,y) #构建并拟合模型</span></span><br><span class="line"></span><br><span class="line">md0=Lasso(<span class="number">0.21</span>).fit(x,y) <span class="comment">#构建并拟合模型</span></span><br><span class="line">cs0=md0.coef_  <span class="comment">#提出标准化数据回归系数b1,b2,b3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准化数据的所有回归系数为：&#x27;</span>,cs0)</span><br><span class="line"></span><br><span class="line">mu=np.mean(a,axis=<span class="number">0</span>)  <span class="comment">#计算所有指标的均值</span></span><br><span class="line">s=np.std(a,axis=<span class="number">0</span>,ddof=<span class="number">1</span>)  <span class="comment">#计算所有指标的标准差</span></span><br><span class="line"></span><br><span class="line">params=[mu[-<span class="number">1</span>]-s[-<span class="number">1</span>]*<span class="built_in">sum</span>(cs0*mu[:<span class="number">1</span>]/s[:-<span class="number">1</span>]),s[-<span class="number">1</span>]*cs0/s[:-<span class="number">1</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数据的回归系数为：&#x27;</span>,params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度：&#x27;</span>,md0.score(x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h6><p>在建立中国私人轿车拥有量模型时，主要考虑一下因素：</p>
<ul>
<li>城镇居民家庭人均可支配收入$x_1$元</li>
<li>全国城镇人口$x_2$亿元</li>
<li>全国汽车产量$x_3$万辆</li>
<li>全国公路长度$x_4$万千米</li>
<li>中国私人轿车拥有量为 $y$ 万辆</li>
</ul>
<p>求建立y的经验公式</p>
<table>
<thead>
<tr>
<th>年份</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$x_3$</th>
<th>$x_4$</th>
<th>$y$</th>
</tr>
</thead>
<tbody><tr>
<td>1994</td>
<td>3496.2</td>
<td>3.43</td>
<td>136.69</td>
<td>111.78</td>
<td>205.42</td>
</tr>
<tr>
<td>1995</td>
<td>4283</td>
<td>3.52</td>
<td>145.27</td>
<td>115.7</td>
<td>249.96</td>
</tr>
<tr>
<td>1996</td>
<td>4838.9</td>
<td>3.73</td>
<td>147.52</td>
<td>118.58</td>
<td>289.67</td>
</tr>
<tr>
<td>1997</td>
<td>5160.3</td>
<td>3.94</td>
<td>158.25</td>
<td>122.64</td>
<td>358.36</td>
</tr>
<tr>
<td>1998</td>
<td>5425.1</td>
<td>4.16</td>
<td>163</td>
<td>127.85</td>
<td>423.65</td>
</tr>
<tr>
<td>1999</td>
<td>5854</td>
<td>4.37</td>
<td>183.2</td>
<td>135.17</td>
<td>533.88</td>
</tr>
<tr>
<td>2000</td>
<td>6280</td>
<td>4.59</td>
<td>207</td>
<td>140.27</td>
<td>625.33</td>
</tr>
<tr>
<td>2001</td>
<td>6859.6</td>
<td>4.81</td>
<td>234.17</td>
<td>169.8</td>
<td>770.78</td>
</tr>
<tr>
<td>2002</td>
<td>7702.8</td>
<td>5.02</td>
<td>325.1</td>
<td>176.52</td>
<td>968.98</td>
</tr>
</tbody></table>
<p>解 &#x3D;&#x3D;（建模思路：可先用普通最小二乘法建立模型，找出不足，然后提出用Lasso模型进行改进，这样体现了建模的逐渐深入和完善的过程，论文也有层次）&#x3D;&#x3D;</p>
<p>首先，最小二乘法建立y与变量之间的关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"></span><br><span class="line">a  = np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡19_例2.txt&#x27;</span>)</span><br><span class="line">n  = a.shape[<span class="number">1</span>]-<span class="number">1</span>               <span class="comment"># 算出自变量数目</span></span><br><span class="line">x  = a[:,:n]                    <span class="comment"># 得到所有的自变量</span></span><br><span class="line">XG = sm.add_constant(x)         <span class="comment"># 变量标准化</span></span><br><span class="line">md = sm.OLS(a[:,n],XG).fit()    <span class="comment"># 构建并拟合模型</span></span><br><span class="line"><span class="built_in">print</span>(md.summary())             <span class="comment"># 输出模型的所有结果</span></span><br></pre></td></tr></table></figure>

<p>out:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   OLS Regression Results                  </span><br><span class="line">====================================================================</span><br><span class="line">Dep. Variable:            y       R-squared:  拟合度            0.999</span><br><span class="line">Model:                  OLS       Adj. R-squared:              0.999</span><br><span class="line">Date:      Thu, 13 Aug 2020       Prob (F-statistic):       1.14e-06</span><br><span class="line">Time:              20:39:48       Log-Likelihood:            -28.919</span><br><span class="line">No. Observations:         9       AIC:                         67.84</span><br><span class="line">Df Residuals:             4       BIC:                         68.82</span><br><span class="line">Df Model:                 4                                        </span><br><span class="line">Covariance Type:  nonrobust                                         </span><br><span class="line">====================================================================</span><br><span class="line">          coef       std err    t      P&gt;|t|     [0.025     0.975]</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">const  -1028.4134    58.305   -17.638   0.000   -1190.294   -866.532</span><br><span class="line">x1        -0.0159     0.015    -1.043   0.356      -0.058      0.026</span><br><span class="line">x2       245.6120    34.213     7.179   0.002     150.622    340.602</span><br><span class="line">x3         1.6316     0.178     9.148   0.001       1.136      2.127</span><br><span class="line">x4         2.0294     0.580     3.500   0.025       0.420      3.639</span><br><span class="line">      这上面就是系数了                 0.356大于0.05</span><br><span class="line">                                    说明x1对y不显著</span><br><span class="line">====================================================================</span><br><span class="line">Omnibus:           0.575      Durbin-Watson:                   2.151</span><br><span class="line">Prob(Omnibus):     0.750      Jarque-Bera (JB):                0.560</span><br><span class="line">Skew:              0.368      Prob(JB):                        0.756</span><br><span class="line">Kurtosis:          2.025      Cond. No.                     1.24e+05</span><br><span class="line">====================================================================</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line">[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</span><br><span class="line">[2] The condition number is large, 1.24e+05. This might indicate that there are</span><br><span class="line">strong multicollinearity or other numerical problems.</span><br></pre></td></tr></table></figure>

<p>这里曲线拟合$R^2&#x3D;0.999$ 拟合效果很好，但是看到$x_1系数&lt;0$所以不符合现实，且在显著水平$\alpha&#x3D;0.05$下，x1对y不显著。</p>
<p>这里输出结果中，写出了所有变量前面的系数。<br>$$<br>\hat{y}&#x3D;-1028.4134-0.0159x_1+245.6120x_2+1.6316x_3+2.0294x_4<br>$$<br>所以我们要优化：Lasso回归部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso,LassoCV</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> zscore</span><br><span class="line"></span><br><span class="line">a  = np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡19_例2.txt&#x27;</span>)</span><br><span class="line">n  = a.shape[<span class="number">1</span>]-<span class="number">1</span>               <span class="comment"># 算出自变量数目</span></span><br><span class="line">aa = zscore(a)                  <span class="comment"># 数据标准化</span></span><br><span class="line">x  = aa[:,:n]                   <span class="comment"># 提出自变量的观测值</span></span><br><span class="line">y  = aa[:, n]                   <span class="comment"># 提出因变量的观测值矩阵</span></span><br><span class="line"></span><br><span class="line">b  = []                         <span class="comment"># 用于存储回归系数的空列表</span></span><br><span class="line">kk = np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)      <span class="comment"># 将-4到0进行99等分得到100个数的等差数列，再生成以10为底的，以等差数列的值为指数的等比数列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> kk :</span><br><span class="line">    md=Lasso(alpha=k).fit(x,y)  <span class="comment"># 循环遍历所有的k</span></span><br><span class="line">    b.append(md.coef_)          <span class="comment"># 得到系数</span></span><br><span class="line"></span><br><span class="line">st=[<span class="string">&#x27;s-r&#x27;</span>,<span class="string">&#x27;*-k&#x27;</span>,<span class="string">&#x27;p-b&#x27;</span>,<span class="string">&#x27;^-y&#x27;</span>]    <span class="comment">#下面画图的控制字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    plt.plot(kk,np.array(b)[:,i],st[i])</span><br><span class="line">plt.legend([<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>,<span class="string">&#x27;x3&#x27;</span>,<span class="string">&#x27;x4&#x27;</span>],fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">mdcv = LassoCV(alphas=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)).fit(x,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优 alpha=&#x27;</span>,mdcv.alpha_)</span><br><span class="line"><span class="comment">#md0=Lasso(mdcv.alpha_).fit(x,y)  # 构建并拟合模型</span></span><br><span class="line">md0 = Lasso(<span class="number">0.05</span>).fit(x,y)</span><br><span class="line"></span><br><span class="line">cs0=md0.coef_                     <span class="comment"># 取出标准化数据的回归系数b1.b2,b3,b4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准化数据的所有回归系数为：&#x27;</span>,cs0)</span><br><span class="line"></span><br><span class="line">mu = a.mean(axis=<span class="number">0</span>)               <span class="comment">#计算所有指标的均差</span></span><br><span class="line">s  = a.std(axis=<span class="number">0</span>,ddof=<span class="number">1</span>)         <span class="comment">#计算所有指标的方差</span></span><br><span class="line">params = [mu[-<span class="number">1</span>]-s[-<span class="number">1</span>]*<span class="built_in">sum</span>(cs0*mu[:-<span class="number">1</span>]),s[-<span class="number">1</span>]*cs0/s[:-<span class="number">1</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数据的回归系数为:&#x27;</span>,params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度：&#x27;</span>,md0.score(x,y))</span><br></pre></td></tr></table></figure>

<p>拓展阅读：（了解就可以了，明白什么时候选择Lasso回归合适.）</p>
<p>对于高维数据，维数灾难所带来的过拟合问题，其解决思路是：1）增加样本量；2）减少样本特征，而对于现实情况，会存在所能获取到的样本数据量有限的情况，甚至远小于数据维度，即：d&gt;&gt;n。如证券市场交易数据、多媒体图形图像视频数据、航天航空采集数据、生物特征数据等。 </p>
<p>主成分分析作为一种数据降维方法，其出发点是通过整合原本的单一变量来得到一组新的综合变量，综合变量所代表的意义丰富且变量间互不相关，综合变量包含了原变量大部分的信息，这些综合变量称为主成分。主成分分析是在保留所有原变量的基础上，通过原变量的线性组合得到主成分，选取少数主成分就可保留原变量的绝大部分信息，这样就可用这几个主成分来代替原变量，从而达到降维的目的。</p>
<p>主成分分析法只适用于数据空间维度小于样本量的情况，当数据空间维度很高时，将不再适用。</p>
<p><strong>Lasso是另一种数据降维方法，该方法不仅适用于线性情况，也适用于非线性情况。Lasso是基于惩罚方法对样本数据进行变量选择，通过对原本的系数进行压缩，将原本很小的系数直接压缩至0，从而将这部分系数所对应的变量视为非显著性变量，将不显著的变量直接舍弃。</strong></p>
<h2 id="常用的数据清洗方法"><a href="#常用的数据清洗方法" class="headerlink" title="常用的数据清洗方法"></a>常用的数据清洗方法</h2><p>在数据处理的过程中，一般都需要进行数据的清洗工作，如数据集是否存在重复、缺失，数据是否具有完整性和一致性、数据中是否存在异常值等. 当发现数据中存在如上可能的问题时，都需要有针对性地处理。现在介绍如何识别和处理重复观察、缺失值和异常值.</p>
<h3 id="重复观测处理"><a href="#重复观测处理" class="headerlink" title="重复观测处理"></a>重复观测处理</h3><p>运用pandas对读入的数据进行重复项检查，以及如何删除数据中的重复项。</p>
<center>数据一</center>

<table>
<thead>
<tr>
<th>appcategory</th>
<th>appname</th>
<th>comments</th>
<th>install</th>
<th>love</th>
<th>size</th>
<th>update</th>
</tr>
</thead>
<tbody><tr>
<td>网上购物-商城-团购-优惠-快递</td>
<td>每日优鲜</td>
<td>1297</td>
<td>204.7万</td>
<td>89.00%</td>
<td>15.16MB</td>
<td>2017年10月11日</td>
</tr>
<tr>
<td>网上购物-商城</td>
<td>苏宁易购</td>
<td>577</td>
<td>7996.8万</td>
<td>73.00%</td>
<td>58.9MB</td>
<td>2017年09月21日</td>
</tr>
<tr>
<td>网上购物-商城-优惠</td>
<td>唯品会</td>
<td>2543</td>
<td>7090.1万</td>
<td>86.00%</td>
<td>41.43MB</td>
<td>2017年10月13日</td>
</tr>
<tr>
<td>网上购物-商城-优惠</td>
<td>唯品会</td>
<td>2543</td>
<td>7090.1万</td>
<td>86.00%</td>
<td>41.43MB</td>
<td>2017年10月13日</td>
</tr>
<tr>
<td>网上购物-商城</td>
<td>拼多多</td>
<td>1921</td>
<td>3841.9万</td>
<td>95.00%</td>
<td>13.35MB</td>
<td>2017年10月11日</td>
</tr>
<tr>
<td>网上购物-商城-优惠</td>
<td>寺库奢侈品</td>
<td>1964</td>
<td>175.4万</td>
<td>100.00%</td>
<td>17.21MB</td>
<td>2017年09月30日</td>
</tr>
<tr>
<td>网上购物-商城</td>
<td>淘宝</td>
<td>14244</td>
<td>4.6亿</td>
<td>68.00%</td>
<td>73.78MB</td>
<td>2017年10月13日</td>
</tr>
<tr>
<td>网上购物-商城-团购-优惠</td>
<td>当当</td>
<td>134</td>
<td>1615.3万</td>
<td>61.00%</td>
<td>37.01MB</td>
<td>2017年10月17日</td>
</tr>
<tr>
<td>网上购物-商城-团购-优惠</td>
<td>当当</td>
<td>134</td>
<td>1615.3万</td>
<td>61.00%</td>
<td>37.01MB</td>
<td>2017年10月17日</td>
</tr>
<tr>
<td>网上购物-商城-团购-优惠</td>
<td>当当</td>
<td>134</td>
<td>1615.3万</td>
<td>61.00%</td>
<td>37.01MB</td>
<td>2017年10月17日</td>
</tr>
</tbody></table>
<p>这里很直观的看到有很多数据重复了。</p>
<p>方法：检查上述的数据集是否有重复，pandas中使用duplicated方法，该方法返回的是数据行每一行的检验结果，即每一行的返回一个bool值，使用drop_duplicates方法移除重复值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">a  = pd.read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例1.xlsx&#x27;</span>) <span class="comment">#读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;是否有重复观测：&#x27;</span>,<span class="built_in">any</span>(a.duplicated()))    <span class="comment"># 有重复的值，则输出True</span></span><br><span class="line">a.drop_duplicates(inplace=<span class="literal">True</span>)                <span class="comment"># inplace=True时，直接删除a中的重复数据</span></span><br><span class="line"></span><br><span class="line">f=pd.ExcelWriter(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例1_已删除重复.xlsx&#x27;</span>) <span class="comment"># 创建文件的对象</span></span><br><span class="line">a.to_excel(f)                                  <span class="comment"># 把a已筛选的数据写入Excel中</span></span><br><span class="line">f.save()                                       <span class="comment">#保存文件，数据才真正写入excel文件,查看所保存的路径下的文件夹，已有excel新文件</span></span><br></pre></td></tr></table></figure>



<h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>Pandas使用浮点值NaN表示浮点或浮点数组中的缺失数据，Python内置的None值也会被当作缺失值处理. Pandas使用方法isnull 检测是否为缺失值，检测对象的每个元素返回一个bool值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检测是否有缺失值</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> NaN</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data=pd.Series([<span class="number">10.0</span>,<span class="literal">None</span>,NaN,<span class="number">30</span>])</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(data.isnull())        <span class="comment"># 输出每个元素的检测结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;是否存在缺失值：&#x27;</span>,<span class="built_in">any</span>(data.isnull()))    <span class="comment"># 输出True</span></span><br></pre></td></tr></table></figure>

<h4 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h4><h5 id="过滤法、删除法"><a href="#过滤法、删除法" class="headerlink" title="过滤法、删除法"></a>过滤法、删除法</h5><ul>
<li>dropna方法，适用于缺失值的观测对象所占比例非常低（如5%以内），直接删除缺失值所在的观测对象。因为对结果影响不大</li>
</ul>
<h5 id="填充法、替换法"><a href="#填充法、替换法" class="headerlink" title="填充法、替换法"></a>填充法、替换法</h5><ul>
<li>用某种常数值替换缺失值，使用fillna方法。例如对连续变量而言，用中位数或均值；对于离散变量，使用众数替换。</li>
</ul>
<h5 id="插值法"><a href="#插值法" class="headerlink" title="插值法"></a>插值法</h5><ul>
<li>根据其他非缺失的变量或观测来预测缺失值，常见有线性插值法、K近邻插值法、Lagrange插值法等</li>
</ul>
<h4 id="对Excel文件数据进行数据-删除-过滤"><a href="#对Excel文件数据进行数据-删除-过滤" class="headerlink" title="对Excel文件数据进行数据(删除)过滤"></a>对Excel文件数据进行数据(删除)过滤</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_excel</span><br><span class="line">a = read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例3.xlsx&#x27;</span>)</span><br><span class="line">b1 = a.dropna()     <span class="comment">#删除所有的缺失值,整行数据都删除</span></span><br><span class="line">b2 = a.dropna(axis=<span class="number">1</span>,thresh=<span class="number">9</span>)</span><br><span class="line"><span class="comment"># 删除一列的数据，这里的thresh就是数据集的个数为多少个，axis=0为行</span></span><br><span class="line">b3 = a.drop(<span class="string">&#x27;用户B&#x27;</span>,axis=<span class="number">1</span>) <span class="comment"># 删除用户B的数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;过滤后的数据：\n&#x27;</span>,b1,<span class="string">&#x27;\n-------------------\n&#x27;</span>,b2,<span class="string">&#x27;\n----------------\n&#x27;</span>,b3)</span><br></pre></td></tr></table></figure>

<h4 id="对excel表中的确实值进行数据填充"><a href="#对excel表中的确实值进行数据填充" class="headerlink" title="对excel表中的确实值进行数据填充"></a>对excel表中的确实值进行数据填充</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_excel</span><br><span class="line">a = read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例4.xlsx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a,<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用0补齐所有的值</span></span><br><span class="line">b1 = a.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用0填补:\n&#x27;</span>,b1,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用前一行的有的值补齐这一行缺失的值</span></span><br><span class="line">b2 = a.fillna(method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用前一行的值填补\n&#x27;</span>,b2,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用后一行向前一行缺失的值补齐</span></span><br><span class="line">b3 = a.fillna(method=<span class="string">&#x27;bfill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用后一行向前一行缺失的值补齐&#x27;</span>,b3,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line">b4=a.fillna(value=&#123;<span class="string">&#x27;gender&#x27;</span>:a.gender.mode()[<span class="number">0</span>],   <span class="comment"># 性别使用总数替换</span></span><br><span class="line">                   <span class="string">&#x27;age&#x27;</span>:a.age.mean(),            <span class="comment"># 年龄使用均值替换</span></span><br><span class="line">                   <span class="string">&#x27;income&#x27;</span>:a.income.median       <span class="comment"># 收入使用中位数替换</span></span><br><span class="line">                     &#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;分变量替换:\n&#x27;</span>,b4)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数值型缺失数据利用插值法进行替换"><a href="#数值型缺失数据利用插值法进行替换" class="headerlink" title="数值型缺失数据利用插值法进行替换"></a>数值型缺失数据利用插值法进行替换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_excel</span><br><span class="line"></span><br><span class="line">a = read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例4.xlsx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b=a.fillna(value=&#123;<span class="string">&#x27;gender&#x27;</span>:a.gender.mode()[<span class="number">0</span>],    <span class="comment"># 性别使用总数替换</span></span><br><span class="line">               <span class="string">&#x27;age&#x27;</span>:a.age.interpolate(method=<span class="string">&#x27;polynomial&#x27;</span>,order=<span class="number">2</span>),</span><br><span class="line">                                            <span class="comment"># 年龄使用二次多项式插值替换</span></span><br><span class="line">               <span class="string">&#x27;income&#x27;</span>:a.income.interpolate() <span class="comment"># 收入使用线性插值替换</span></span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h3><p>异常值的检测一般采用两种方法：<strong>标准差法</strong>、<strong>箱线图法</strong></p>
<p>太阳黑子个数文件<code>sunspots.csv</code>数据用Excel软件打开后的格式如<code>C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例6_sunspots.csv</code>，共有289条记录，识别并处理其中的异常值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">a  = read_csv(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例6_sunspots.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)                  <span class="comment"># 查看数据的多少，此处显示289个记录;2种数据</span></span><br><span class="line"></span><br><span class="line">mu = a.counts.mean()            <span class="comment"># 计算黑子个数counts的年平均数</span></span><br><span class="line"><span class="built_in">print</span>(mu)</span><br><span class="line">s  = a.counts.std()             <span class="comment"># 计算黑子个数标准差</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准差法异常值上限检测：&#x27;</span>,<span class="built_in">any</span>(a.counts&gt;mu+<span class="number">2</span>*s))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准差法异常值下限检测：&#x27;</span>,<span class="built_in">any</span>(a.counts&lt;mu+<span class="number">2</span>*s))</span><br><span class="line"></span><br><span class="line">Q1=a.counts.quantile(<span class="number">0.25</span>)      <span class="comment"># 计算下四分位数</span></span><br><span class="line"><span class="built_in">print</span>(Q1)</span><br><span class="line">Q3=a.counts.quantile(<span class="number">0.75</span>)      <span class="comment"># 计算上四分位数</span></span><br><span class="line"><span class="built_in">print</span>(Q3)</span><br><span class="line">IQR=Q3-Q1                       <span class="comment"># 计算四分位距</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;箱线法图异常值上限检测:&#x27;</span>,<span class="built_in">any</span>(a.counts&gt;Q3+<span class="number">1.5</span>*IQR))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;箱线法图异常值下限检测:&#x27;</span>,<span class="built_in">any</span>(a.counts&lt;Q1-<span class="number">1.5</span>*IQR))</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)         <span class="comment"># 设置绘线风格</span></span><br><span class="line">a.counts.plot(kind=<span class="string">&#x27;hist&#x27;</span>,bins=<span class="number">30</span>,density=<span class="literal">True</span>)</span><br><span class="line">a.counts.plot(kind=<span class="string">&#x27;kde&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;异常值替换前的数据统计特征:\n&#x27;</span>,a.counts.describe(),<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">UB = Q3+<span class="number">1.5</span>*IQR</span><br><span class="line">st=a.counts[a.counts&lt;UB].<span class="built_in">max</span>()   <span class="comment"># 找出低于判别上限的最大值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;判断异常值的上限临界值为：&#x27;</span>,UB)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用以替换异常值的数据为：&#x27;</span>,st)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;异常值的位置：\n&#x27;</span>,a.loc[a.counts&gt;UB,<span class="string">&#x27;counts&#x27;</span>])  <span class="comment"># 观察后可以注释掉</span></span><br><span class="line">a.loc[a.counts&gt;UB, <span class="string">&#x27;counts&#x27;</span>]=st  <span class="comment"># 替换超过判别上限异常值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;异常值替换后的数据统计特征为：\n&#x27;</span>,a.counts.describe(),<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">a.to_csv(<span class="string">&#x27;暑假打卡20_例6_sunspots_已数据清洗.csv&#x27;</span>)</span><br><span class="line"> <span class="comment">#将清洗后的数据存入新的文件，此处可自行修改为想保存的文件路径</span></span><br></pre></td></tr></table></figure>



<h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><p>如何利用现有资源来安排生产，以取得最大经济效益的问题。</p>
<p>例 1 某机床厂生产甲、 乙两种机床， 每台销售后的利润分别为 4000 元与 3000 元。生产甲机床需用 A、 B 机器加工，加工时间分别为每台 2 小时和 1 小时；生产乙机床需用 A、 B、 C 三种机器加工，加工时间为每台各一小时。若每天可用于加工的机器时数分别为 A 机器 10 小时、 B 机器 8 小时和C 机器 7 小时，问该厂应生产甲、乙机床各几台，才能使总利润最大？  </p>
<blockquote>
<p><strong>数学模型</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>4000</td>
<td>甲</td>
<td>2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>3000</td>
<td>乙</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td></td>
<td>10</td>
<td>8</td>
<td>7</td>
</tr>
</tbody></table>
<p>设甲机床有x<sub>1</sub>个，乙机床有x<sub>2</sub>个        						（0）x<sub>1</sub>, x<sub>2</sub> 称之为决策变量  </p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>目标函数  max   z &#x3D; 4 x<sub>1</sub> + 3x<sub>2</sub>     			（1）目标函数 </p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>约束条件：                                              			（2）约束条件  		</p>
<blockquote>
<p>2 x<sub>1</sub> + x<sub>2</sub> &amp;le; 10</p>
<p>x<sub>1</sub> + x<sub>2</sub> &amp;le; 8</p>
<p>x<sub>2</sub>  &amp;le; 7</p>
<p>x<sub>1</sub>,x<sub>2</sub> ≥ 0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Matlab 中规定线性规划的标准形式为<br>$$<br>\min_{x} c^T x<br>$$</p>
<p>$$<br>s.t.\begin{cases} Ax\le b \ Aeq \cdot x &#x3D; beq \lb \le x\le ub\end{cases}<br>$$</p>
<p>其中 c 和 x 为 n 维列向量， A 、 Aeq 为适当维数的矩阵， b 、 beq 为适当维数的列向量。  </p>
<p>线性规划中<br>$$<br>\min_{x} c^T x  \qquad s.t.  \quad Ax \le b<br>$$<br>的Matlab标准型为<br>$$<br>\min_{x} -c^T x  \qquad s.t.  \quad -Ax \le -b<br>$$</p>
<p><strong>可行解</strong>：满足目标  s.t.      <em><strong>最优解</strong></em>：满足可行解的情况下，更加接近目标函数     <strong>可行域</strong>：满足所用的可行解</p>
<p>注：跟高中所学的线性规划的题目相似。平移z函数</p>
<p>（2，6）点处，可能为非空点（无最优解），或者是实数点（有最优解）。</p>
<hr>
<p><em><strong>特别解释及定义：</strong></em></p>
<p>多维空间中：R不再是二维平面了。我们成多维空间形成的可行域为多胞形。二维平面中最优点一般是顶点，多胞体我们称最优点为一下概念：</p>
<p>**定义一：称 n 维空间中的区域 R 为一凸集，若   ∀x<sub>1</sub>, x<sub>2</sub> &amp;isin; R 及 ∀&amp;lambda; ∈(0,1) ，有   &amp;lambda;x<sub>1</sub> + (1- &amp;lambda;)x<sub>2</sub> ∈R   **</p>
<p>**定义二:  设 R 为 n 维空间中的一个凸集， R 中的点 x 被称为 R 的一个极点，若不存在 x<sub>1</sub>、 x<sub>2</sub> ∈ R 及λ ∈(0,1) ,使得 x &#x3D; &amp;lambda;x<sub>1</sub> + (1- &amp;lambda;)x<sub>2</sub>  **</p>
<p>解释：</p>
<p>[1].  定义1 说明凸集中<em><strong>任意两点的连线必在此凸集中</strong></em>；  </p>
<p>[2]. 定义 2 说明，若 x 是凸集 R的一个<strong>极点</strong>，则 <em><strong>x 不能位于 R 中任意两点的连线上</strong></em>。  </p>
<hr>
<h3 id="一：单纯形法-—遍历法"><a href="#一：单纯形法-—遍历法" class="headerlink" title="一：单纯形法  —遍历法"></a>一：单纯形法  —遍历法</h3><p>一般<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1661606">线性规划</a>问题中当线性方程组的变量数大于方程个数，这时会有不定数量的解，而单纯形法是求解线性规划问题的通用方法。</p>
<p><strong>具体步骤</strong>，从线性方程组找出一个个的单纯形，每一个单纯形可以求得一组解，然后再判断该解使目标函数值是增大还是变小了，决定下一步选择的单纯形。通过优化迭代，直到目标函数实现最大或最小值。</p>
<p>等我稍加学习后，在拿出来更新分享。</p>
<h3 id="二：Matlab解法"><a href="#二：Matlab解法" class="headerlink" title="二：Matlab解法"></a>二：Matlab解法</h3><p><em><strong>重点：</strong></em></p>
<p>Matlab 中规定线性规划的标准形式为<br>$$<br>\min_{x} c^T x<br>$$</p>
<p>$$<br>s.t.\begin{cases} Ax\le b \ Aeq \cdot x &#x3D; beq \lb \le x\le ub\end{cases}<br>$$</p>
<p>其中 c 和 x 为 n 维列向量， A 、 Aeq 为适当维数的矩阵， b 、 beq 为适当维数的列向量。  </p>
<p>**[x,fval]&#x3D;linprog(c,A,b,Aeq,beq,LB,UB,X0,OPTIONS)  **</p>
<p>LB 和 UB 分别是变量 x 的下界和上界    		x0 是 x 的初始值       	OPTIONS 是控制参数  </p>
<p> c 和 x 为 n 维列向量           A 、 Aeq 为适当维数的矩阵			 b 、 beq 为适当维数的列向量。 </p>
<p>$$<br>\min_{z} &#x3D; 2x_1+3x_2-5x_3<br>\s.t.\begin{cases}<br>            x_1+x_2+x_3&#x3D;7\2x_1-5x_2+x_3 \ge 12 \x_1,x_2,x_3 \ge 0<br>        \end{cases}<br>$$<br>Matlab编写：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">c = [<span class="number">2</span>;<span class="number">3</span>;<span class="number">-5</span>];</span><br><span class="line">a = [<span class="number">-2</span>,<span class="number">5</span>,<span class="number">-1</span>;<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">b = [<span class="number">-10</span>,<span class="number">12</span>];</span><br><span class="line">aeq = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">beq = <span class="number">7</span>;</span><br><span class="line">x = linprog(-c,a,b,aeq,beq,<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">value = c&#x27;*x</span><br></pre></td></tr></table></figure>



<h3 id="三、python求解"><a href="#三、python求解" class="headerlink" title="三、python求解"></a>三、python求解</h3><h5 id="scipy-optimize模块求解"><a href="#scipy-optimize模块求解" class="headerlink" title="scipy.optimize模块求解"></a>scipy.optimize模块求解</h5><p>scipy.optimize提供了一个线性求解线性规划的函数linprog</p>
<p>scipy中线性规划的标准形为：<br>$$<br>\min_{x}z&#x3D; c^T x			\<br>s.t.\begin{cases} Ax\le b, 	\<br>Aeq \cdot x &#x3D; beq, 			\<br>Lb \le x\le Ub\end{cases}<br>$$<br>lingrop的基本调用格式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"><span class="comment">### 注：这里的c,A,b,Aeq,beq都要求出来才行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认每个决策变量下界为0，上界为无穷大</span></span><br><span class="line">res=linprog(c, A, b, Aeq, beq) </span><br><span class="line">res=linprog(c,A=<span class="literal">None</span>,b=<span class="literal">None</span>,Aeq=<span class="literal">None</span>,beq=<span class="literal">None</span>,</span><br><span class="line">            bounds=<span class="literal">None</span>,method=’simplex’)</span><br><span class="line"><span class="built_in">print</span>(res.fun)		<span class="comment"># 显示目标函数最小值</span></span><br><span class="line"><span class="built_in">print</span>(res.x)		<span class="comment"># 显示最优解</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>c 和 x 为 n 维列向量，c 对应目标函数的系数变量</p>
</li>
<li><p>A  为适当维数的矩阵， b为适当维数的列向量；A,b分别对应<strong>不等式约束</strong>的系数向量和常数项</p>
</li>
<li><p>Aeq 为适当维数的矩阵，beq 为适当维数的列向量；Aeq，beq分别对应<strong>等式约束</strong>的系数向量和常数项</p>
</li>
</ul>
<h6 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h6><hr>
<p>$$<br>\min_{x}z&#x3D; -x_1+4x_2		\<br>s.t.<br>\begin{cases}<br>-3x_1+\ \ x_2\leqslant\ \ \ \  6\<br>\ \ \ \ \ x_1+2x_2 \leqslant\ \ \ \  4 \<br> \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ x_2  \geqslant  -3<br>\end{cases}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c=[-<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">A=[[-<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">b=[<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">bounds=((<span class="literal">None</span>,<span class="literal">None</span>),(-<span class="number">3</span>,<span class="literal">None</span>))</span><br><span class="line"><span class="comment">#      x1的取值无穷  x2的取值&gt;=2</span></span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解：&#x27;</span>,res.x)</span><br></pre></td></tr></table></figure>

<p>目标函数的最小值： -21.99999984082497<br>最优解： [ 9.99999989 -2.99999999]</p>
<p>所以最优解为$x_1&#x3D;10,x_2&#x3D;-3$,目标 函数的最优值为 -22.</p>
<hr>
<p>$$<br>\min z&#x3D; x_1-2x_2-3x_3		\<br>s.t.<br>\begin{cases}<br>-2x_1+x_2+\ \  x_3\leqslant \ \ \ 9\<br>-3x_1+x_2+2x_3 \geqslant \ \ \ 4 \<br>\ \ \ 4x_1-2x_2-x_3 &#x3D;  -6 \<br>x_1\geqslant -10, x_2\geqslant 0,x_3取值无约束<br>\end{cases}<br>$$</p>
<p>化成标准型：<br>$$<br>\min w&#x3D; -x_1+2x_2+3x_3		\<br>s.t.<br>\begin{cases}<br>-2x_1+x_2+\ \  x_3\leqslant \ \ \ 9\<br>\ \ \ 3x_1-x_2-2x_3 \leqslant  -4 \<br>\ \ \ 4x_1-2x_2-x_3 &#x3D;  -6 \<br>x_1\geqslant -10, x_2\geqslant 0,x_3取值无约束<br>\end{cases}<br>$$<br>也就是说将所有都化为$ax_1+bx_2\leqslant c$的形式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c=[-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">A=[[-<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">2</span>]]</span><br><span class="line">b=[<span class="number">9</span>,-<span class="number">4</span>]</span><br><span class="line">Aeq=[[<span class="number">4</span>,-<span class="number">2</span>,-<span class="number">1</span>]]</span><br><span class="line">beq=[-<span class="number">6</span>]</span><br><span class="line">LB=[-<span class="number">10</span>,<span class="number">0</span>,<span class="literal">None</span>]</span><br><span class="line">UB=[<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>]</span><br><span class="line"><span class="comment">#bounds=((-10,None,),(0,None),(None,None))</span></span><br><span class="line">bounds=<span class="built_in">tuple</span>(<span class="built_in">zip</span>(LB,UB))</span><br><span class="line">res=linprog(c,A,b,Aeq,beq,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解：&#x27;</span>,res.x)</span><br><span class="line"></span><br><span class="line"><span class="comment">################ or #####################</span></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c=[-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">A=[[-<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">2</span>]]</span><br><span class="line">b=[<span class="number">9</span>,-<span class="number">4</span>]</span><br><span class="line">Aeq=[[<span class="number">4</span>,-<span class="number">2</span>,-<span class="number">1</span>]]</span><br><span class="line">beq=[-<span class="number">6</span>]</span><br><span class="line">bounds=((-<span class="number">10</span>,<span class="literal">None</span>,),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="literal">None</span>,<span class="literal">None</span>))</span><br><span class="line">res=linprog(c,A,b,Aeq,beq,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解：&#x27;</span>,res.x)</span><br></pre></td></tr></table></figure>

<p>即所求问题的最优解为</p>
<p>目标函数的最小值： 0.4000000006525579<br>最优解： [-1.60000000e+00  8.29738643e-11 -4.00000000e-01]</p>
<p>（注意x2的解为8.29674988x10<sup>-11</sup> ，写成解的时候保留一位小数就是0.0，即0)</p>
<hr>
<p>例题：</p>
<p>加工一种食用油需要精炼若干种原料油并把它们混合起来、原料油的来源有两类共5种：植物油VEG1、植物油VEG2、非植物油OIL1、非植物油OIL2、非植物油OIL3. 购买每种原料油的价格（英镑&#x2F;吨）如下表1，最终产品以<em><strong>150英镑&#x2F;吨的价格出售</strong></em>. 植物油和非植物油需要在<strong>不同的生成线</strong>上进行精炼. <strong>每月能够精炼的植物油不超过200吨，非植物油不超过250吨</strong>；在精炼过程中，重量没有损失，精炼费用可忽略不计. 最终产品要符合硬度的技术条件. 按照硬度计量单位，它必须为<strong>3~6</strong>. 假定<strong>硬度的混合是线性</strong>的，而原材料的硬度如表2所示.</p>
<p>求：为使利润最大，应该怎样指定它的月采购和加工计划</p>
<center>表一  原料油价格</center>

<table>
<thead>
<tr>
<th>原料油</th>
<th>VEG1</th>
<th>VEG2</th>
<th>OIL1</th>
<th>OIL2</th>
<th>OIL3</th>
</tr>
</thead>
<tbody><tr>
<td>价格</td>
<td>110</td>
<td>120</td>
<td>130</td>
<td>110</td>
<td>115</td>
</tr>
</tbody></table>
<center>表2 原料油硬度表</center>

<table>
<thead>
<tr>
<th>原料油</th>
<th>VEG1</th>
<th>VEG2</th>
<th>OIL1</th>
<th>OIL2</th>
<th>OIL3</th>
</tr>
</thead>
<tbody><tr>
<td>硬度值</td>
<td>8.8</td>
<td>6.1</td>
<td>2.0</td>
<td>4.2</td>
<td>5.0</td>
</tr>
</tbody></table>
<p>解：设$x_1,x_2,…,x_5$分别对应了5种原料油吨数，$x_6$为每月加工的成品油吨数</p>
<ol>
<li><p>目标函数是要让净利润达到最大：即<br>$$<br>z&#x3D;-100x_1-120x_2-130x_3-110x_4-115x_5+150x_6<br>$$</p>
</li>
<li><p>约束条件为以下四类：</p>
<p>i.精炼能力的限制</p>
<p>​	植物油精炼能力的限制：$x_1+x_2\leqslant 200$</p>
<p>​	非植物油精炼能力的限制：$x_3+x_4+x_5\leqslant 250$ </p>
<p>ii.硬度的限制</p>
<p>​	硬度上限：$8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\leqslant 6x_6$</p>
<p>​	硬度下限：$8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\geqslant3x_6$</p>
<p>iii.守恒性质限制（重量没有损失）</p>
<p>​	$x_1+x_1+x_3+x_4+x_5&#x3D;x_6$</p>
<p>iiii.非负性限制</p>
<p>​	$x_i\geqslant0,i&#x3D;0,1,…,6$</p>
</li>
</ol>
<p>所以建立如下的线性规划<br>$$<br>max\ z&#x3D;-100x_1-120x_2-130x_3-110x_4-115x_5+150x_6\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 200\<br>x_3+x_4+x_5\leqslant 250\<br>8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\leqslant 6x_6\<br>8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\geqslant3x_6\<br>x_1+x_1+x_3+x_4+x_5&#x3D;x_6\<br>x_i\geqslant0,i&#x3D;0,1,…,6 .<br>\end{cases}<br>$$<br>要先转变成标准型即：<br>$$<br>这种函数\<br>\min_{x}z&#x3D; c^T x			\<br>s.t.\begin{cases} Ax\le b, 	\<br>Aeq \cdot x &#x3D; beq, 			\<br>Lb \le x\le Ub\end{cases}<br>$$<br>所以得到为：<br>$$<br>max\ z&#x3D;-100x_1-120x_2-130x_3-110x_4-115x_5+150x_6\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 200\<br>x_3+x_4+x_5\leqslant 250\<br>8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5-6x_6\leqslant 0\<br>-8.8x_1-6.1x_1-2.0x_3-4.2x_4-5.0x_5+3x_6\leqslant0\<br>x_1+x_1+x_3+x_4+x_5-x_6&#x3D;0\<br>x_i\geqslant0,i&#x3D;0,1,…,6 .<br>\end{cases}<br>$$<br>程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">100</span>,-<span class="number">120</span>,-<span class="number">130</span>,-<span class="number">110</span>,-<span class="number">115</span>,<span class="number">150</span>]</span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">8.8</span>,<span class="number">6.1</span>,<span class="number">2.0</span>,<span class="number">4.2</span>,<span class="number">5.0</span>,-<span class="number">6.0</span>],[-<span class="number">8.8</span>,-<span class="number">6.1</span>,-<span class="number">2.0</span>,-<span class="number">4.2</span>,-<span class="number">5.0</span>,<span class="number">3.0</span>]]</span><br><span class="line"><span class="comment">#b=[200,250,0,0]</span></span><br><span class="line">b=[[<span class="number">200</span>],[<span class="number">250</span>],[<span class="number">0</span>],[<span class="number">0</span>]]</span><br><span class="line">Aeq=[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>]]</span><br><span class="line">beq=[<span class="number">0</span>]</span><br><span class="line">bounds=((<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line">res=linprog(c,A,b,Aeq,beq,bounds)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：&#x27;</span>,res.x)</span><br></pre></td></tr></table></figure>

<p>目标函数的最小值： -4.1769028848418895e-13<br>最优解为： [1.16766018e-16 2.24124639e-15 3.48701448e-16 1.33739624e-15<br> 2.13371900e-15 2.00505560e-15]</p>
<hr>
<p>已知某种商品6个仓库的存活量，8个客户对该商品的需求量，单位商品运价如下表3所示. 试确定6个仓库到8个客户的商品调运数量，使总的运输费用最小.</p>
<table>
<thead>
<tr>
<th>仓库W|单价运价右下\客户V</th>
<th>V1</th>
<th>V2</th>
<th>V3</th>
<th>V4</th>
<th>V5</th>
<th>V6</th>
<th>V7</th>
<th>V8</th>
<th>存货量</th>
</tr>
</thead>
<tbody><tr>
<td>$W_1$</td>
<td>6</td>
<td>2</td>
<td>6</td>
<td>7</td>
<td>4</td>
<td>2</td>
<td>5</td>
<td>9</td>
<td>60</td>
</tr>
<tr>
<td>$W_2$</td>
<td>4</td>
<td>9</td>
<td>5</td>
<td>3</td>
<td>8</td>
<td>5</td>
<td>8</td>
<td>2</td>
<td>55</td>
</tr>
<tr>
<td>$W_3$</td>
<td>5</td>
<td>2</td>
<td>1</td>
<td>9</td>
<td>7</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>51</td>
</tr>
<tr>
<td>$W_4$</td>
<td>7</td>
<td>6</td>
<td>7</td>
<td>3</td>
<td>9</td>
<td>2</td>
<td>7</td>
<td>1</td>
<td>43</td>
</tr>
<tr>
<td>$W_5$</td>
<td>2</td>
<td>3</td>
<td>9</td>
<td>5</td>
<td>7</td>
<td>2</td>
<td>6</td>
<td>5</td>
<td>41</td>
</tr>
<tr>
<td>$W_6$</td>
<td>5</td>
<td>5</td>
<td>2</td>
<td>2</td>
<td>8</td>
<td>1</td>
<td>4</td>
<td>3</td>
<td>52</td>
</tr>
<tr>
<td>需求量</td>
<td>35</td>
<td>37</td>
<td>22</td>
<td>32</td>
<td>41</td>
<td>32</td>
<td>43</td>
<td>38</td>
<td></td>
</tr>
</tbody></table>
<p>解：设</p>
<p>$x_{ij}(i&#x3D;1,2,…,6;j&#x3D;1,2,…,8)$表示第i个仓库到第j个客户的商品数量，</p>
<p>$c_{ij}(i&#x3D;1,2,…,6;j&#x3D;1,2,…,8)$表示第i个仓库运到第j个客户的单位运价，</p>
<p>$d_{j}$表示第j个客户的需求量</p>
<p>$e_i$表示第i个仓库的库存量</p>
<p>建立线性规划模型：<br>$$<br>min \sum_{i&#x3D;1}^{6}\sum_{j&#x3D;1}^{8}c_{ij}x_{ij},\<br>s.t.<br>\begin{cases}<br>\sum_{j&#x3D;1}^{8}x_{ij}\leqslant e_i,i&#x3D;1,2,…,6\<br>\sum_{i&#x3D;1}^{6}x_{ij}\leqslant d_j,j&#x3D;1,2,…,6\<br>x_{ij}\geqslant0,i&#x3D;1,2,…,6;j&#x3D;1,2,…,8. \<br>\end{cases}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">import cvxpy as cp</span></span><br><span class="line"><span class="string">import numpy as np</span></span><br><span class="line"><span class="string">import pandas as pd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d1=pd.read_excel(r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡21_例4.xlsx&#x27;,header=None)</span></span><br><span class="line"><span class="string"># 这里的header=None是告诉程序没有表头，不然会导致得到的结果的第一行被当作表头使用了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d2=d1.values    # 将值转变为数组</span></span><br><span class="line"><span class="string">c=d2[:-1,:-1]    #读取d2中除最后一行一列的数据</span></span><br><span class="line"><span class="string">e=d2[:-1,-1].reshape(-1,1)#数据表中的最后一列（不包括该列的最后一个元素）,reshape(-1,1)表示生成1列</span></span><br><span class="line"><span class="string">d=d2[-1,:-1].reshape(1,-1)#数据表中的最后一行（不包括该行的最后一个元素），reshape（1，-1）表示生成1行</span></span><br><span class="line"><span class="string">x=cp.Variable((6,8))      #用凸优化的cvxpy库</span></span><br><span class="line"><span class="string">obj=cp.Minimize(cp.sum(cp.multiply(c,x)))   #构造目标函数  即将数据带入x6*8矩阵</span></span><br><span class="line"><span class="string">con=[cp.sum(x,axis=1,keepdims=True)&lt;=e,     #构造约束条件1，axis=1表示按行计算</span></span><br><span class="line"><span class="string">     cp.sum(x,axis=0,keepdims=True)==d,     #构造约束条件2，axis=0表示按列计算</span></span><br><span class="line"><span class="string">     x&gt;=0]</span></span><br><span class="line"><span class="string">prob=cp.Problem(obj,con)    # 构造模型</span></span><br><span class="line"><span class="string">prob.solve(solver=&#x27;SCS&#x27;,verbose=True) #求解模型</span></span><br><span class="line"><span class="string">print(&#x27;最优值为：&#x27;,prob.value)</span></span><br><span class="line"><span class="string">print(&#x27;最优解为：&#x27;,x.value)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d1=pd.read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡21_例4.xlsx&#x27;</span>,header=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#如果excel的数据没有表头的变量，则用header=None后会分配索引，否则会吃掉第一行</span></span><br><span class="line"><span class="comment">#print(d1)</span></span><br><span class="line"></span><br><span class="line">d2=d1.values</span><br><span class="line"><span class="comment">#print(&#x27;d2=:\n&#x27;,d2)</span></span><br><span class="line">c=d2[:-<span class="number">1</span>,:-<span class="number">1</span>] <span class="comment">#读取d2中除最后一行一列的数据</span></span><br><span class="line"><span class="comment">#print(&#x27;c= \n&#x27;,c)</span></span><br><span class="line"></span><br><span class="line">e=d2[:-<span class="number">1</span>,-<span class="number">1</span>].reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"> <span class="comment">#数据表中的最后一列（不包括该列的最后一个元素）,reshape(-1,1)表示生成1列</span></span><br><span class="line">d=d2[-<span class="number">1</span>,:-<span class="number">1</span>].reshape(<span class="number">1</span>,-<span class="number">1</span>) </span><br><span class="line"> <span class="comment">#数据表中的最后一行（不包括该行的最后一个元素），reshape（1，-1）表示生成1行</span></span><br><span class="line"></span><br><span class="line">x=cp.Variable((<span class="number">6</span>,<span class="number">8</span>))</span><br><span class="line">obj=cp.Minimize(cp.<span class="built_in">sum</span>(cp.multiply(c,x))) <span class="comment">#构造目标函数</span></span><br><span class="line"></span><br><span class="line">con=[cp.<span class="built_in">sum</span>(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)&lt;=e,  <span class="comment">#构造约束条件，axis=1表示按行计算</span></span><br><span class="line">    cp.<span class="built_in">sum</span>(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)==d,   <span class="comment">#axis=0表示按列计算</span></span><br><span class="line">     x&gt;=<span class="number">0</span>]</span><br><span class="line">prob=cp.Problem(obj,con) <span class="comment"># 构造模型</span></span><br><span class="line">prob.solve(solver=<span class="string">&#x27;SCS&#x27;</span>,verbose=<span class="literal">True</span>) <span class="comment">#求解模型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优值为：&#x27;</span>,prob.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：&#x27;</span>,x.value)</span><br><span class="line"></span><br><span class="line"><span class="comment">######################这里我出错了，可能没有scs库#######################</span></span><br></pre></td></tr></table></figure>



<h2 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h2><p>灵敏度分析是指对系统因周围条件变化显示出来的敏感程度的分析.</p>
<p>在上一个例题中，都设定了$c_{ij},d_j,e_i$等为常数，但实际问题中，这些系数往往是估计值，或者预测值，经常有少许的变动。</p>
<p>所以提出几点问题</p>
<ul>
<li>如果参数$c_{ij},d_j,e_i$中的一个或几个发生变化，现行最优方案会有什么变化？</li>
<li>将这些参数的变化限制在什么范围下，原最优解任然是最优解？</li>
</ul>
<p>实际上，给定参数量一个步长使其重复求解线性规划问题，以观察最优解的变化情况，这是一个可用的数值方法，特别是计算机求解时。</p>
<h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><p>一家奶制品加工厂用牛奶生成A、B两种奶制品，1桶牛奶可以在<strong>甲类</strong>设备上用<strong>12 h</strong>加工成<strong>3kg A</strong>，或者在<strong>乙类</strong>设备上用<strong>8h <strong>加工成</strong>4kg B.</strong> 假定根据市场需求，生成的A，B全部能售出，且<strong>每千克A 获利24元</strong>，<strong>每千克B 获利16 元</strong>. 现在加工厂<strong>每天能得到50 桶牛奶</strong>的供应，<strong>每天正式工人总的劳动时间为480 h</strong>，并且<strong>甲类设备每天至多能加工100kg A</strong>，<strong>乙类设备的加工能力没有限制</strong>. 试为该厂指定一个生产计划，使每天<strong>获利最大</strong>，并进一步讨论以下两个附加问题：</p>
<p>(1)  若可以聘用临时工人以增加劳动时间，是否聘用临时工人.</p>
<p>(2)  假设由于市场需求变化，每千克A 的获利增加到30元，是否改变生成计划.</p>
<p>解：设$x_1$桶牛奶生成A，$x_2$桶牛奶生成B，每天获利z元</p>
<p>建立方程有：<br>$$<br>min\ z&#x3D;3<em>24x_1+4</em>16x_2&#x3D;72x_1+64x_2\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 50\<br>12x_1+8x_2\leqslant 480\<br>3x_1\leqslant 100\<br>x_1&gt;0,x_2&gt;0<br>\end{cases}<br>$$<br>求解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##我的</span></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">72</span>,-<span class="number">64</span>]<span class="comment">#注意此处是目标系数的相反数</span></span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">12</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">0</span>]]</span><br><span class="line">b=[[<span class="number">50</span>],[<span class="number">480</span>],[<span class="number">100</span>]]</span><br><span class="line">bounds=((<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;求解结果为：\n&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(res.x)</span><br><span class="line"></span><br><span class="line"><span class="comment">##老师的</span></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">72</span>,-<span class="number">64</span>] <span class="comment">#注意此处是目标系数的相反数</span></span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">12</span>,<span class="number">8</span>]]</span><br><span class="line">b=[[<span class="number">50</span>],[<span class="number">480</span>]]</span><br><span class="line">bound=((<span class="number">0</span>,<span class="number">100</span>/<span class="number">3.0</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bound,method=<span class="string">&#x27;simplex&#x27;</span>,options=&#123;<span class="string">&#x27;disp&#x27;</span>:<span class="literal">True</span>&#125;) <span class="comment">#simplex表示单纯形法，</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;求解结果为：\n&#x27;</span>,res)</span><br></pre></td></tr></table></figure>

<p>为什么c&#x3D;[-72,-64]呢？</p>
<ul>
<li>是因为本来这个函数求解的就是最小值，那么要求解最小值的话，变为负数就成为了最大值，但是符号相反。</li>
</ul>
<p>所以最优解为：$x_1&#x3D;20;x_2&#x3D;30$，收益最大化为3360元。</p>
<p>松弛问题slack</p>
<ul>
<li>经过求解可知（slack的两个分量都是0），两个约束条件都是“紧约束”，即最优解是不等式的约束条件达到了边界，约束条件此时实际上是等式约束，（1）所以增加劳动时间，会提高收益，因而附加问题（1）应该聘用临时工人.</li>
</ul>
<p>问题二：</p>
<p>当每千克A 的获利增加到30元<br>$$<br>min\ z&#x3D;3<em>30x_1+4</em>16x_2&#x3D;90x_1+64x_2\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 50\<br>12x_1+8x_2\leqslant 480\<br>3x_1\leqslant 100\<br>x_1&gt;0,x_2&gt;0<br>\end{cases}<br>$$<br>方程几乎不变，只是改变了最优函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">90</span>,-<span class="number">64</span>] <span class="comment">#注意此处是目标系数的相反数</span></span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">12</span>,<span class="number">8</span>]]</span><br><span class="line">b=[[<span class="number">50</span>],[<span class="number">480</span>]]</span><br><span class="line">bound=((<span class="number">0</span>,<span class="number">100</span>/<span class="number">3.0</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bound,method=<span class="string">&#x27;simplex&#x27;</span>,options=&#123;<span class="string">&#x27;disp&#x27;</span>:<span class="literal">True</span>&#125;) <span class="comment">#simplex表示单纯形法，</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;求解结果为：\n&#x27;</span>,res)</span><br></pre></td></tr></table></figure>

<p>最优解不变，但是获得的价为3720.0。所以生产计划不变。</p>
<h2 id="整数规划与非线性规划"><a href="#整数规划与非线性规划" class="headerlink" title="整数规划与非线性规划"></a>整数规划与非线性规划</h2><h3 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h3><p>线性规划的变量是连续型的，但如果变量是离散的非负整数值才有意义，就是整数线性规划，简称整数规划（问题依旧不变，但是物品类似不可分，导致得到的解只有整数解）</p>
<p>求解下列整数线性规划问题<br>$$<br>min\ z&#x3D;40x_1+90x_2\<br>s.t.<br>\begin{cases}<br>9x_1+7x_2\leqslant 56\<br>-7x_1+-20x_2\leqslant -70\<br>x_1&gt;0,x_2&gt;0且为整数<br>\end{cases}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">c=np.array([<span class="number">40</span>,<span class="number">90</span>])</span><br><span class="line">A=np.array([[<span class="number">9</span>,<span class="number">7</span>],[-<span class="number">7</span>,-<span class="number">20</span>]])</span><br><span class="line">b=np.array([<span class="number">56</span>,-<span class="number">70</span>])</span><br><span class="line">x=cp.Variable(<span class="number">2</span>,integer=<span class="literal">True</span>)  <span class="comment">#定义两个整数决策变量</span></span><br><span class="line"></span><br><span class="line">obj=cp.Minimize(c@x)           <span class="comment">#构造函数</span></span><br><span class="line">cons=[A@x&lt;=b,x&gt;=<span class="number">0</span>]             <span class="comment">#构造约束条件，此处 @表示矩阵与矩阵的乘法</span></span><br><span class="line">prob=cp.Problem(obj,cons)      <span class="comment">#构建问题模型</span></span><br><span class="line">prob.solve(solve=<span class="string">&#x27;GLPK_MI&#x27;</span>,verbose=<span class="literal">True</span>) <span class="comment">#求解问题，GLPK_MI表示单纯性法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优值为：\n&#x27;</span>,prob.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：\n&#x27;</span>,x.value)</span><br></pre></td></tr></table></figure>

<p>最优值为： 350.0                      最优解为： [2. 3.]</p>
<h3 id="指派问题及求解"><a href="#指派问题及求解" class="headerlink" title="指派问题及求解"></a>指派问题及求解</h3><h4 id="标准指派模型"><a href="#标准指派模型" class="headerlink" title="标准指派模型"></a>标准指派模型</h4><p>标准指派问题的数学模型表现为0-1整数规划的形式，当然可以通过整数规划的算法求最优解，但是标准指派问题的数学具有独特的结构，可采用著名的<strong>匈牙利算法</strong>求标准指派问题的最优解。</p>
<hr>
<p>某商业公司计划开办5家新商店，决定由5家建筑公司分别承建. 已知建筑公司$A_i(i&#x3D;1,..,5)$,对新商店$B_j(j&#x3D;1,..,5)$的建造费用的报价（万元）为$c_{ij}(i,j&#x3D;1,..,5)$,如下。为了节省费用，商业公司应当对5家建筑公司怎样分配建造任务，才能使总的建造费最少？</p>
<table>
<thead>
<tr>
<th></th>
<th>$B_1$</th>
<th>$B_2$</th>
<th>$B_3$</th>
<th>$B_4$</th>
<th>$B_5$</th>
</tr>
</thead>
<tbody><tr>
<td>$A_1$</td>
<td>4</td>
<td>8</td>
<td>7</td>
<td>15</td>
<td>12</td>
</tr>
<tr>
<td>$A_2$</td>
<td>7</td>
<td>9</td>
<td>17</td>
<td>14</td>
<td>10</td>
</tr>
<tr>
<td>$A_3$</td>
<td>6</td>
<td>9</td>
<td>12</td>
<td>8</td>
<td>7</td>
</tr>
<tr>
<td>$A_4$</td>
<td>6</td>
<td>7</td>
<td>14</td>
<td>6</td>
<td>10</td>
</tr>
<tr>
<td>$A_5$</td>
<td>6</td>
<td>9</td>
<td>12</td>
<td>10</td>
<td>6</td>
</tr>
</tbody></table>
<p>解：这是一个标准的指派问题. 引进0-1变量<br>$$<br>x_{ij}<br>\begin{cases}<br>1,A_i承建B_j;\<br>0,A_i不承建B_j;\<br>\end{cases}<br>\ \ \ (i,j&#x3D;1,2,3,4,5)<br>$$<br>建立数学模型：<br>$$<br>min\ z&#x3D;\sum_{i&#x3D;1}^{5}\sum_{j&#x3D;1}^{5}c_{ij}+x_{ij}\<br>s.t.<br>\begin{cases}<br>\sum_{j&#x3D;1}^{5}x_{ij}&#x3D;1,i&#x3D;1,2,…,5\<br>\sum_{i&#x3D;1}^{5}x_{ij}&#x3D;1,i&#x3D;1,2,…,5\<br>x_{ij}&#x3D;0\ or\ 1,(i,j&#x3D;1,2,…,5)<br>\end{cases}<br>(意思是每个房子都要建且只能是一个建筑队去建且要不不建要不建)<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"></span><br><span class="line">c=np.array([</span><br><span class="line">    [<span class="number">4</span>	,<span class="number">8</span>	,<span class="number">7</span>	,<span class="number">15</span>	,<span class="number">12</span>],</span><br><span class="line">    [<span class="number">7</span>	,<span class="number">9</span>	,<span class="number">17</span>	,<span class="number">14</span>	,<span class="number">10</span>],</span><br><span class="line">    [<span class="number">6</span>	,<span class="number">9</span>	,<span class="number">12</span>	,<span class="number">8</span>	,<span class="number">7</span> ],</span><br><span class="line">    [<span class="number">6</span>	,<span class="number">7</span>	,<span class="number">14</span>	,<span class="number">6</span>	,<span class="number">10</span>],</span><br><span class="line">    [<span class="number">6</span>	,<span class="number">9</span>	,<span class="number">12</span>	,<span class="number">10</span>	,<span class="number">6</span> ] ])</span><br><span class="line">x=cp.Variable((<span class="number">5</span>,<span class="number">5</span>),integer=<span class="literal">True</span>) <span class="comment">#定义5*5的整型变量</span></span><br><span class="line"></span><br><span class="line">obj=cp.Minimize(cp.<span class="built_in">sum</span>(cp.multiply(c,x)))   <span class="comment">#构造函数</span></span><br><span class="line">con=[<span class="number">0</span>&lt;=x,x&lt;=<span class="number">1</span>,cp.<span class="built_in">sum</span>(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)==<span class="number">1</span>,</span><br><span class="line">     cp.<span class="built_in">sum</span>(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)==<span class="number">1</span>]</span><br><span class="line"><span class="comment"># axis=0表示按列相加，keepdims=True指保持其二维特性</span></span><br><span class="line">prob=cp.Problem(obj,con)</span><br><span class="line">prob.solve(solver=<span class="string">&#x27;GLPK_MI&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优值为：&#x27;</span>,prob.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：\n&#x27;</span>,x.value)</span><br></pre></td></tr></table></figure>

<h4 id="广义指派模型"><a href="#广义指派模型" class="headerlink" title="广义指派模型"></a>广义指派模型</h4><h5 id="最大化指派模型"><a href="#最大化指派模型" class="headerlink" title="最大化指派模型"></a>最大化指派模型</h5><p>在实际应用中，常会遇到各种非标准形式的指派问题—广义指派问题，通常的处理方法是<strong>先讲它们转化为标准形式，然后再用匈牙利算法求解</strong><strong>.</strong></p>
<p>一些指派问题中，每人完成各项工作的<strong>效率</strong>可能是诸如<strong>利润、业绩</strong>等(效益型指标&#x2F;指标体现)，此时则以总的工作效率最大为目标函数，即<br>$$<br>max\ z&#x3D;\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij}<br>$$<br>对于最大化指派问题，若令：<br>$$<br>M&#x3D;\max_{i\leqslant n,j\leqslant n} {c_{ij} }<br>$$<br>再由于约束函数条件的限制<br>$$<br>\sum^{n}<em>{i&#x3D;1}\sum</em>{j&#x3D;1}^{n}x_{ij}&#x3D;n<br>$$<br>则有：<br>$$<br>min\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}(M-c_{ij})x_{ij}\<br>&#x3D;min(\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}Mx_{ij}-\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij})\<br>&#x3D;nM-max\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \<br>$$<br>即<br>$$<br>max\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij}&#x3D;<br>nM-min\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}(M-c_{ij})x_{ij}<br>$$<br>于是，使得$C&#x3D;(c_{ij})<em>{n\times n}$为效率矩阵的最大化指派问题，就转化为求以$(M-c</em>{ij})_{n\times n}$为效率矩阵的标准指派问题。</p>
<h5 id="人数和任务数不等的指派问题"><a href="#人数和任务数不等的指派问题" class="headerlink" title="人数和任务数不等的指派问题"></a>人数和任务数不等的指派问题</h5><ul>
<li>若人数少于任务数，添加虚拟的“人”，对应的效率取为0</li>
<li>若人数多于任务数，添加虚拟的“任务”，对应的效率取为0</li>
</ul>
<h5 id="一个人可完成多项任务的指派问题"><a href="#一个人可完成多项任务的指派问题" class="headerlink" title="一个人可完成多项任务的指派问题"></a>一个人可完成多项任务的指派问题</h5><ul>
<li>可将该人看作相同的几个人来接受指派，只需令其完成同一项任务的效率都一样即可</li>
</ul>
<h5 id="某项任务一定不能由某人完成的指派问题"><a href="#某项任务一定不能由某人完成的指派问题" class="headerlink" title="某项任务一定不能由某人完成的指派问题"></a>某项任务一定不能由某人完成的指派问题</h5><ul>
<li>对于这样的指派问题，只需将相应的效率值取成足够大的数即可.</li>
</ul>
<p>注意：上述是理论推导，在实际使用软件求解广义指派问题时，也可直接建立0-1整数规划模型，不需要把广义指派问题化成标准的指派问题.</p>
]]></content>
      <categories>
        <category>算法类</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派系统</title>
    <url>/archives/94d4c7d.html</url>
    <content><![CDATA[<h1 id="树莓派-ROS-melodic-Ubuntu-meta桌面-安装大全"><a href="#树莓派-ROS-melodic-Ubuntu-meta桌面-安装大全" class="headerlink" title="树莓派+ROS_melodic+Ubuntu+meta桌面 安装大全"></a>树莓派+ROS_melodic+Ubuntu+meta桌面 安装大全</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>​		您首先是将ROS系统安装于Ubuntu对应的版本上，时常我们会因为不是统一版本，导致安装失败。其次是换源操作，但倘若你是在树莓派上安装对应的版本，这个时候要小心，因为树莓派4B属于Arm64位系统，所以换源一定是属于树莓派的源。</p>
<p><em><strong>许多的电脑系统学习，时常会因为环境的安装，导致一半的人放弃；这里我要说，倘若你是真的爱，环境安装即使数十次，任不能阻挡你，那便是成功的一半了。</strong></em></p>
<h2 id="安装Ubuntu系统"><a href="#安装Ubuntu系统" class="headerlink" title="安装Ubuntu系统"></a>安装Ubuntu系统</h2><p>这里我使用树莓派4B安装此操作系统，倘若你说虚拟机版本的ubuntu的话，基本上一模一样。(树莓派的问题和系统前的操作更加复杂。)</p>
<p>基础配置：树莓派4B一个内存16GB</p>
<p>软件下载：</p>
<p>[1] SD Memory Card formatter 格式化软件   <a href="https://www.sdcard.org/chs/downloads/formatter/index.html">https://www.sdcard.org/chs/downloads/formatter/index.html</a></p>
<p>[2] Raspberry Pi Imager for Windows <a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a></p>
<p>[3] 系统(我用的是Ubuntu 18.04树莓派4下载64位)  <a href="https://ubuntu.com/download/raspberry-pi">https://ubuntu.com/download/raspberry-pi</a></p>
<p>[4] MobaXterm  <a href="https://moba.en.softonic.com/">https://moba.en.softonic.com/</a></p>
<h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><p>第一次启动树莓派，要插入一个键盘，鼠标，HDMI线，连接网线</p>
<h3 id="格式化SD卡"><a href="#格式化SD卡" class="headerlink" title="格式化SD卡"></a>格式化SD卡</h3><p>首先，下载好SD格式化软件，使用读卡器读取TF卡，然后打开SD格式化软件</p>
<p>【图片】</p>
<p>选择好要格式的卡，选择Quock format ，然后点击Format直接快速格式化SD卡</p>
<h3 id="烧录ubuntu系统"><a href="#烧录ubuntu系统" class="headerlink" title="烧录ubuntu系统"></a>烧录ubuntu系统</h3><p>选择下载好的 Raspberry Pi Imager直接安装，然后双击打开，OS选择下载好的Ubuntu 18.04系统,SD卡选择烧录的卡，然后写入。</p>
<p>写入完成后，将烧录好的SD卡插入树莓派背面的SD(TF)卡槽。</p>
<h3 id="直接设置"><a href="#直接设置" class="headerlink" title="直接设置"></a>直接设置</h3><p>连接好电源、网线，然后打开树莓派，（其实键盘，鼠标，HDMI线非必须，可以使用ssh连接），连接会提示修改ubuntu用户密码。第一次到第三次输入<code>ubuntu</code>，然后输入两次新密码。设置完成。</p>
<h3 id="ssh连接（仅适用于命令行系统）"><a href="#ssh连接（仅适用于命令行系统）" class="headerlink" title="ssh连接（仅适用于命令行系统）"></a>ssh连接（仅适用于命令行系统）</h3><p>这里我们先使用ssh连接，用MobaXterm软件。首先连接好电源、网线，然后打开树莓派，要通过路由器的设置网站（一般会在路由器上能找到），找到一个叫pi名字的，记住pi的地址。</p>
<p>在MobaXterm中，打开找到ssh，输入ip地址。</p>
<p>然后会让我们输入用户名，这里输入<code>ubuntu</code>,然后输入密码便打开了。</p>
<h3 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h3><p>这里如果想深入了解的话建议访问这个网址：<code>https://blog.csdn.net/CharlesSimonyi/article/details/89346473</code></p>
<p>不要在网站上随便复制，对应的系统架构不同，导致库文件和包不相同，所以建议如下操作：</p>
<p>在命令行中输入<code>cp /etc/apt/sources.list ./sources.list.backup</code>先备份地址。</p>
<p>然后输入 <code>sudo vim /etc/apt/sources.list</code>打开软件源。这里使用Vim来进行编辑。附录中有简单的对Vim的使用。</p>
<p>将所有的<a href="http://ports.ubuntu.com/ubuntu-ports%E5%85%A8%E9%83%A8%E6%9B%BF%E6%8D%A2%E4%B8%BA%E4%BD%A0%E8%A6%81%E7%9A%84%E6%BA%90%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9A">http://ports.ubuntu.com/ubuntu-ports全部替换为你要的源，例如：</a></p>
<p>中国科技大学地址：<code>http://mirrors.ustc.edu.cn/ubuntu-ports</code></p>
<p>阿里地址：<a href="https://mirrors.aliyun.com/ubuntu-ports/">https://mirrors.aliyun.com/ubuntu-ports/</a></p>
<p>然后<code>:wq</code>退出</p>
<p>最后输入<code>sudo apt update</code>和<code>sudo apt upgrade</code>这里时常会有些问题，可以在网络上查找，或者在评论区说出来，我会区看看帮帮忙。</p>
<h3 id="安装桌面系统-耗时很长"><a href="#安装桌面系统-耗时很长" class="headerlink" title="安装桌面系统(耗时很长)"></a>安装桌面系统(耗时很长)</h3><p>这里的任何几个桌面系统应该都是可以的</p>
<p>sudo apt-get install ubuntu-mate-desktop&#96;</p>
<p><code>sudo apt-get install xubuntu-desktop</code></p>
<p><code>sudo apt-get install lubuntu-desktop</code></p>
<p><code>sudo apt-get install kubuntu-desktop</code></p>
<h3 id="远程连接屏幕"><a href="#远程连接屏幕" class="headerlink" title="远程连接屏幕"></a>远程连接屏幕</h3><p>方法一:</p>
<p>安装xrdp</p>
<p><code>sudo apt-get install xrdp</code></p>
<p>重启xrdp服务</p>
<p><code>sudo service xrdp restart</code></p>
<p>Javis123</p>
<p>方法二:</p>
<p>安装VNC服务</p>
<p><code>sudo apt-get install tightvncserver</code></p>
<p>设置密码(输入连接客户端密码两次)</p>
<p><code> vncpasswd</code></p>
<p>开启服务功能(其中一定要记住他给出来的一个端口)</p>
<p><code>vncserver </code></p>
<p>记住端口(New ‘X’ desktop is  …. :2&#x2F;3&#x2F;4…)</p>
<p>在MobaXterm输入地址的时候,比如:192.162.169.2:2  &lt;—这里一定加上<code>:x</code>x为输出端口</p>
<h2 id="安装ROS"><a href="#安装ROS" class="headerlink" title="安装ROS"></a>安装ROS</h2><h3 id="多说几句"><a href="#多说几句" class="headerlink" title="多说几句"></a>多说几句</h3><p>几乎和官网的方法一致,但是总会有出现错误的地方.因为我们这里使用的是ubuntu 18.04系统,所以对应的ROS版本为Melodic;每个版本对应的不一样,一定要去官网查看好.这里我没有使用ubuntu20.04的原因是:树莓派可以安装好系统,但是无法找到ROS的完整软件包.但也有大神完成了树莓派官方系统的安装ROS…我这里不建议,因为官方系统没有对ros有较高的支持,而且 ROS的安装会出现一大堆意想不到的问题.这里我是经历过痛的,从树莓派官方系统到ubuntu的20.04版本,再到国外开发的ubuntu18.04桌面版本到现在的ubuntu mate18.04版本.只有少几次成功.</p>
<h3 id="安装前的设置"><a href="#安装前的设置" class="headerlink" title="安装前的设置"></a>安装前的设置</h3><p>打开<code>Ubuntu的设置</code>-&gt;<code>软件与更新</code>-&gt;<code>Ubuntu软件</code>-&gt;勾选关键字<code>universe</code>,<code>restricted</code>,<code>multiverse</code>三项。 如图所示:</p>
<p>[图片]</p>
<h3 id="添加sources-list"><a href="#添加sources-list" class="headerlink" title="添加sources.list"></a>添加sources.list</h3><p><code>$ sudo sh -c &#39;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;</code></p>
<p>建议使用国内或镜像源,官网使用的是外国的网站,这里使用的是中国科技大学的源.</p>
<h3 id="添加keys"><a href="#添加keys" class="headerlink" title="添加keys"></a>添加keys</h3><p><code>$ sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116</code></p>
<h3 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h3><p><code>$ sudo apt-get update </code></p>
<p><code>$ sudo apt-get upgrade</code></p>
<p>建议重启下树莓派 <code>sudo reboot</code></p>
<h3 id="安装完整工具箱"><a href="#安装完整工具箱" class="headerlink" title="安装完整工具箱"></a>安装完整工具箱</h3><p>安装桌面完整版安装（包含ROS、rqt、rviz、通用机器人函数库、2D&#x2F;3D仿真器、导航以及2D&#x2F;3D感知功能）</p>
<p><code>$ sudo apt-get install ros-melodic-desktop-full</code></p>
<h3 id="配置ROS"><a href="#配置ROS" class="headerlink" title="配置ROS"></a>配置ROS</h3><h4 id="初始化rosdep"><a href="#初始化rosdep" class="headerlink" title="初始化rosdep"></a>初始化rosdep</h4><p><code>$ sudo apt install python-rosdep</code>  避免后面出现sudo rosdep：找不到命令提示</p>
<p><code>$ sudo rosdep init</code></p>
<p>这里一般都会出现问题,<strong>rosdep init 或者rosdep update 连接错误的解决办法:</strong></p>
<p> ERROR: unable to process source <a href="https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/xxxxx">https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/xxxxx</a> </p>
<p>则:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#打开hosts文件</span><br><span class="line">sudo gedit /etc/hosts</span><br><span class="line">#在文件末尾添加</span><br><span class="line">151.101.84.133  raw.githubusercontent.com</span><br><span class="line">#保存后退出再尝试</span><br></pre></td></tr></table></figure>

<p>成功之后输入:</p>
<p><code>$ rosdep update</code></p>
<h4 id="ROS环境配置"><a href="#ROS环境配置" class="headerlink" title="ROS环境配置"></a>ROS环境配置</h4><h5 id="添加ros环境变量"><a href="#添加ros环境变量" class="headerlink" title="添加ros环境变量"></a>添加ros环境变量</h5><p><code>$ echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc</code></p>
<p><code>$ source ~/.bashrc</code></p>
<h5 id="安装rosinstall"><a href="#安装rosinstall" class="headerlink" title="安装rosinstall"></a>安装rosinstall</h5><p>ROS中一个独立分开的常用命令行工具，它可以方便让你通过一条命令就可以给某个ROS软件包下载很多源码树。</p>
<p><code>$ sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential </code></p>
<h2 id="安装完成-测试"><a href="#安装完成-测试" class="headerlink" title="安装完成+测试"></a>安装完成+测试</h2><p>ROS服务开启的第一的命令,一般使用ROS都要先执行这个:</p>
<p><code>$ roscore</code></p>
<p>启动乌龟的终端:</p>
<p><code>$ rosrun turtlesim turtlesim_node</code></p>
<p>连接键盘命令的节点:</p>
<p><code>$ rosrun turtlesim  turtle_teleop_key</code></p>
<p>选择好键盘命令的节点终端窗口,通过键盘上的方向键，进行操作小海龟.</p>
<h2 id="恭喜你，ROS已经成功的安装、配置并且运行！"><a href="#恭喜你，ROS已经成功的安装、配置并且运行！" class="headerlink" title="恭喜你，ROS已经成功的安装、配置并且运行！"></a>恭喜你，ROS已经成功的安装、配置并且运行！</h2><p>下面就正式开启ROS精彩的旅程！</p>
<p>我个人已经成功,这是我对于成功后的总结,当然,其中我也面对了许多的问题,没有在文章中说明,是因为尝试前还不知是否可以,当写完这篇文章的时候,已经是安装完成的形态了.</p>
<p>但我相信还是有许多同学总是卡在安装的过程中,这里您们可以留言在讨论区,共同解决问题.倘若有问题已经在讨论区中出现,请先查找讨论区的问题是否有,进行相对应的调试.</p>
<p>尽量每一层都是新的问题.</p>
<p>参考地址:</p>
<p>[1] <a href="https://ismango.blog.csdn.net/article/details/106049992">https://ismango.blog.csdn.net/article/details/106049992</a></p>
<p>[2]  <a href="https://community.bwbot.org/topic/811/rosdep-init-%E6%88%96%E8%80%85rosdep-update-%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">https://community.bwbot.org/topic/811/rosdep-init-%E6%88%96%E8%80%85rosdep-update-%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95</a></p>
<p>[3] <a href="https://wiki.ros.org/melodic/Installation/Ubuntu">https://wiki.ros.org/melodic/Installation/Ubuntu</a></p>
<p>[4] <a href="https://www.cnblogs.com/wjundong/p/10701160.html">https://www.cnblogs.com/wjundong/p/10701160.html</a></p>
<p>[5]  <a href="https://www.bilibili.com/video/BV1zt411G7Vn?t=7&amp;p=5">https://www.bilibili.com/video/BV1zt411G7Vn?t=7&amp;p=5</a></p>
<p>[6]  <a href="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/chapter1/1.4.html">https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/chapter1/1.4.html</a></p>
<p>基础命令</p>
<p>启动小海龟：</p>
<p>$ roscore 	运行节点管理器</p>
<p>$ rosrun turtlesim turtesim_node		打开仿真器节点</p>
<p>$ rosrun turtlesim turtle_teleop_key    				  键盘控制键</p>
<p>$ rqt_graph	显示图</p>
<p>$ rosnode	显示节点相关信息的指令</p>
<p>​	$ rosnode list	列出所有节点</p>
<p>​	$ rosnode info  +上面列出的节点信息  	查询某节点具体信息</p>
<p>​			例如：$ rosnode info &#x2F;rosout</p>
<p>$ rostopic 	显示话题相关的指令</p>
<p>​	$ rostopic list	列出所有话题</p>
<p>$rostopic pub &#x2F;turtle1&#x2F;cmd_vel 后面的内容双击Tab键进行补齐</p>
<p>​		解释：rostopic是使用话题的命令   pub  发布数据给某个topic   &#x2F;turtle1&#x2F;cmd_vel控制海龟运动的话题 </p>
<p>里面linear 为海龟的线速度  angular 为海龟的角速度  可修改</p>
<p>其中加了  -r 10     代表：重复发布，即一直执行  10 每秒10次</p>
<p>$ rosmsg  	与消息有关</p>
<p>​	$ rosmsg show +要展示的消息</p>
<p>​		例子：rosmsg show geometry_msgs&#x2F;Twist</p>
<p>​					geometry_msgs&#x2F;Twist 为海龟运动时补全的第一个命令</p>
<p>$ rosservice	服务有关</p>
<p>​	$ rosservice list 显示服务的相关功能</p>
<p>​		其中&#x2F;spawn  产生新的海龟</p>
<p>​			操作:</p>
<p>​					$ rosservice call &#x2F;spawn  [2次Tab补全]</p>
<p>​							call  发布请求    x、y、theta为xy坐标，角度  name为名字，不要出现重复</p>
<p>$ rosbag record -a -O cmd_record	 话题记录工具</p>
<p>record 记录功能  -a  也就是 -all记录所有  -O保存为压缩包   cmd_record压缩包名字</p>
<p>重启后：</p>
<p>$ roscore 	运行节点管理器</p>
<p>$ rosrun turtlesim turtesim_node		打开仿真器节点</p>
<p>$ rosbag play cmd_record.bag   		复现记入的路径数据  cmd_record.bag  为压缩包名字</p>
<p>创建工作空间与功能包</p>
<p>工程空间：workspace 存放<strong>工程</strong>发开发相关文件的文件夹</p>
<p>src : 代码空间   			功能包</p>
<p>build : 编译空间			中间文件</p>
<p>devel : 开发空间    		放置最后的文件</p>
<p>install : 安装空间			安装的位置</p>
<p>空间结构图</p>
<p>创建工作空间：</p>
<p>$ mkdir -p ~&#x2F;project_name&#x2F;src</p>
<p>$ cd ~&#x2F;project_name&#x2F;src</p>
<p>$ catkin_init_workspace</p>
<p>编译空间：</p>
<p>$ cd ~&#x2F;project_name&#x2F;</p>
<p>$ catkin_make</p>
<p>设置环境变量：</p>
<p>$ source devel&#x2F;setup.bash</p>
<p>检查环境变量：</p>
<p> $   echo $ROS_PACKAGE_PATH</p>
]]></content>
      <categories>
        <category>全栈类</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派初体验</title>
    <url>/archives/f8223cc6.html</url>
    <content><![CDATA[<h1>树莓派初体验</h1>

<h2>开箱+详解</h2>

<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_003141.jpg" alt="IMG_20200620_003141"></p>
<p>分别为亚克力板、散热片、电风扇、读卡器、Tf卡，SD卡、树莓派单板、500万摄像头、电源、网线、hdml转micro线。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pi-plug-in.gif" alt="pi-plug-in"></p>
<p>这里特别注释：必要的购买：</p>
<p>首先至少要有<em><strong>电源供应器</strong></em>（Raspberry Pi 4至少3.0安培&#x2F;Raspberry Pi 3至少为2.5A）（在许多手机上都可以找到），4B的话是平头，与一加手机充电器差不多，充电器最好带开关，这里不和STM32或51单片机一样自带开关的。电源插头的形状如下：</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/Snipaste_2020-06-20_12-01-31.png" alt="Snipaste_2020-06-20_12-01-31"></p>
<h3 id="microSD卡（TF卡）"><a href="#microSD卡（TF卡）" class="headerlink" title="microSD卡（TF卡）"></a>microSD卡（TF卡）</h3><p>您的Raspberry Pi需要一个SD卡来存储其所有文件和Raspbian操作系统。需要容量<strong>至少为8 GB</strong>的microSD卡</p>
<p><em><strong>散热片和电风扇：</strong></em></p>
<p>保证温度不会过高导致死机。</p>
<p>不必要的购买：</p>
<h3 id="键盘和鼠标"><a href="#键盘和鼠标" class="headerlink" title="键盘和鼠标"></a>键盘和鼠标</h3><p>第一次使用树莓派，需要一个USB键盘和一个USB鼠标。设置好Pi后，您可以使用蓝牙键盘和鼠标，但是第一次安装时需要USB键盘和鼠标。</p>
<h3 id="电视或电脑屏幕"><a href="#电视或电脑屏幕" class="headerlink" title="电视或电脑屏幕"></a>电视或电脑屏幕</h3><p>要查看Raspbian桌面环境，您要一个屏幕以及用于连接树莓派的电缆。如果屏幕上有内置扬声器，则Pi可以使用这些扬声器播放声音。</p>
<p>想查看细节建议  <a href="https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up/1">https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up/1</a>  官方网站讲解基本</p>
<p>以下是细节部分：</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_004244.jpg" alt="IMG_20200620_004244"></p>
<center>hdml转micro细节</center>

<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_004842.jpg" alt="IMG_20200620_004842"></p>
<center>亚克力板自左上到右下依次叠加成为树莓派盒</center>

<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_004112.jpg" alt="IMG_20200620_004112"></p>
<center>带开关的电源

<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_004337.jpg" alt="IMG_20200620_004337"></p>
<center>500万摄像头



<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_003950.jpg" alt="IMG_20200620_003950"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_003923.jpg" alt="IMG_20200620_003923"></p>
<center>零部件



<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_003317.jpg" alt="IMG_20200620_003317"></p>
<center>带插槽的读卡器（非u盘）



<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_003513.jpg" alt="IMG_20200620_003513"></p>
<center>正面

<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_003732.jpg" alt="IMG_20200620_003732"></p>
<center>反面

<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/-18699762.jpg" alt="-18699762"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/-1788106408.jpg" alt="-1788106408"></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/-692123576.jpg" alt="-692123576"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/490159692.jpg" alt="490159692"></p>
<h1>组装</h1>

<p>因为买来的Tf卡已经安装好Raspberry Pie官方的系统Raspbian，下次等刷机的时候，再写一篇关于装系统的文章。<a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a>  系统镜像下载地址。</p>
<p>首先先将TF卡插入树莓派板后方的卡槽，再为CPU和旁边的芯片，及蓝牙WIFI芯片贴好散热片，否则过热会导致树莓派死机，再组装盒子。在亚克力板的上方固定风扇于是完成。</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_123416.jpg" alt="IMG_20200620_123416"></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/IMG_20200620_123555.jpg" alt="IMG_20200620_123555"></p>
<p>那么开始使用吧~</p>
]]></content>
      <categories>
        <category>全栈类</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>电子钟的设计</title>
    <url>/archives/12e2ae1e.html</url>
    <content><![CDATA[<p>程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line">sbit RS = P3^<span class="number">0</span>;</span><br><span class="line">sbit RW = P3^<span class="number">1</span>;</span><br><span class="line">sbit E  = P3^<span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hour=<span class="number">0</span>,min=<span class="number">0</span>,sec=<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str[]=&#123;<span class="string">&quot;0123456789&quot;</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str1[]=&#123;<span class="string">&quot;Clock:&quot;</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=<span class="number">100</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writedat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span>  <span class="comment">//写入命令</span></span><br><span class="line">&#123;</span><br><span class="line">	RS= <span class="number">1</span>;</span><br><span class="line">	RW= <span class="number">0</span>;</span><br><span class="line">	E = <span class="number">0</span>;</span><br><span class="line">	P2=dat;</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	E=<span class="number">1</span>;</span><br><span class="line">	E=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writecom</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> com)</span>  <span class="comment">//写入命令</span></span><br><span class="line">&#123;</span><br><span class="line">	RS= <span class="number">0</span>;</span><br><span class="line">	RW= <span class="number">0</span>;</span><br><span class="line">	E = <span class="number">0</span>;</span><br><span class="line">	P2=com;</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	E=<span class="number">1</span>;</span><br><span class="line">	E=<span class="number">0</span>;</span><br><span class="line">	E=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> temp0=<span class="number">0</span>,temp1=<span class="number">0</span>,temp2=<span class="number">0</span>,temp3=<span class="number">0</span>,temp4=<span class="number">0</span>,temp5=<span class="number">0</span>;</span><br><span class="line">	temp0=hour/<span class="number">10</span>;</span><br><span class="line">	temp1=hour%<span class="number">10</span>;</span><br><span class="line">	temp2=min/<span class="number">10</span>;</span><br><span class="line">	temp3=min%<span class="number">10</span>;</span><br><span class="line">	temp4=sec/<span class="number">10</span>;</span><br><span class="line">	temp5=sec%<span class="number">10</span>;</span><br><span class="line">	writecom(<span class="number">0x80</span>);</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        writedat(str1[i]);</span><br><span class="line">        delay(<span class="number">5</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    writecom(<span class="number">0x80</span>+<span class="number">0x40</span>+<span class="number">4</span>);</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	writedat(str[temp0]);</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	writedat(str[temp1]);</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	writedat(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	writedat(str[temp2]);</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	writedat(str[temp3]);</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	writedat(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	writedat(str[temp4]);</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	writedat(str[temp5]);</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initlcd</span><span class="params">()</span>  <span class="comment">//初始化</span></span><br><span class="line">&#123;</span><br><span class="line">	writecom(<span class="number">0x38</span>);</span><br><span class="line">	writecom(<span class="number">0x0c</span>);</span><br><span class="line">	writecom(<span class="number">0x06</span>);</span><br><span class="line">	writecom(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">inittimer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	TMOD=<span class="number">0x01</span>;</span><br><span class="line">	TH0=(<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>;  </span><br><span class="line">	TL0=(<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;</span><br><span class="line">	ET0=<span class="number">1</span>;</span><br><span class="line">	EA=<span class="number">1</span>;</span><br><span class="line">	TR0=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	initlcd();</span><br><span class="line">	inittimer();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer0_isr</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">	TH0=(<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>; <span class="comment">//无法重装载</span></span><br><span class="line">	TL0=(<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;</span><br><span class="line">	count++;</span><br><span class="line">	<span class="keyword">if</span>(count==<span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sec++;</span><br><span class="line">		count=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sec==<span class="number">60</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		min++;</span><br><span class="line">		sec=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(min==<span class="number">60</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		hour++;</span><br><span class="line">		min=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(hour==<span class="number">24</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		hour=<span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>硬件类</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理</title>
    <url>/archives/9ab27f24.html</url>
    <content><![CDATA[<h1 id="大学物理"><a href="#大学物理" class="headerlink" title="大学物理"></a>大学物理</h1><p>资料总结整理人：19级通信工程于邦震</p>
<p>作图：于邦震</p>
<h2 id="电"><a href="#电" class="headerlink" title="电"></a>电</h2><h3 id="1-库仑定律-F"><a href="#1-库仑定律-F" class="headerlink" title="1. 库仑定律 F"></a>1. 库仑定律 F</h3><p>$$<br>F&#x3D;k\frac{q_1q_2}{r^2}e_r \ \ \ 又有k&#x3D;\frac{1}{4\pi\varepsilon _0}<br>$$</p>
<p>推导出来有<br>$$<br>F&#x3D;\frac{1}{4\pi\varepsilon _0}\frac{q_1q_2}{r^2}\overrightarrow{e_r}&#x3D; Eq<br>$$</p>
<h3 id="2-电场"><a href="#2-电场" class="headerlink" title="2. 电场"></a>2. 电场</h3><h4 id="电场强度-E"><a href="#电场强度-E" class="headerlink" title="电场强度 E"></a>电场强度 E</h4><p>$$<br>E&#x3D;\frac{\overrightarrow{F}}{q_0}&#x3D;\frac{1}{4\pi\varepsilon _0}\frac{q}{r^2}\overrightarrow{e_r}<br>$$</p>
<p>微分形式：<br>$$<br>E&#x3D;\int dE&#x3D;\frac{1}{4\pi\varepsilon _0}\int_v \frac{dq}{r^2}\overrightarrow{e_r}<br>$$</p>
<p>$$<br>dq&#x3D;<br>\left{\begin{matrix}<br>  \lambda dL\ \sigma dS\ \rho dV<br>\end{matrix}\right.<br>$$</p>
<h4 id="2-2-电偶极子-p-e"><a href="#2-2-电偶极子-p-e" class="headerlink" title="2.2. 电偶极子 $p_e$"></a>2.2. 电偶极子 $p_e$</h4><p>$$<br>p_e&#x3D;ql<br>$$</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/%E7%89%A9%E7%90%860.png" alt="物理0"><br>$$<br>E&#x3D;-\frac{p_e}{4\pi\varepsilon_0 r^3}<br>$$</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/%E7%89%A9%E7%90%861.png" alt="物理1"><br>$$<br>E&#x3D;<br>\left{\begin{matrix}<br>  E_x&#x3D; \frac{\lambda}{2\pi\varepsilon_0 a}\<br>  E_y&#x3D;0<br>\end{matrix}\right.<br>$$</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/%E7%89%A9%E7%90%862.png" alt="物理2"><br>$$<br>E&#x3D;E_{\}&#x3D;\frac{qx}{4\pi\varepsilon_0 \sqrt{(x^2+R^2)^3}}&#x3D;<br>\left{\begin{matrix}<br>x&gt;&gt;R,E&#x3D;\frac{q}{4\pi\varepsilon_0 x^2};\<br>x&#x3D;0,则E&#x3D;0;\ \ \ \ \ \ \ \ \<br>由\frac{dE}{dx}&#x3D;0,知x&#x3D;\pm \frac{\sqrt{2}}{2}R<br>\end{matrix}\right.<br>$$</p>
<h3 id="3-电通量"><a href="#3-电通量" class="headerlink" title="3. 电通量"></a>3. 电通量</h3><p>$$<br>d\Phi_e&#x3D;EdS_\perp&#x3D;EdScos\theta<br>$$</p>
<p>所以<br>$$<br>\Phi_e&#x3D;\int _sEdS_\perp&#x3D;\int_s EdScos\theta<br>$$</p>
<h3 id="4-静电场的高斯定理-Phi-e-x3D-oint-sEdS-x3D-frac-1-varepsilon-0-sum-i-q-i"><a href="#4-静电场的高斯定理-Phi-e-x3D-oint-sEdS-x3D-frac-1-varepsilon-0-sum-i-q-i" class="headerlink" title="4. 静电场的高斯定理$\Phi_e&#x3D;\oint _sEdS&#x3D;\frac{1}{\varepsilon _0}\sum_i q_i$"></a>4. 静电场的高斯定理$\Phi_e&#x3D;\oint _sEdS&#x3D;\frac{1}{\varepsilon _0}\sum_i q_i$</h3><p>$$<br>\Phi_e&#x3D;\oint _sEdS&#x3D;\frac{1}{\varepsilon _0}\sum_i q_i<br>$$</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/物理4.png" alt="物理4" style="zoom:45%;" /><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/物理5.png" alt="物理5" style="zoom:48%;" /></p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/物理3.png" alt="物理3" style="zoom:40%;" /><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/WL16.png" alt="WL16" style="zoom:72%;" /></p>
<h3 id="5-静电力做功-W"><a href="#5-静电力做功-W" class="headerlink" title="5. 静电力做功 W"></a>5. 静电力做功 W</h3><p>$$<br>W&#x3D;Eqcos\theta l<br>$$</p>
<p>微分形式<br>$$<br>dW&#x3D;Eqcos\theta dl<br>$$<br>所以积分后(这里的E是有方向的)<br>$$<br>W_{ab}&#x3D;W_a-W_b<br>&#x3D;\int_a^b q_0Edl<br>&#x3D;\frac{q_0q_i}{4\pi\varepsilon_0}\int_{r_a}^{r_b}\frac{1}{r^2}dr<br>&#x3D;\frac{q_0q_i}{4\pi\varepsilon_0}(\frac{1}{r_a}-\frac{1}{r_b})<br>$$</p>
<h3 id="6-静电场环路定理-oint-L-Edl-x3D-0"><a href="#6-静电场环路定理-oint-L-Edl-x3D-0" class="headerlink" title="6. 静电场环路定理$\oint_L Edl&#x3D;0$"></a>6. 静电场环路定理$\oint_L Edl&#x3D;0$</h3><p>$$<br>\oint_LEqdl&#x3D;0，则可以写为\oint_L Edl&#x3D;0.表达是转一圈做功为0<br>$$</p>
<h3 id="7-电势"><a href="#7-电势" class="headerlink" title="7. 电势"></a>7. 电势</h3><h4 id="7-1-电势能-W"><a href="#7-1-电势能-W" class="headerlink" title="7.1.电势能 W"></a>7.1.电势能 W</h4><p>点电荷q的电势&#x3D;点电荷q从该点移动到电势为0的点所做的功。<br>$$<br>W_p&#x3D;\int_p^\infty  q_0E\cdot dl<br>$$</p>
<h4 id="7-2-电势与电势差-V"><a href="#7-2-电势与电势差-V" class="headerlink" title="7.2.电势与电势差 V"></a>7.2.电势与电势差 V</h4><p>$$<br>U_p&#x3D;\frac{W_p}{q_0}&#x3D;\int_p^\infty E\cdot dl<br>$$</p>
<p>电势差<br>$$<br>U_{ab}&#x3D;U_a-U_b<br>&#x3D;\int_a^\infty E\cdot dl-\int_b^\infty E\cdot dl<br>&#x3D;\int_a^b E\cdot dl<br>$$</p>
<h3 id="8-点电荷的库仑力、电场、电势"><a href="#8-点电荷的库仑力、电场、电势" class="headerlink" title="8. 点电荷的库仑力、电场、电势"></a>8. 点电荷的库仑力、电场、电势</h3><h4 id="8-1-库仑力"><a href="#8-1-库仑力" class="headerlink" title="8.1.库仑力"></a>8.1.库仑力</h4><p>$$<br>F&#x3D;\frac{1}{4\pi\varepsilon _0}\frac{q_1q_2}{r^2}\overrightarrow{e_r}<br>$$</p>
<h4 id="8-2-电场"><a href="#8-2-电场" class="headerlink" title="8.2.电场"></a>8.2.电场</h4><p>$$<br>E&#x3D;\frac{1}{4\pi\varepsilon _0}\frac{q_0}{r^2}\overrightarrow{e_r}<br>$$</p>
<h4 id="8-3-电势"><a href="#8-3-电势" class="headerlink" title="8.3.电势"></a>8.3.电势</h4><p>$$<br>U&#x3D;\frac{1}{4\pi\varepsilon _0}\frac{q}{r^r}<br>$$</p>
<h3 id="9-等势面"><a href="#9-等势面" class="headerlink" title="9. 等势面"></a>9. 等势面</h3><ul>
<li><p>等势面与电场线处处正交垂直</p>
</li>
<li><p>电势面密集，场强越大</p>
</li>
<li><p>电场线指向电势减弱的方向</p>
</li>
</ul>
<h4 id="9-1-电场强度与电势梯度"><a href="#9-1-电场强度与电势梯度" class="headerlink" title="9.1. 电场强度与电势梯度"></a>9.1. 电场强度与电势梯度</h4><p>$$<br>E_l&#x3D;-\frac{dU}{dl}<br>$$</p>
<p>电场指向电势降低的方向</p>
<ul>
<li>电势梯度：电势减少的方向</li>
</ul>
<p>$$<br>E&#x3D;-\frac{dU}{dn}\overrightarrow{e_n}&#x3D;-\bigtriangledown U &#x3D;-grad U<br>$$</p>
<p>场强与电势梯度相反</p>
<h3 id="10-电容"><a href="#10-电容" class="headerlink" title="10. 电容"></a>10. 电容</h3><p>$$<br>C&#x3D;\frac{q}{U}<br>$$</p>
<ul>
<li>求电容的方法</li>
</ul>
<ol>
<li>先设电荷</li>
<li>求E(高斯去求)</li>
<li>求$U&#x3D;\int_A^B E\cdot dl&#x3D;\frac{qd}{\varepsilon_0S}$</li>
<li>求$C&#x3D;\frac{q}{U}&#x3D;\frac{\varepsilon_0S}{qd}$</li>
</ol>
<p>1、平行板电容<br>$$<br>\because E&#x3D;\frac{\sigma}{\varepsilon_0}&#x3D;\frac{q}{\varepsilon_0S};U_{AB}&#x3D;\int_A^BE \cdot dl&#x3D;Ed&#x3D;\frac{qd}{\varepsilon_0S}<br>$$</p>
<p>$$<br>\therefore C&#x3D;\frac{q}{U_{AB}}&#x3D;\frac{\varepsilon_0S}{d}<br>$$</p>
<p>2、圆柱形电容器<br>$$<br>\because \lambda&#x3D;\frac{q}{l}<br>$$</p>
<p>$$<br>\therefore E&#x3D;\frac{\lambda}{2\pi\varepsilon_0r},R_A&lt;r&lt;R_B<br>$$</p>
<p>$$<br>\therefore U_{AB}&#x3D;\int_{R_A}^{R_B}E \cdot dr &#x3D;\int_{R_A}^{R_B}\frac{\lambda}{2\pi\varepsilon_0r}dr&#x3D;\frac{\lambda}{2\pi\varepsilon_0}ln\frac{R_B}{R_A}<br>$$</p>
<p>$$<br>\therefore C&#x3D;\frac{q}{U_{AB}}&#x3D;\frac{\lambda l}{U_{AB}}&#x3D;\frac{2\pi\varepsilon_0l}{ln\frac{R_B}{R_A}}<br>$$</p>
<p>3、球型电容器<br>$$<br>设(内R_A)(外R_B)球壳分别带电：+q、-q<br>$$</p>
<p>$$<br>E&#x3D;\frac{q}{4\pi\varepsilon_0r^2},(R_A&lt;r&lt;R_B)<br>$$</p>
<p>$$<br>U_{AB}&#x3D;\int_{R_A}^{R_B}E \cdot dr &#x3D;\frac{q}{4\pi\varepsilon_0}\int_{R_A}^{R_B}\frac{dr}{r^2}&#x3D;\frac{q}{4\pi\varepsilon_0}(\frac{1}{R_A}-\frac{1}{R_B})<br>$$</p>
<p>所以电容为<br>$$<br>C&#x3D;\frac{q}{U_{AB}}&#x3D;\frac{4\pi\varepsilon_0R_AR_B}{R_B-R_A}<br>$$<br>当$d&#x3D;R_B-R_A$很小的时候，$R_BR_A\approx R_A^2$ ,而$4\pi\varepsilon_0R_A^2&#x3D;S$<br>$$<br>有:C&#x3D;\frac{4\pi\varepsilon_0R_A^2}{d}&#x3D;\frac{\varepsilon_0S}{d}<br>$$</p>
<h4 id="10-1-有电解质的情况"><a href="#10-1-有电解质的情况" class="headerlink" title="10.1. 有电解质的情况"></a>10.1. 有电解质的情况</h4><p>$$<br>C&#x3D;\frac{\varepsilon_0\varepsilon_rS}{d}<br>$$</p>
<p>有电解质后整个电容的静电场<br>$$<br>E&#x3D;E_0-E’&#x3D;\frac{1}{\varepsilon_0}(\sigma_0-\sigma’)<br>$$</p>
<p>$$<br>U_0&#x3D;\varepsilon_r(Ed)&#x3D;E_0d<br>$$</p>
<p>$$<br>E&#x3D;\frac{E_0}{\varepsilon_r}<br>$$</p>
<p>充满介质的电容总电场为真空电容场强的$\frac{1}{\varepsilon_r}$倍</p>
<h4 id="10-2-高斯定理"><a href="#10-2-高斯定理" class="headerlink" title="10.2. 高斯定理"></a>10.2. 高斯定理</h4><p>$$<br>\oint_S \varepsilon_r\varepsilon_0E\cdot dS&#x3D;\sum_iq_i<br>$$</p>
<p>$$<br>电位移矢量 ：D&#x3D;\varepsilon_r\varepsilon_0E&#x3D;\varepsilon E<br>$$</p>
<p>$$<br>\because \oint_S \varepsilon E\cdot dS&#x3D;\oint_S D\cdot dS&#x3D;\sigma_0 S&#x3D;\sum_iq_i<br>$$</p>
<p>推导：<br>$$<br>\oint_S E_{空}\cdot ds&#x3D;\frac{1}{\varepsilon _0}\sum_i q_i<br>$$</p>
<p>$$<br>\oint_S \varepsilon_r \frac{E_{空}}{\varepsilon_r}\cdot ds&#x3D;\frac{1}{\varepsilon _0}\sum_i q_i<br>$$</p>
<p>$$<br>\oint_S \varepsilon_r\varepsilon_0 \frac{E_{空}}{\varepsilon_r}\cdot ds&#x3D;\sum_i q_i<br>$$</p>
<p>$$<br>\oint_S \varepsilon_r\varepsilon_0 E_{介}\cdot ds&#x3D;\sum_i q_i<br>$$</p>
<p>$$<br>\oint_S D\cdot dS&#x3D;\sigma_0 S&#x3D;\sum_iq_i<br>$$</p>
<h4 id="10-3-静电场的储存能量"><a href="#10-3-静电场的储存能量" class="headerlink" title="10.3. 静电场的储存能量"></a>10.3. 静电场的储存能量</h4><p>$$<br>C&#x3D;\frac{q}{U}<br>$$</p>
<p>$$<br>dW&#x3D;Udq&#x3D;\frac{q}{C}dq<br>$$</p>
<p>所以有<br>$$<br>W&#x3D;\frac{1}{C}\int_0^Qqdq&#x3D;\frac{Q^2}{2C}<br>$$<br>又因为<br>$$<br>Q&#x3D;CU<br>$$</p>
<p>所以有<br>$$<br>W&#x3D;\frac{Q^2}{2C}&#x3D;\frac{1}{2}QU&#x3D;\frac{CU^2}{2}<br>$$</p>
<h4 id="10-4-静电场的能量"><a href="#10-4-静电场的能量" class="headerlink" title="10.4. 静电场的能量"></a>10.4. 静电场的能量</h4><p>$$<br>E&#x3D;\frac{\sigma}{\varepsilon}&#x3D;\frac{Q}{\varepsilon S}<br>$$</p>
<p>又有<br>$$<br>C&#x3D;\frac{\varepsilon S}{d}<br>$$<br>所以有<br>$$<br>W_e&#x3D;\frac{1}{2}\frac{Q^2}{C}&#x3D;\frac{1}{2}\frac{\varepsilon^2 S^2E^2d}{\varepsilon S}&#x3D;\frac{1}{2}\varepsilon SE^2d&#x3D;\frac{1}{2}\varepsilon E^2V<br>$$<br>引入能量密度：<br>$$<br>w_e&#x3D;\frac{W_e}{V}&#x3D;\frac{1}{2}\varepsilon E^2<br>$$<br>所以微分形式：<br>$$<br>dW_e&#x3D;w_edV<br>$$<br>所以有：<br>$$<br>W_e&#x3D;\int_VdW_e&#x3D;\int_Vw_edV&#x3D;\int_V\frac{1}{2}\varepsilon E^2dV<br>$$</p>
<h2 id="磁学"><a href="#磁学" class="headerlink" title="磁学"></a>磁学</h2><p>（左力右电）</p>
<h3 id="1-恒定电流"><a href="#1-恒定电流" class="headerlink" title="1. 恒定电流"></a>1. 恒定电流</h3><p>$$<br>I&#x3D;\frac{dq}{dt}&#x3D;I(t)<br>$$</p>
<p>q为单位载流子电量、n为载流子的数量、u为飘移速度<br>$$<br>dI&#x3D;qnudS_\perp&#x3D;qnudScos\theta<br>$$<br>所以设 电流密度矢量$\delta &#x3D;qnu$ </p>
<p>所以有：<br>$$<br>I&#x3D;\int_S\delta \cdot ds<br>$$<br>则<br>$$<br>I&#x3D;\oint_S\delta \cdot ds&#x3D;0<br>$$</p>
<h3 id="2-电源电动势"><a href="#2-电源电动势" class="headerlink" title="2. 电源电动势"></a>2. 电源电动势</h3><p>$$<br>E为电源电动势(其实就是V):\ \ \ E&#x3D;\frac{W}{q}<br>$$</p>
<h3 id="3-磁场强度"><a href="#3-磁场强度" class="headerlink" title="3. 磁场强度"></a>3. 磁场强度</h3><p>$$<br>F_{max}&#x3D;q_0vB;所以B&#x3D;\frac{F_{max}}{q_0v}<br>$$</p>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/5243fbf2b2119313eec6cbd263380cd790238dce.jpg" alt="5243fbf2b2119313eec6cbd263380cd790238dce"></p>
<h3 id="4-毕奥-萨法尔定律"><a href="#4-毕奥-萨法尔定律" class="headerlink" title="4. 毕奥-萨法尔定律"></a>4. 毕奥-萨法尔定律</h3><p>$$<br>dB&#x3D;k\frac{Idlsin\theta}{r^2}&#x3D;\frac{\mu_0}{4\pi}\frac{Idlsin\theta}{r^2}<br>$$</p>
<p>$$<br>dB&#x3D;k\frac{Idl\times r }{r^3}&#x3D;\frac{\mu_0}{4\pi}\frac{Idl\times e_r}{r^2}<br>$$</p>
<p>$$<br>B&#x3D;\int dB&#x3D;\frac{\mu_0}{4\pi}\int\frac{Idl\times e_r}{r^2}<br>$$</p>
<h4 id="4-1-长直导线"><a href="#4-1-长直导线" class="headerlink" title="4.1. 长直导线"></a>4.1. 长直导线</h4><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/ML8.png" alt="ML8"></p>
<p>$$<br>dB&#x3D;\frac{\mu_0}{4\pi}\frac{Idzsin\theta}{r^2}<br>$$</p>
<p>$$<br>z&#x3D;a\ cot(\pi-\theta)&#x3D;-a\ cot\theta<br>$$</p>
<p>$$<br>dz&#x3D;d(-acot\theta)&#x3D;-a\ dcot\theta&#x3D;acsc^2\theta d\theta<br>$$</p>
<p>r和$\theta$ 的关系<br>$$<br>r&#x3D;\frac{a}{sin\theta}<br>$$<br>带入，得：<br>$$<br>B&#x3D;\int\frac{\mu_0}{4\pi}\frac{Iacsc^2\theta sin^3\theta}{a^2}d\theta&#x3D;\frac{\mu_0I}{4a\pi}\int_{\theta_1}^{\theta_2}sin\theta d\theta&#x3D;\frac{\mu_0I}{4a\pi}(cos\theta_1-cos\theta_2)<br>$$<br>当为无线长的时候：$\theta_1&#x3D;0;\theta_2&#x3D;\pi$:<br>$$<br>B&#x3D;\frac{\mu_0I}{2a\pi}<br>$$<br>当为半无线长，$\theta_1&#x3D;0\ or\ \frac{\pi}{2};\theta_2&#x3D;\frac{\pi}{2}\ or\ \pi$:<br>$$<br>B&#x3D;\frac{\mu_0I}{4a\pi}<br>$$</p>
<h4 id="4-2-圆环轴线附近的磁场"><a href="#4-2-圆环轴线附近的磁场" class="headerlink" title="4.2. 圆环轴线附近的磁场"></a>4.2. 圆环轴线附近的磁场</h4><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/ml10.png" alt="ml10"><br>$$<br>dB&#x3D;\frac{\mu_0}{4\pi}\frac{Idlsin(90^{\circ})}{r^2}<br>$$</p>
<p>$$<br>B_\perp&#x3D;0<br>$$</p>
<p>$$<br>sin\theta&#x3D;\frac{R}{r}<br>$$</p>
<p>$$<br>r&#x3D;\sqrt{x^2+R^2}<br>$$</p>
<p>$$<br>B_{&#x2F;&#x2F;}&#x3D;\int dB_{&#x2F;&#x2F;}&#x3D;\int dBsin\theta&#x3D;dB\<br>&#x3D;\int_0^{2\pi R}\frac{\mu_0}{4\pi}\frac{Idl}{r^2}\frac{R}{r}\<br>&#x3D;\frac{\mu_0IR^2}{2\pi(x^2+R^2)^{\frac{3}{2}}}\<br>&#x3D;\frac{\mu_0S}{2\pi(x^2+R^2)^{\frac{3}{2}}}<br>$$</p>
<ul>
<li><p>当x&#x3D;0时：<br>$$<br>B_0&#x3D;\frac{\mu_0I}{2R}<br>$$</p>
</li>
<li><p>当x&gt;&gt;R时：R&#x3D;0</p>
</li>
</ul>
<p>$$<br>B<br>&#x3D;\frac{\mu_0IR^2}{2 x^3}\<br>&#x3D;\frac{\mu_0S}{2\pi x^3}<br>$$</p>
<p>这里引入载流线圈的磁矩$P_m$有：<br>$$<br>P_m&#x3D;ISe_n\ \ \ \ \ \ or\ \ \ \ \ P_m&#x3D;NISe_n<br>$$</p>
<h4 id="4-3-载流密绕直螺线管内部磁场"><a href="#4-3-载流密绕直螺线管内部磁场" class="headerlink" title="4.3. 载流密绕直螺线管内部磁场"></a>4.3. 载流密绕直螺线管内部磁场</h4><p>推导：</p>
<p>设半径为$R$，通电流$I$,单位长度绕有n匝线圈，求o电处的磁感应强度<br>$$<br>由上个知识的公式得知：dB&#x3D;\frac{\mu_0}{2}\frac{nIR^2dx}{(x^2+R^2)^{\frac{3}{2}}}<br>$$<br>因为上下的原因，导致所有的磁感应强度方向相同都向右，整个磁感应强度为B<br>$$<br>B&#x3D;\int dB&#x3D;\int_{x_1}^{x_2}\frac{\mu_0}{2}\frac{nIR^2dx}{(x^2+R^2)^{\frac{3}{2}}}<br>$$<br>所以得：<br>$$<br>B&#x3D;\frac{1}{2}\mu_0nI(cos\beta_2 -cos\beta_1)<br>$$<br>当为无线长直螺线管有：<br>$$<br>\beta_1&#x3D;0,\beta_2&#x3D;\pi;所以：B&#x3D;\mu_0nI<br>$$<br>当为半无线直导线的有段或左端有：<br>$$<br>B&#x3D;\frac{1}{2}\mu_0nI<br>$$</p>
<h3 id="5-运动电荷产生的磁场"><a href="#5-运动电荷产生的磁场" class="headerlink" title="5. 运动电荷产生的磁场"></a>5. 运动电荷产生的磁场</h3><p>由<br>$$<br>dB&#x3D;\frac{\mu_0}{4\pi}\frac{Idlsin\theta}{r^2}\ \ \ \ \ 和 \ \ \ \ \ I&#x3D;nqvS<br>$$<br>所以可以得到：<br>$$<br>dB&#x3D;\frac{\mu_0}{4\pi}\frac{nqvSdlsin\theta}{r^2}<br>$$</p>
<p>$$<br>dN&#x3D;nSdl<br>$$</p>
<p>又有如下的公式：<br>$$<br>B&#x3D;\frac{dB}{dN}&#x3D;\frac{\mu_0}{4\pi}\frac{qvsin\theta}{r^2}&#x3D;\frac{\mu_0}{4\pi}\frac{qV\times r}{r^3}<br>$$<br>所以：<br>$$<br>B&#x3D;\frac{\mu_0}{4\pi}\frac{qV\times r}{r^3}<br>$$</p>
<h3 id="6-真空磁场的高斯定理"><a href="#6-真空磁场的高斯定理" class="headerlink" title="6. 真空磁场的高斯定理"></a>6. 真空磁场的高斯定理</h3><h4 id="6-1-磁通量-Phi-m"><a href="#6-1-磁通量-Phi-m" class="headerlink" title="6.1. 磁通量 $\Phi_m$"></a>6.1. 磁通量 $\Phi_m$</h4><p>$$<br>B&#x3D;\frac{d\Phi_m}{dS_\perp}<br>$$</p>
<p>$$<br>d\Phi_m&#x3D;B\cdot dS<br>$$</p>
<h4 id="6-2-高斯定理"><a href="#6-2-高斯定理" class="headerlink" title="6.2. 高斯定理"></a>6.2. 高斯定理</h4><p>$$<br>\oint _sBdS&#x3D;0<br>$$</p>
<h3 id="7-真空恒定磁场安培环路定理"><a href="#7-真空恒定磁场安培环路定理" class="headerlink" title="7. 真空恒定磁场安培环路定理"></a>7. 真空恒定磁场安培环路定理</h3><p>沿任何路径L一周的B矢量线积分&#x3D;闭合路径内包含并穿过的电流代数和的$\mu_0$倍，与路径形状无关。<br>$$<br>\oint B\cdot dl&#x3D;\mu_0\sum_iI_i<br>$$<br>方向的确定：<br>$$<br>对于包围的电流I，当电流与积分路径绕行方向成右手螺旋关系时，电流为正，反之为负。<br>$$</p>
<h4 id="7-1-无线长圆柱导体磁场"><a href="#7-1-无线长圆柱导体磁场" class="headerlink" title="7.1 无线长圆柱导体磁场"></a>7.1 无线长圆柱导体磁场</h4><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/wl15.png" alt="wl15" style="zoom:75%;" />
$$
\oint_LB\cdot dl=2\pi rB=\mu_0I
$$
所以得到：
$$
B=\frac{\mu_0I}{2\pi r}  ,r>R
$$
当$r<R$时：
$$
2\pi rB= \sum_i I_i=\frac{\pi r^2}{\pi R^2}I
$$
所以总的有：
$$
实心圆柱：B=
\left\{\begin{matrix}
 0&,r<R \\ 
 \frac{\mu_0 rI}{2\pi R^2}&\ \ \ ,r<=R \\ 
\frac{\mu_0I}{2\pi r} & ,r>R
\end{matrix}\right.
$$

<p>$$<br>空心圆柱：B&#x3D;<br>\left{\begin{matrix}<br> 0&amp;,r&lt;R \<br>\frac{\mu_0I}{2\pi r} &amp; ,r&gt;&#x3D;R<br>\end{matrix}\right.<br>$$</p>
<h4 id="7-2-长直载流螺线管内的磁场分布"><a href="#7-2-长直载流螺线管内的磁场分布" class="headerlink" title="7.2. 长直载流螺线管内的磁场分布"></a>7.2. 长直载流螺线管内的磁场分布</h4><p>$$<br>\oint_LB\cdot dl&#x3D;\int_{AB}B\cdot dl+\int_{BC}B\cdot dl+\int_{CD}B\cdot dl+\int_{DA}B\cdot dl<br>$$</p>
<p>$$<br>\int_{AB}B\cdot dl&#x3D;B\overline{AB}<br>$$</p>
<p>$$<br>\because BC、AD垂直与B，而<br>CD处：B&#x3D;0<br>$$</p>
<p>所以可以得到：<br>$$<br>\oint_LB\cdot dl&#x3D;\int_{AB}B\cdot dl&#x3D;\mu_0I(n\overline{AB})<br>$$</p>
<p>$$<br>B&#x3D;\mu_0nI<br>$$</p>
<h4 id="7-3-载流螺绕环的磁分布"><a href="#7-3-载流螺绕环的磁分布" class="headerlink" title="7.3. 载流螺绕环的磁分布"></a>7.3. 载流螺绕环的磁分布</h4><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/wl17.png" alt="wl17"></p>
<p>$$<br>\oint_LB\cdot dl&#x3D;B\cdot2\pi r&#x3D;\mu_0NI<br>$$<br>所以求得：<br>$$<br>B&#x3D;\frac{\mu_0NI}{2\pi r},R-\frac{d}{2}&lt;r&lt;R+\frac{d}{2}<br>$$<br>d为大环半径-小环半径</p>
<p>当环很细的时候，R很大，即R&gt;&gt;d,可认为r约等于R。令$n&#x3D;\frac{N}{2\pi R}$</p>
<p>所以得：<br>$$<br>B&#x3D;\frac{\mu_0NI}{2\pi R}&#x3D;\mu_0nI<br>$$</p>
<h3 id="8-磁场对运动电荷和载流导线作用"><a href="#8-磁场对运动电荷和载流导线作用" class="headerlink" title="8. 磁场对运动电荷和载流导线作用"></a>8. 磁场对运动电荷和载流导线作用</h3><h4 id="8-1-洛伦兹力"><a href="#8-1-洛伦兹力" class="headerlink" title="8.1. 洛伦兹力"></a>8.1. 洛伦兹力</h4><p>$$<br>F&#x3D;qB\times v &#x3D; qvBsin\theta<br>$$</p>
<p>v X B 为方向，由电荷为正，方向不变；电荷为负，方向相反</p>
<p>高中记法：<br>$$<br>F&#x3D;qvB<br>$$</p>
<h4 id="8-2-带点粒子在磁场运动"><a href="#8-2-带点粒子在磁场运动" class="headerlink" title="8.2. 带点粒子在磁场运动"></a>8.2. 带点粒子在磁场运动</h4><p>$$<br>F&#x3D;qvB&#x3D;m\frac{v^2}{R}<br>$$</p>
<p>所以<br>$$<br>R&#x3D;\frac{mv}{qB}<br>$$</p>
<p>$$<br>T&#x3D;\frac{2\pi R}{v_0}&#x3D;\frac{2\pi m}{qB}<br>$$</p>
<h4 id="8-3-应用"><a href="#8-3-应用" class="headerlink" title="8.3. 应用"></a>8.3. 应用</h4><ul>
<li>速度选择器：</li>
</ul>
<p>$F&#x3D;Eq&#x3D;qvB$ 所以有：$V&#x3D;\frac{E}{B}$</p>
<p>核质比：$\frac{q}{m}$</p>
<ul>
<li>霍尔元件</li>
</ul>
<p>$I&#x3D;qnvs$</p>
<h4 id="8-4-安培力"><a href="#8-4-安培力" class="headerlink" title="8.4. 安培力"></a>8.4. 安培力</h4><p>只与始末位置有关,与路径无关:</p>
<p>高中记法：<br>$$<br>F&#x3D;BIL<br>$$</p>
<p>$$<br>F&#x3D;IL\times B<br>$$</p>
<p>微分形式：<br>$$<br>dF&#x3D;Idl\times B<br>$$</p>
<p>$$<br>F&#x3D;\int Idl\times B<br>$$</p>
<h4 id="8-5-磁力矩"><a href="#8-5-磁力矩" class="headerlink" title="8.5. 磁力矩"></a>8.5. 磁力矩</h4><p>磁矩:<br>$$<br>P_m&#x3D;IS_{en}<br>$$<br>磁力矩:<br>$$<br>M&#x3D;P_m\times B<br>$$</p>
<h3 id="9-磁力做功"><a href="#9-磁力做功" class="headerlink" title="9. 磁力做功"></a>9. 磁力做功</h3><h4 id="9-1-长载流直导线"><a href="#9-1-长载流直导线" class="headerlink" title="9.1. 长载流直导线"></a>9.1. 长载流直导线</h4><p>$$<br>W&#x3D;F\Delta x&#x3D;BIL\times\Delta x &#x3D;I B\Delta S&#x3D;I\Delta \Phi_m<br>$$</p>
<p> 所以<br>$$<br>W&#x3D;I\Delta \Phi_m<br>$$<br>积分形式:<br>$$<br>W&#x3D;\int_{\Phi_{m1}}^{\Phi_{m2}}Id{\Phi_{m}}<br>$$</p>
<h3 id="10-介质中磁化强度"><a href="#10-介质中磁化强度" class="headerlink" title="10. 介质中磁化强度"></a>10. 介质中磁化强度</h3><p>为介质产生的磁化强度,不考虑其他<br>$$<br>\oint_LM\cdot dl&#x3D;\sum_{L内}I_s<br>$$</p>
<h3 id="11-磁介质中的高斯定理"><a href="#11-磁介质中的高斯定理" class="headerlink" title="11. 磁介质中的高斯定理"></a>11. 磁介质中的高斯定理</h3><p>$$<br>\oint_SB\cdot dS&#x3D;0<br>$$</p>
<h3 id="12-磁介质中的安培环路定理"><a href="#12-磁介质中的安培环路定理" class="headerlink" title="12. 磁介质中的安培环路定理"></a>12. 磁介质中的安培环路定理</h3><p>$$<br>\oint_LB\cdot dl&#x3D;\mu_0(\sum I+\sum_{L内}I_s)<br>$$</p>
<p>$$<br>\oint_LB\cdot dl&#x3D;\mu_0(\sum I+\oint_LM\cdot dl)<br>$$</p>
<p>所以整理有:<br>$$<br>\oint_L(\frac{B}{\mu_0}-M)\cdot dl&#x3D;\sum I<br>$$<br>所以有:<br>$$<br>\oint_LH\cdot dl&#x3D;\sum I<br>$$<br>因为:磁化强度&#x3D;磁化率*总的磁场强度 有:<br>$$<br>M&#x3D;\chi_mH<br>$$<br>所以:<br>$$<br>B&#x3D;\mu_0H+\mu_0M&#x3D;\mu_0(1+\chi_m)H<br>$$<br>令:$\mu_r&#x3D;(1+\chi_m)$ 所以有:<br>$$<br>B&#x3D;\mu_0\mu_rH&#x3D;\mu H<br>$$</p>
<h3 id="13-电磁感应定律"><a href="#13-电磁感应定律" class="headerlink" title="13. 电磁感应定律"></a>13. 电磁感应定律</h3><h4 id="13-1-法拉第电磁感应定律"><a href="#13-1-法拉第电磁感应定律" class="headerlink" title="13.1. 法拉第电磁感应定律"></a>13.1. 法拉第电磁感应定律</h4><p>右手螺旋</p>
<p>感应电动势:<br>$$<br>E&#x3D;-N\frac{d\Phi_m}{dt}&#x3D;-N\frac{d(BS)}{dt}<br>$$</p>
<h4 id="13-2-楞次定律"><a href="#13-2-楞次定律" class="headerlink" title="13.2. 楞次定律"></a>13.2. 楞次定律</h4><p>增减反同\来拒去留\增缩减阔</p>
<p>阻碍磁场的变化</p>
<h3 id="14-动生电动势"><a href="#14-动生电动势" class="headerlink" title="14. 动生电动势"></a>14. 动生电动势</h3><p>产生的原因:洛伦磁力<br>$$<br>电动势:E_压&#x3D;\int E_场dl<br>$$</p>
<p>$$<br>E_场&#x3D;\frac{F_{洛}}{q}<br>$$</p>
<p>$$<br>F_{洛}&#x3D;qv\times B<br>$$</p>
<p>所以有:<br>$$<br>E_压&#x3D;\int (v\times B) dl<br>$$<br>高中为$E&#x3D;Blv$</p>
<h3 id="15-感生电动势"><a href="#15-感生电动势" class="headerlink" title="15. 感生电动势"></a>15. 感生电动势</h3><p>$$<br>E&#x3D;\oint_L E_{感}\cdot dl&#x3D;-\frac{d \Phi_m}{dt}<br>$$</p>
<p>又有:<br>$$<br>\Phi_m&#x3D;\iint_SB\cdot dS<br>$$<br>所以:<br>$$<br>\oint_L E_{感}\cdot dl&#x3D;-\iint_S\frac{\partial B}{\partial t}\cdot dS<br>$$</p>
<h3 id="16-自感"><a href="#16-自感" class="headerlink" title="16. 自感"></a>16. 自感</h3><p>$$<br>U&#x3D;-L\frac{dI}{dt}<br>$$</p>
<p>所以:<br>$$<br>L&#x3D;\frac{\phi}{I} \ \ \ \ \phi为全磁通<br>$$</p>
<p>$$<br>L&#x3D;-U\frac{dI}{dt}<br>$$</p>
<h3 id="17-互感"><a href="#17-互感" class="headerlink" title="17. 互感"></a>17. 互感</h3><p>$$<br>M&#x3D;\frac{\phi_{21}}{I_1}\ \ \ or\ \ \ M&#x3D;-U_{21}\frac{dI_1}{dt}<br>$$</p>
<h3 id="18-位移电流的引入"><a href="#18-位移电流的引入" class="headerlink" title="18. 位移电流的引入"></a>18. 位移电流的引入</h3><p>$$<br>\oint_LH\cdot dl&#x3D;I<br>$$</p>
<p>但当包括的变为电容后,<br>$$<br>I_d&#x3D;\iint_S\delta_d\cdot dS&#x3D;\iint_S\frac{\partial D}{\partial t}\cdot dS<br>$$<br>则全电流为:<br>$$<br>I_{全电流}&#x3D;I_{传导电流}+I_{位移电流}<br>$$</p>
<p>$$<br>\oint_LH\cdot dl&#x3D;\iint_s\delta_0\cdot dS+\iint_S\frac{\partial D}{\partial t}\cdot dS<br>$$</p>
<h3 id="19-麦克斯韦方程组与电磁波"><a href="#19-麦克斯韦方程组与电磁波" class="headerlink" title="19. 麦克斯韦方程组与电磁波"></a>19. 麦克斯韦方程组与电磁波</h3><p>$$<br>\oint_l H\cdot dl&#x3D;\iint_s(\delta+\frac{\partial D}{\partial t})\cdot dS<br>$$</p>
<p>$$<br>\oint_LE\cdot dl&#x3D;-\iint_S\frac{\partial B}{\partial t}\cdot dS<br>$$</p>
<p>$$<br>\oiint_SD\cdot dS&#x3D;\sum_Iq_i<br>$$</p>
<p>$$<br>\oiint_SB\cdot dS&#x3D;0<br>$$</p>
<h2 id="力学"><a href="#力学" class="headerlink" title="力学"></a>力学</h2><h3 id="位移速度加速度"><a href="#位移速度加速度" class="headerlink" title="位移速度加速度"></a>位移速度加速度</h3><p>微分形式：<br>$$<br>v&#x3D;\frac{dx}{dt}\ \ \ \ \ \ \ \ \ \ \ \ \ 有:x-x_0&#x3D;\int_0^tvdt<br>$$</p>
<p>$$<br>a&#x3D;\frac{dv}{dt}\ \ \ \ \ \ \ \ \ \ \ \ \ 有:v-v_0&#x3D;\int_0^tadt<br>$$</p>
<h3 id="曲率半径"><a href="#曲率半径" class="headerlink" title="曲率半径"></a>曲率半径</h3><p>$$<br>a_n&#x3D;\frac{v^2}{\rho},所以\rho&#x3D;\frac{v^2}{a_n}<br>$$</p>
<h3 id="圆周运动"><a href="#圆周运动" class="headerlink" title="圆周运动"></a>圆周运动</h3><p>$$<br>v&#x3D;R\omega<br>$$</p>
<p>$$<br>\omega &#x3D;\frac{d\theta}{dt}<br>$$</p>
<p>$$<br>\beta&#x3D;\frac{d\omega}{dt}&#x3D;\frac{d^2\theta}{dt^2}<br>$$</p>
<p>$$<br>a&#x3D;a_n+a_t&#x3D;\frac{v^2}{R}e_n+\frac{dv}{dt}e_t&#x3D;\omega^2Re_n+R\beta e_t<br>$$</p>
<p>更多公式在对比公式里面</p>
<h3 id="牛顿运动定律"><a href="#牛顿运动定律" class="headerlink" title="牛顿运动定律"></a>牛顿运动定律</h3><h4 id="第一"><a href="#第一" class="headerlink" title="第一"></a>第一</h4><p>惯性</p>
<h4 id="第二"><a href="#第二" class="headerlink" title="第二"></a>第二</h4><p>$$<br>F&#x3D;m\frac{dv}{dt}&#x3D;ma<br>$$</p>
<h4 id="第三"><a href="#第三" class="headerlink" title="第三"></a>第三</h4><p>$$<br>F&#x3D;-F’<br>$$</p>
<h3 id="万有引力"><a href="#万有引力" class="headerlink" title="万有引力"></a>万有引力</h3><p>$$<br>F_{12}&#x3D;-G\frac{m_1m_2}{r^2}e_r<br>$$</p>
<h3 id="重力"><a href="#重力" class="headerlink" title="重力"></a>重力</h3><p>$$<br>G\frac{Mm}{R^2}&#x3D;mg<br>$$</p>
<p>所以：<br>$$<br>g&#x3D;G\frac{M}{R^2}<br>$$</p>
<h3 id="弹簧弹力"><a href="#弹簧弹力" class="headerlink" title="弹簧弹力"></a>弹簧弹力</h3><p>$$<br>f&#x3D;-k(x_1-x_0)<br>$$</p>
<h3 id="摩擦力"><a href="#摩擦力" class="headerlink" title="摩擦力"></a>摩擦力</h3><p>$$<br>f&#x3D;\mu mg<br>$$</p>
<h3 id="动量及冲量"><a href="#动量及冲量" class="headerlink" title="动量及冲量"></a>动量及冲量</h3><p>动量<br>$$<br>p&#x3D;mv<br>$$<br>冲量<br>$$<br>Fdt&#x3D;dp<br>$$<br>所以积分形式<br>$$<br>I&#x3D;\int_{t_0}^{t}F(t)dt&#x3D;\int_{p_0}^{p}dp&#x3D;p-p_0<br>$$</p>
<h3 id="动量守恒"><a href="#动量守恒" class="headerlink" title="动量守恒"></a>动量守恒</h3><p>$$<br>m_0v_0&#x3D;m_1v_1+m_2v_2<br>$$</p>
<p>或有：<br>$$<br>Ft&#x3D;mv-mv<br>$$</p>
<h3 id="功-、-能"><a href="#功-、-能" class="headerlink" title="功  、 能"></a>功  、 能</h3><p>$$<br>做功：W&#x3D;Fs<br>$$</p>
<p>$$<br>平均功率：\overline{P}&#x3D;\frac{\Delta W}{\Delta t}<br>$$</p>
<p>瞬时功率：<br>$$<br>P&#x3D;\frac{dW}{dt}&#x3D;\frac{d(Fs)}{dt}&#x3D;Fv<br>$$<br>重力做功：<br>$$<br>W&#x3D;mg\Delta h<br>$$<br>弹簧弹力做功<br>$$<br>W&#x3D;\int_{x_1}^{x_2}-kxdx&#x3D;\frac{1}{2}kx_1^2-\frac{1}{2}kx_2^2<br>$$<br>万有引力做功<br>$$<br>W&#x3D;\int_{r_1}^{r_2}(-G\frac{Mm}{r^2})dr&#x3D;GMm(\frac{1}{r_2}-\frac{1}{r_1})<br>$$<br>摩擦力做功:<br>$$<br>W&#x3D;\int Fds&#x3D;\int \mu mgds&#x3D;\mu mgs<br>$$</p>
<h3 id="动能定理"><a href="#动能定理" class="headerlink" title="动能定理"></a>动能定理</h3><p>$$<br>E_k&#x3D;\frac{1}{2}mv^2<br>$$</p>
<p>$$<br>W&#x3D;\frac{1}{2}mv_1^2-\frac{1}{2}mv_0^2<br>$$</p>
<h3 id="势能"><a href="#势能" class="headerlink" title="势能"></a>势能</h3><p>$$<br>W&#x3D;-\Delta E_p<br>$$</p>
<p>重力势能:<br>$$<br>E&#x3D;mgh<br>$$<br>弹性势能：<br>$$<br>E&#x3D;\frac{1}{2}k\Delta x^2<br>$$<br>万有引力势能：<br>$$<br>E&#x3D;\int_e^\infty (-G\frac{Mm}{r^2})dr&#x3D;-G\frac{Mm}{r}<br>$$</p>
<h3 id="机械能守恒"><a href="#机械能守恒" class="headerlink" title="机械能守恒"></a>机械能守恒</h3><p>$$<br>\sum W_外+\sum W_{内非保守}&#x3D;0<br>$$</p>
<h3 id="力矩"><a href="#力矩" class="headerlink" title="力矩"></a>力矩</h3><p>$$<br>M&#x3D;r\times F<br>$$</p>
<h3 id="角动量"><a href="#角动量" class="headerlink" title="角动量"></a>角动量</h3><p>$$<br>L&#x3D;r\times p&#x3D;r\times mv&#x3D;m\omega r^2<br>$$</p>
<p>关系：<br>$$<br>M&#x3D;\frac{dL}{dt}\ \ \ \ \ \ \ \ \ \ \ \ \ 角冲量：\int_{t_0}^{t}M dt&#x3D;L-L_0<br>$$</p>
<h3 id="角动量守恒"><a href="#角动量守恒" class="headerlink" title="角动量守恒"></a>角动量守恒</h3><p>$$<br>L&#x3D;r\times p&#x3D;r\times mv&#x3D;C_{常数}<br>$$</p>
<h3 id="角动量定理-守恒"><a href="#角动量定理-守恒" class="headerlink" title="角动量定理+守恒"></a>角动量定理+守恒</h3><p>所有的内力矩之和为0</p>
<p>$L&#x3D;L_0&#x3D;C_{常数}$</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="对比使用公式"><a href="#对比使用公式" class="headerlink" title="对比使用公式"></a>对比使用公式</h2><table>
<thead>
<tr>
<th>力矩</th>
<th>$M&#x3D;FS$</th>
</tr>
</thead>
<tbody><tr>
<td>电矩</td>
<td>$P&#x3D;ql$</td>
</tr>
<tr>
<td>磁矩</td>
<td>$P_m&#x3D;IS_{en}$</td>
</tr>
</tbody></table>
<p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/WL9.png" alt="WL9"></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">$F&#x3D;Eq$</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">$W&#x3D;Fd$</td>
<td align="center"></td>
<td>$U&#x3D;Ed$</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">$W&#x3D;qU$</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><em><strong>高斯公式</strong></em></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>电场</strong></td>
<td></td>
<td><strong>磁场</strong></td>
<td></td>
</tr>
<tr>
<td>真空</td>
<td>$\oint _sEdS&#x3D;\frac{1}{\varepsilon _0}\sum_i q_i$</td>
<td>真空</td>
<td>$\oint _sBdS&#x3D;0$</td>
</tr>
<tr>
<td>有介质</td>
<td>$\oint <em>sDdS&#x3D;\oint_S \varepsilon_r\varepsilon_0E</em>{介质}\cdot dS&#x3D; \sum_i q_i$</td>
<td>有介质</td>
<td>$\oint_SB\cdot dS&#x3D;0$</td>
</tr>
<tr>
<td><em><strong>环路积分</strong></em></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>电场</strong></td>
<td>相当于做功</td>
<td><strong>磁场</strong></td>
<td></td>
</tr>
<tr>
<td>真空</td>
<td>$\oint_LEqdl&#x3D;\oint_L Edl&#x3D;0$</td>
<td>真空</td>
<td>$\oint B\cdot dl&#x3D;\mu_0\sum_iI_i$</td>
</tr>
<tr>
<td>有介质</td>
<td>$\oint_L Edl&#x3D;0$</td>
<td>有介质</td>
<td>$\oint_LH\cdot dl&#x3D;\sum I$</td>
</tr>
<tr>
<td>$D&#x3D;\varepsilon_r\varepsilon_0E_{介质}$</td>
<td></td>
<td>$H&#x3D;\frac{B}{\mu_r\mu_0}$</td>
<td></td>
</tr>
</tbody></table>
<p>$$<br>安培力:F&#x3D;BIL  \洛伦茨力:F&#x3D;q_0vB\感应电动势:E&#x3D;BLV<br>$$</p>
<table>
<thead>
<tr>
<th>圆周运动</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>位移</td>
<td>$s$</td>
<td>角度</td>
<td>$\theta$</td>
</tr>
<tr>
<td>速度</td>
<td>$v$</td>
<td>角速度</td>
<td>$\omega$</td>
</tr>
<tr>
<td>加速度</td>
<td>$\alpha$</td>
<td>角加速度</td>
<td>$\beta$</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>$x_t&#x3D;x_0+v_0t+\frac{1}{2}a t^2$</th>
<th>$\theta_t&#x3D;\theta_0+\omega_0t+\frac{1}{2}\beta t^2$</th>
</tr>
</thead>
<tbody><tr>
<td>$v_t&#x3D;v_0+at$</td>
<td>$\omega_t&#x3D;\omega_0+\beta t$</td>
</tr>
<tr>
<td>$\omega^2-\omega_0^2&#x3D;2\beta (\theta-\theta_0)$</td>
<td>$v^2-v_0^2&#x3D;2a (x-x_0)$</td>
</tr>
<tr>
<td>$v &#x3D;\frac{dx}{dt}$</td>
<td>$\omega &#x3D;\frac{d\theta}{dt}$</td>
</tr>
<tr>
<td>$a&#x3D;\frac{dv}{dt}&#x3D;\frac{d^2x}{dt^2}$</td>
<td>$\beta&#x3D;\frac{d\omega}{dt}&#x3D;\frac{d^2\theta}{dt^2}$</td>
</tr>
</tbody></table>
<p>转换公式：</p>
<p>$v&#x3D;\omega R$</p>
<p>$a&#x3D;a_n+a_t&#x3D;\frac{v^2}{R}e_n+\frac{dv}{dt}e_t&#x3D;\omega^2Re_n+R\beta e_t$</p>
<p>力：F</p>
<p>力矩：$M&#x3D;r\times F$</p>
<p>动量：$p&#x3D;mv$</p>
<p>角动量:$L&#x3D;r\times p&#x3D;r\times mv&#x3D;m\omega r^2$</p>
<p>冲量：$I&#x3D;\int_{t_0}^{t}F(t)dt&#x3D;\int_{p_0}^{p}dp&#x3D;p-p_0$</p>
<p>角冲量：$\int_{t_0}^{t}M dt&#x3D;L-L_0 $</p>
<p>力矩与角动量:$M&#x3D;\frac{dL}{dt}$</p>
<p>力与动量:$F&#x3D;\frac{dp}{dt}$</p>
<p>转动惯量：$$</p>
]]></content>
      <categories>
        <category>课程学习类</category>
      </categories>
      <tags>
        <tag>课程学习</tag>
      </tags>
  </entry>
  <entry>
    <title>训练分类器</title>
    <url>/archives/a8495978.html</url>
    <content><![CDATA[<h1 id="训练分类器"><a href="#训练分类器" class="headerlink" title="训练分类器"></a>训练分类器</h1><p>数据可以是图像，文本，音频或视频数据，可以将数据加载到Numpy数组中，利用Python包，处理好后再转换为张量。</p>
<ul>
<li>对于图像，Pillow，OpenCV 等包很有用</li>
<li>对于音频，请使用 SciPy 和 librosa 等包</li>
<li>对于文本，基于 Python 或 Cython 的原始加载，或者 NLTK 和 SpaCy 很有用</li>
</ul>
<p><code>torchvision</code>的包中包含很多常用的数据集，（例如 Imagenet，CIFAR10，MNIST 等）的数据加载器，以及用于图像（即<code>torchvision.datasets</code>和<code>torch.utils.data.DataLoader</code>）的数据转换器。</p>
<p>这次利用<code>CIFAR10 数据集</code>,类别：“飞机”，“汽车”，“鸟”，“猫”，“鹿”，“狗”，“青蛙”，“马”，“船”，“卡车”，图像尺寸为<code>3x32x32</code>，<code>32x32</code>像素的 3 通道彩色图像。</p>
<h2 id="训练图像分类器"><a href="#训练图像分类器" class="headerlink" title="训练图像分类器"></a>训练图像分类器</h2><p>我们将按顺序执行以下步骤：</p>
<ol>
<li>使用<code>torchvision</code>加载并标准化 CIFAR10 训练和测试数据集</li>
<li>定义卷积神经网络</li>
<li>定义损失函数</li>
<li>根据训练数据训练网络</li>
<li>在测试数据上测试网络</li>
</ol>
<h3 id="1-加载并标准化-CIFAR10"><a href="#1-加载并标准化-CIFAR10" class="headerlink" title="1.加载并标准化 CIFAR10"></a>1.加载并标准化 CIFAR10</h3><p>使用<code>torchvision</code>，加载 CIFAR10 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br></pre></td></tr></table></figure>

<p>TorchVision 数据集的输出是<code>[0, 1]</code>范围的<code>PILImage</code>图像。 我们将它们转换为归一化范围<code>[-1, 1]</code>的张量。</p>
<h3 id="2-定义卷积神经网络"><a href="#2-定义卷积神经网络" class="headerlink" title="2.定义卷积神经网络"></a>2.定义卷积神经网络</h3><h3 id="3-定义损失函数和优化器"><a href="#3-定义损失函数和优化器" class="headerlink" title="3.定义损失函数和优化器"></a>3.定义损失函数和优化器</h3><h3 id="4-训练网络"><a href="#4-训练网络" class="headerlink" title="4.训练网络"></a>4.训练网络</h3><h3 id="5-根据测试数据测试网络"><a href="#5-根据测试数据测试网络" class="headerlink" title="5.根据测试数据测试网络"></a>5.根据测试数据测试网络</h3><h3 id="在-GPU-上进行训练"><a href="#在-GPU-上进行训练" class="headerlink" title="在 GPU 上进行训练"></a>在 GPU 上进行训练</h3>]]></content>
      <categories>
        <category>算法类</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络</title>
    <url>/archives/7ca31f7.html</url>
    <content><![CDATA[<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p><img src="https://pytorch.apachecn.org/docs/1.7/img/3250cbba812d68265cf7815d987bcd1b.png" alt="convnet"></p>
<h2 id="卷积网"><a href="#卷积网" class="headerlink" title="卷积网"></a>卷积网</h2><p>这是一个简单的前馈网络。 它获取输入，将其一层又一层地馈入，然后最终给出输出。</p>
<p>神经网络的典型训练过程如下：</p>
<ul>
<li>定义具有一些可学习参数（或权重）的神经网络</li>
<li>遍历输入数据集</li>
<li>通过网络处理输入</li>
<li>计算损失（输出正确的距离有多远）</li>
<li>将梯度传播回网络参数</li>
<li>通常使用简单的更新规则来更新网络的权重：<code>weight = weight - learning_rate * gradient</code></li>
</ul>
<h2 id="定义网络"><a href="#定义网络" class="headerlink" title="定义网络"></a>定义网络</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 1个输入图像通道，6个输出通道，5x5平方卷积</span></span><br><span class="line">        <span class="comment"># kernel 内核</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># an affine operation: y = Wx + b</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)  <span class="comment"># 图像尺寸为5*5</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># (2, 2)窗口上的最大池化</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 如果大小是正方形，则可以指定一个数字</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 压平除批量尺寸外的所有尺寸</span></span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>) </span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line"><span class="built_in">print</span>(net)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>super()</strong> 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。</p>
</blockquote>
<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Net(</span><br><span class="line">  (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1))</span><br><span class="line">  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))</span><br><span class="line">  (fc1): Linear(in_features=400, out_features=120, bias=True)</span><br><span class="line">  (fc2): Linear(in_features=120, out_features=84, bias=True)</span><br><span class="line">  (fc3): Linear(in_features=84, out_features=10, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>只需要定义<code>forward</code>函数，就可以使用<code>autograd</code>自动定义<code>backward</code>函数（计算梯度）。 </p>
<p>模型的可学习参数由<code>net.parameters()</code>返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = <span class="built_in">list</span>(net.parameters())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(params))</span><br><span class="line"><span class="built_in">print</span>(params[<span class="number">0</span>].size())  <span class="comment"># conv1&#x27;s .weight</span></span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line">torch.Size([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>



<p>让我们尝试一个<code>32x32</code>随机输入。 </p>
<blockquote>
<p> 注意：该网络的预期输入大小（LeNet）为<code>32x32</code>。 要在 MNIST 数据集 上使用此网络，请将图像从数据集中调整为<code>32x32</code>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 1个输入图像通道，6个输出通道，5x5平方卷积</span></span><br><span class="line">        <span class="comment"># kernel 内核</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># an affine operation: y = Wx + b</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)  <span class="comment"># 图像尺寸为5*5</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># (2, 2)窗口上的最大池化</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 如果大小是正方形，则可以指定一个数字</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 压平除批量尺寸外的所有尺寸</span></span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line"><span class="comment">###################################  与上文相同   ##############################</span></span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">out = net(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(out)</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tensor([[ <span class="number">0.0265</span>,  <span class="number">0.0280</span>,  <span class="number">0.0228</span>,  <span class="number">0.1131</span>,  <span class="number">0.0270</span>, -<span class="number">0.1227</span>,  <span class="number">0.0928</span>,  <span class="number">0.0028</span>,</span><br><span class="line">          <span class="number">0.0389</span>, -<span class="number">0.0410</span>]], grad_fn=&lt;AddmmBackward&gt;)</span><br></pre></td></tr></table></figure>



<p>使用随机梯度将所有参数和反向传播的梯度缓冲区归零：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">out.backward(torch.randn(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>torch.nn</code>仅支持小批量。 整个<code>torch.nn</code>包仅支持作为微型样本而不是单个样本的输入。</p>
</blockquote>
<ul>
<li><code>torch.Tensor</code>-一个<em>多维数组</em>，支持诸如<code>backward()</code>的自动微分操作。 同样，保持相对于张量的梯度。</li>
<li><code>nn.Module</code>-神经网络模块。 <em>封装参数</em>的便捷方法，并带有将其移动到 GPU，导出，加载等的帮助器。</li>
<li><code>nn.Parameter</code>-一种张量，即将其分配为<code>Module</code>的属性时，自动注册为参数。</li>
<li><code>autograd.Function</code>-实现自动微分操作的正向和反向定义。 每个<code>Tensor</code>操作都会创建至少一个<code>Function</code>节点，该节点连接到创建<code>Tensor</code>的函数，并且编码其历史记录。</li>
</ul>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>损失函数采用一对（输出，目标）输入，并计算一个值，该值估计输出与目标之间的距离。</p>
<p><code>nn</code>包下有几种不同的<a href="https://pytorch.org/docs/nn.html#loss-functions">损失函数</a>。 一个简单的损失是：<code>nn.MSELoss</code>，它计算输入和目标之间的均方误差。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = net(<span class="built_in">input</span>)</span><br><span class="line">target = torch.randn(<span class="number">10</span>)  <span class="comment"># 一个虚拟目标</span></span><br><span class="line">target = target.view(<span class="number">1</span>, -<span class="number">1</span>)  <span class="comment"># 使它与输出相同的形状</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">loss = criterion(output, target)</span><br><span class="line"><span class="built_in">print</span>(loss)</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor(1.1649, grad_fn=&lt;MseLossBackward0&gt;)</span><br></pre></td></tr></table></figure>



<p>现在，如果使用<code>.grad_fn</code>属性向后跟随<code>loss</code>，您将看到一个计算图，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d</span><br><span class="line">      -&gt; view -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear</span><br><span class="line">      -&gt; MSELoss</span><br><span class="line">      -&gt; loss</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>loss.backward()</code>时，整个图将被微分。图中具有<code>requires_grad=True</code>的所有张量将随梯度累积其<code>.grad</code>张量</p>
<p>让我们向后走几步：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(loss.grad_fn)  <span class="comment"># MSELoss</span></span><br><span class="line"><span class="built_in">print</span>(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>])  <span class="comment"># Linear</span></span><br><span class="line"><span class="built_in">print</span>(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>].next_functions[<span class="number">0</span>][<span class="number">0</span>])  <span class="comment"># ReLU</span></span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MseLossBackward0 object at 0x7f71283dd048&gt;</span><br><span class="line">&lt;AddmmBackward0 object at 0x7f71283dd7f0&gt;</span><br><span class="line">&lt;AccumulateGrad object at 0x7f71283dd7f0&gt;</span><br></pre></td></tr></table></figure>



<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>要反向传播误差，我们要做的只是对<code>loss.backward()</code>。 不过，需要清除现有的梯度，否则梯度将累积到现有的梯度中。</p>
<p>现在，我们将其称为<code>loss.backward()</code>，然后看一下向后前后<code>conv1</code>的偏差梯度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()     <span class="comment"># 将所有参数的梯度缓冲区归零</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;conv1.bias.grad before backward&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(net.conv1.bias.grad)</span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;conv1.bias.grad after backward&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conv1.bias.grad before backward</span><br><span class="line">tensor([0., 0., 0., 0., 0., 0.])</span><br><span class="line">conv1.bias.grad after backward</span><br><span class="line">tensor([ 0.0188,  0.0172, -0.0044, -0.0141, -0.0058, -0.0013])</span><br></pre></td></tr></table></figure>



<h2 id="更新权重"><a href="#更新权重" class="headerlink" title="更新权重"></a>更新权重</h2><p>实践中使用的最简单的更新规则是  <code>随机梯度下降（SGD）</code>：</p>
<blockquote>
<p>weight &#x3D; weight - learning_rate * gradient</p>
<p>下一次的权重  &#x3D;  本次的权重值 -  学习率  *  梯度（误差）</p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.01</span> 							<span class="comment"># 学习率0.01</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> net.parameters():						<span class="comment"># 遍历与调整</span></span><br><span class="line">    f.data.sub_(f.grad.data * learning_rate)	<span class="comment"># 更新权重</span></span><br></pre></td></tr></table></figure>



<p>在使用神经网络时，您希望使用各种不同的更新规则，如 SGD，Nesterov-SGD，Adam，RMSProp 等……</p>
<p>为实现此目的，我们构建了一个小包装：<code>torch.optim</code>，可实现所有这些方法。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim		<span class="comment"># 引入更新规则包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建您的优化器</span></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在你的训练循环中:</span></span><br><span class="line">optimizer.zero_grad()   <span class="comment"># 将梯度缓冲区归零</span></span><br><span class="line">output = net(<span class="built_in">input</span>)</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()    <span class="comment"># 更新</span></span><br></pre></td></tr></table></figure>

<p>使用<code>optimizer.zero_grad()</code>将梯度缓冲区手动设置为零，这是因为<a href="https://pytorch.apachecn.org/#/docs/1.7/05?id=backprop">反向传播</a>部分中所述累积了梯度。</p>
]]></content>
      <categories>
        <category>算法类</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
