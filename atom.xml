<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Javis&#39;s Blogs</title>
  
  <subtitle>于邦震</subtitle>
  <link href="https://javis-yu.github.io/atom.xml" rel="self"/>
  
  <link href="https://javis-yu.github.io/"/>
  <updated>2022-05-08T17:27:24.741Z</updated>
  <id>https://javis-yu.github.io/</id>
  
  <author>
    <name>于邦震</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://javis-yu.github.io/archives/4a17b156.html"/>
    <id>https://javis-yu.github.io/archives/4a17b156.html</id>
    <published>2022-05-08T16:34:28.389Z</published>
    <updated>2022-05-08T17:27:24.741Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>这是第一个尝试</title>
    <link href="https://javis-yu.github.io/archives/e2465b5f.html"/>
    <id>https://javis-yu.github.io/archives/e2465b5f.html</id>
    <published>2022-05-08T16:34:28.387Z</published>
    <updated>2022-05-08T19:25:55.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="让我看看好看吗？"><a href="#让我看看好看吗？" class="headerlink" title="让我看看好看吗？"></a>让我看看好看吗？</h2><h1 id="感觉不错"><a href="#感觉不错" class="headerlink" title="感觉不错"></a>感觉不错</h1><p>试试看</p><p>666666666666666</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;让我看看好看吗？&quot;&gt;&lt;a href=&quot;#让我看看好看吗？&quot; class=&quot;headerlink&quot; title=&quot;让我看看好看吗？&quot;&gt;&lt;/a&gt;让我看看好看吗？&lt;/h2&gt;&lt;h1 id=&quot;感觉不错&quot;&gt;&lt;a href=&quot;#感觉不错&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LCD1602程序</title>
    <link href="https://javis-yu.github.io/archives/d44ed278.html"/>
    <id>https://javis-yu.github.io/archives/d44ed278.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:35:33.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCD1602"><a href="#LCD1602" class="headerlink" title="LCD1602"></a>LCD1602</h1><p>[toc]</p><p>为什么叫1602呢？</p><p>原因：LCD的显示是2行，每行只有16个字符显示。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk44.jpg" alt="pk44"></p><center>管脚功能</center><table><thead><tr><th>引脚</th><th>符号</th><th>功能说明</th></tr></thead><tbody><tr><td>1</td><td>VSS</td><td>一般接地</td></tr><tr><td>2</td><td>VDD</td><td>接电源（+5V）</td></tr><tr><td>3</td><td>V0</td><td>液晶显示器对比度调整端，接正电源时对比度最弱，接地电源时对比度最高（对比度过高时会产生“鬼影”，使用时可以通过一个10K的电位器调整对比度）。</td></tr><tr><td>4</td><td>RS</td><td>RS为寄存器选择，高电平1时选择数据寄存器、低电平0时选择指令寄存器。</td></tr><tr><td>5</td><td>R&#x2F;W</td><td>R&#x2F;W为读写信号线，高电平(1)时进行读操作，低电平(0)时进行写操作。</td></tr><tr><td>6</td><td>E</td><td>E(或EN)端为使能(enable)端，写操作时，下降沿使能。读操作时，E高电平有效</td></tr><tr><td>7</td><td>DB0</td><td>低4位三态、 双向数据总线 0位（最低位）</td></tr><tr><td>8</td><td>DB1</td><td>低4位三态、 双向数据总线 1位</td></tr><tr><td>9</td><td>DB2</td><td>低4位三态、 双向数据总线 2位</td></tr><tr><td>10</td><td>DB3</td><td>低4位三态、 双向数据总线 3位</td></tr><tr><td>11</td><td>DB4</td><td>高4位三态、 双向数据总线 4位</td></tr><tr><td>12</td><td>DB5</td><td>高4位三态、 双向数据总线 5位</td></tr><tr><td>13</td><td>DB6</td><td>高4位三态、 双向数据总线 6位</td></tr><tr><td>14</td><td>DB7</td><td>高4位三态、 双向数据总线 7位（最高位）（也是busy flag）</td></tr><tr><td>15</td><td>BLA</td><td>背光电源正极 （仿真中没有）</td></tr><tr><td>16</td><td>BLK</td><td>背光 电源负极（仿真中没有）</td></tr></tbody></table><center>显示地址</center><table><thead><tr><th>00H</th><th>01H</th><th>02H</th><th>03H</th><th>04H</th><th>05H</th><th>06H</th><th>07H</th><th>08H</th><th>09H</th><th>0AH</th><th>0BH</th><th>0CH</th><th>0DH</th><th>0EH</th><th>0FH</th></tr></thead><tbody><tr><td>40H</td><td>41H</td><td>42H</td><td>43H</td><td>44H</td><td>45H</td><td>46H</td><td>47H</td><td>48H</td><td>49H</td><td>4AH</td><td>4BH</td><td>4CH</td><td>4DH</td><td>4EH</td><td>4FH</td></tr></tbody></table><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk43.png" alt="pk43"></p><p>本身的原始地址 ：0x80  则要找的地址为：0x80+00  0x80+01 …</p><center>指令</center><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk48.png" alt="pk48"></p><p>常用的指令：</p><p>0x38 : 设置16 * 2显示，5 * 7点阵 ，8位数据接口</p><p>0x0C : 设置开显示 ，不显示光标</p><p>0x06 : 写一个字符后地址指针+1</p><p>0x01 :显示清0   数据指针清0</p><p>0x80 : LCD第一行的起始地址</p><p>0x80+0x40 :  LCD第二行的起始地址</p><center>时序图</center><p>看懂时序图：<a href="https://blog.csdn.net/u010794281/article/details/46273479">https://blog.csdn.net/u010794281/article/details/46273479</a> 可以参考讲解</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk46.png" alt="pk46"></p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk47.png" alt="pk47"></p>]]></content>
    
    
    <summary type="html">51单片机的LCD1602</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Proteus_keil仿真单片机二</title>
    <link href="https://javis-yu.github.io/archives/570258ab.html"/>
    <id>https://javis-yu.github.io/archives/570258ab.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:52:48.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Proteus-keil仿真单片机二"><a href="#Proteus-keil仿真单片机二" class="headerlink" title="Proteus_keil仿真单片机二"></a>Proteus_keil仿真单片机二</h1><p>[toc]</p><h2 id="LED灯的使用及流水灯的实现"><a href="#LED灯的使用及流水灯的实现" class="headerlink" title="LED灯的使用及流水灯的实现"></a>LED灯的使用及流水灯的实现</h2><h3 id="LED灯的介绍"><a href="#LED灯的介绍" class="headerlink" title="LED灯的介绍"></a>LED灯的介绍</h3><p><strong>发光二极管</strong>（LED）：在电路及仪器中作为指示灯，或者组成文字或数字显示。</p><p>单向导通性，导致发光二极管要又PN断点之分，所以就会产生共阴极和共阳极区别（在后面讨论）</p><p>​     <em><strong>控制电流从P端口流向N端口。</strong></em></p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/PK14.png" alt="PK14"></p><p> 许多的广告牌，是由很多个LED灯不断的闪烁，导致一片区域的灯亮起来，然后形成文字的移动等，led灯的使用有很多地方，LED灯几乎是电器必带的一个，总会显示电器的开关或运行。但LED又是最简单的元器件，许多的单片机或开发板，总会以先控制LED来尝试第一个历程。这里我们先不长篇大论的讨论真实的单片机是如何的，但我觉得有必要先讲解不同，为暂时没资金但未来会买单片机的同学有所提示。</p><h4 id="单片机和仿真软件的不同"><a href="#单片机和仿真软件的不同" class="headerlink" title="单片机和仿真软件的不同"></a>单片机和仿真软件的不同</h4><p>1、真实的单片机是已经将电路固定好了，难以改变，我们只能通过外部拓展来来进行我们想要拓展的元器件。但仿真软件的电路是不固定的，可以根据所学的电路分析的知识，来进行电器的连接。这样子我们可以灵活多变的设计电路，这里设计到自己设计PCB板，建议仿真入手，提高理解。</p><p>2.单片机的部分引脚拓展了许多的功能，一个引脚便控制多个器件，这样子大大减少了IO口的使用。仿真软件可以灵活的改变引脚。</p><p>3.单片机的0端，许多会拓展时钟等，但仿真单片机里面已经自带好了时钟。（这里使用时钟什么的都一样使用。）</p><p>未来还会有区别我们在讨论。</p><h2 id="创建流水灯项目"><a href="#创建流水灯项目" class="headerlink" title="创建流水灯项目"></a>创建流水灯项目</h2><p>在keil中创建项目，并创建<code>xx.c</code>文件，并设置好输出hex文件的初始设置。</p><h3 id="流水灯的设计"><a href="#流水灯的设计" class="headerlink" title="流水灯的设计"></a>流水灯的设计</h3><h3 id="Proteus设计电路"><a href="#Proteus设计电路" class="headerlink" title="Proteus设计电路"></a>Proteus设计电路</h3><p>这里使用AT89C51芯片、led（灯）、res（电阻）。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/prj.png" alt="prj"></p><p>选好元器件后，进行摆放。分为共阴极和共阳极（如下）</p><h4 id="共阳极"><a href="#共阳极" class="headerlink" title="共阳极"></a>共阳极</h4><p>右上角的三角符号是这个软件的高电位，即电源。所有的流水灯的阳极都是连接在LED灯的P端口，这样子就是共阳极。</p><p>然后在看左边，电阻是300欧姆，为什么加电阻呢？</p><p>原因很简单，单片机端口是无法承受过大的电流和电压的，电阻是防止过大，导致烧坏芯片；但倘若电阻过大，led灯也可能会不亮。</p><p>然后在向左边，这个东西很简单，就是一个端口，两个同名的端口提高命名的方法连接（连接方式在附录），这样子电气图便可以按区块分布。这里我使用了0端口的0~7来控制。当LED灯两端呈现一正一负便可以发光。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk15.png" alt="pk15"></p><h4 id="共阴极"><a href="#共阴极" class="headerlink" title="共阴极"></a>共阴极</h4><p>所有的流水灯的阴极都是连接在LED灯的N端口，这样子就是共阴极，与上面的恰恰相反（这里忘了加电阻，不过仿真电路问题不大，我们等等看看会不会出现问题，买的单片机开发板基本上不用考虑电路设计。）</p><p>总的电路如下所示：（记得保存）</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk20.png" alt="pk20"></p><h3 id="Keil"><a href="#Keil" class="headerlink" title="Keil"></a>Keil</h3><h4 id="流水灯程序实现"><a href="#流水灯程序实现" class="headerlink" title="流水灯程序实现"></a>流水灯程序实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//最基本的程序框架</span><br><span class="line"></span><br><span class="line">#include &quot;reg51.h&quot; //这个是89c51的头文件，一般我们都选择是双引号引起来，c语言中，标准库才是使用#include&lt;..&gt; 尖括号，这里一般使用&quot;&quot;较好</span><br><span class="line">sbit LED00=P0^0;//位操作sbit</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">while(1) //这里使用while的原因是因为单片机应当是一直循环执行的。</span><br><span class="line">&#123;</span><br><span class="line">//* code *//</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="点亮一个LED灯"><a href="#点亮一个LED灯" class="headerlink" title="点亮一个LED灯"></a>点亮一个LED灯</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line">sbit led00=P0^<span class="number">0</span>;   <span class="comment">//初始P00口    ^号是选择大端口的一个引脚</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span>     <span class="comment">//延迟函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">120</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">led00=<span class="number">0</span>;<span class="comment">//共阳-亮</span></span><br><span class="line">        delay(<span class="number">5</span>);</span><br><span class="line">        led00=<span class="number">1</span>;<span class="comment">//共阳-灭</span></span><br><span class="line">        delay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk21.png" alt="pk21"><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk23.png" alt="pk23"></p><p>在Proteus左下角有个播放键</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk24.png" alt="pk24"></p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk25.png" alt="pk25"></p><p>若你也是这样子的错误，不要慌。这是因为自己的用户名是英文，使用导致出错。这里建议添加一个英文用户。（若不会的话可以在评论区交流，很简单的）</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/prj.png" alt="prj"></p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk26.png" alt="pk26"></p><h5 id="流水灯特殊实现"><a href="#流水灯特殊实现" class="headerlink" title="流水灯特殊实现"></a>流水灯特殊实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span>     <span class="comment">//延迟函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">120</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led</span><span class="params">()</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">P0=~(<span class="number">0X01</span>&lt;&lt;i);  <span class="comment">//P0=~(0X01&lt;&lt;i) 0000 0001  位运算</span></span><br><span class="line">P1=<span class="number">0X01</span>&lt;&lt;i;  <span class="comment">//      0000 0010</span></span><br><span class="line">delay(<span class="number">70</span>);      <span class="comment">//   0000 0100</span></span><br><span class="line">&#125;  <span class="comment">//               ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">led();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P0&#x3D;~(0X01&lt;&lt;i);共阳的</p><p>P1&#x3D;0X01&lt;&lt;i;共阴的</p><h5 id="流水灯一般实现"><a href="#流水灯一般实现" class="headerlink" title="流水灯一般实现"></a>流水灯一般实现</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;reg51.h&quot;</span><br><span class="line">unsigned char leddata[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;</span><br><span class="line">//通过控制一个端口的所有引脚 以0000 0000 为16进制数来进行控制。</span><br><span class="line"></span><br><span class="line">void delay(unsigned int n)     //延迟函数</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">    for(j=0;j&lt;120;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void led() </span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">P1=leddata[i];</span><br><span class="line">delay(70);</span><br><span class="line">P0=leddata[i];</span><br><span class="line">delay(70);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">led();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk27.png" alt="pk27"></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="一、端口的连接"><a href="#一、端口的连接" class="headerlink" title="一、端口的连接"></a>一、端口的连接</h3><p>首先选好要连接的端口，连接一条线出来，出来一点点的地方双击左键，使得生成节点（在这里属于端口）如下图</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk17.png" alt="pk17"></p><p>但这个端口不完整，仅仅是无对应端的端口，然后我们放大线条出现红色虚线，右键选择“放置网络标号”，填写一个唯一的标号，然后再在对应芯片的对应端也做如上方法。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk18.png" alt="pk18"></p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk19.png" alt="pk19"></p>]]></content>
    
    
    <summary type="html">Proteus_keil仿真单片机二学习</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Proteus 和 Keil --&gt;模拟单片机</title>
    <link href="https://javis-yu.github.io/archives/b256b6b7.html"/>
    <id>https://javis-yu.github.io/archives/b256b6b7.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:52:48.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Proteus-和-Keil-–-gt-模拟单片机"><a href="#Proteus-和-Keil-–-gt-模拟单片机" class="headerlink" title="Proteus 和 Keil –&gt;模拟单片机"></a>Proteus 和 Keil –&gt;模拟单片机</h1><p>&lt;**献给那些爱学习，但起始资金有很大问题的同学**&gt;</p><p>但我还是建议买一个属于自己的单片机，这样子更加能够有实战作用，且能够解决一些软件上的问题。这个工具只能代替你去了解和掌握，但实践起来稍微会有偏差的。</p><p>注：<em><strong>本教程不自带软件破解的安装（毕竟有版权、要的话私下私信我们），仅限于安装学习，不可商业化使用。</strong></em></p><p>[toc]</p><h2 id="Proteus"><a href="#Proteus" class="headerlink" title="Proteus"></a>Proteus</h2><p>Proteus是一款电子设计自动化（EDA）软件，除具有其它EDA软件的仿真功能，还能仿真单片机及其外围器件。</p><p>这里我们较多使用为学习单片机的软件工具，不仅仅更加了解电路知识，也让我们学到了51单片机的结构于控制，是很好的搭建单片机的软件，倘若自己也要开发一款PCB电路板，想要看看自己设计的电路的控制情况，这里推荐使用这个。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk1.png" alt="pk1"></p><h2 id="Keil"><a href="#Keil" class="headerlink" title="Keil"></a>Keil</h2><p>​单片机的开发工具，多用于为单片机写程序软件。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk2.png" alt="pk2"></p><h2 id="配置软件"><a href="#配置软件" class="headerlink" title="配置软件"></a>配置软件</h2><p>下载好两个文件后，要配置两个文件，使得他们能够相互连通，一个编程，一个仿真实验。</p><p>首先，是Proteus，这个比较直接，下载好后可以直接使用，不用太麻烦。</p><p>其次，是Keil，要设置好输出文件。</p><p>方法：<img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk3.png" alt="pk3"></p><p>使得编译好的文件能够烧录到仿真软件中，单片机也是如此。</p><h2 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h2><h3 id="Proteus-1"><a href="#Proteus-1" class="headerlink" title="Proteus"></a>Proteus</h3><h4 id="添加元件和使用元件"><a href="#添加元件和使用元件" class="headerlink" title="添加元件和使用元件"></a>添加元件和使用元件</h4><p>有些元件的寻找和放置等使用方式+接地和接电源的符号</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk4.png" alt="pk4"></p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk5.png" alt="pk5"></p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk6.png" alt="pk6"></p><p>Ctrl+s—&gt;保存项目文件</p><h3 id="Keil-1"><a href="#Keil-1" class="headerlink" title="Keil"></a>Keil</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk7.png" alt="pk7"></p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk8.png" alt="pk8"></p><p>这里应该是输入项目名，打错了</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk9.png" alt="pk9"></p><p>1处，因为我使用的是Keil5，是不包含51单片机的芯片的，所以我去官网下载了芯片文件，建议去网上下载keil4，减少了许多 麻烦。倘若你和我一样接触过或使用过stm32，可以使用我的方法。这个方法我放到附录中。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/PK10.png" alt="PK10"></p><h4 id="创建和添加c文件"><a href="#创建和添加c文件" class="headerlink" title="创建和添加c文件"></a>创建和添加c文件</h4><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk11.png" alt="pk11"></p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk12.png" alt="pk12"></p><p>这样子基础工作几乎全部搞定。</p><p>接下来我们就可以开发了。</p><p>下一次更新《LED灯的使用及流水灯的实现》</p><p>以后有机会，我会在文章后添加<strong>视频讲解</strong>。比较麻烦啦。但如果许多的关注和“在看”，一定人气了也许就会加倍努力了啦。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h2 id="一、下载-C51相关依赖包"><a href="#一、下载-C51相关依赖包" class="headerlink" title="一、下载 C51相关依赖包"></a>一、下载 C51相关依赖包</h2><p> keil官网下载地址：   <a href="https://www.keil.com/download/product/">https://www.keil.com/download/product/</a></p><p>这里我给出来哈：官网有些比较慢，信息填写也麻烦。</p><p>链接：<a href="https://pan.baidu.com/s/1I_XyuAOLtgBlcwCW_EAuTw">https://pan.baidu.com/s/1I_XyuAOLtgBlcwCW_EAuTw</a><br>提取码：ju98</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/PK13.png" alt="PK13"></p><p>填写好里面的表单，我们便可以下载资料了。</p><h3 id="安装包与库文件"><a href="#安装包与库文件" class="headerlink" title="安装包与库文件"></a>安装包与库文件</h3><p>默认配置安装即可，安装位置一般会标出的。</p><p>然后就可以了，进入创建项目时，便会有80c51的芯片了。</p>]]></content>
    
    
    <summary type="html">Proteus 和 Keil --&gt;模拟单片机学习</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Scikit-learn学习</title>
    <link href="https://javis-yu.github.io/archives/67844827.html"/>
    <id>https://javis-yu.github.io/archives/67844827.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:34:44.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scikit-learn"><a href="#Scikit-learn" class="headerlink" title="Scikit-learn"></a>Scikit-learn</h1><p>[toc]</p><h2 id="sklearn使用函数的路线图"><a href="#sklearn使用函数的路线图" class="headerlink" title="sklearn使用函数的路线图"></a>sklearn使用函数的路线图</h2><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/sklearn.png" alt="sklearn"></p>]]></content>
    
    
    <summary type="html">Scikit-learn的使用</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>mainim</title>
    <link href="https://javis-yu.github.io/archives/22a17072.html"/>
    <id>https://javis-yu.github.io/archives/22a17072.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:52:48.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mainim"><a href="#mainim" class="headerlink" title="mainim"></a>mainim</h1><p>[toc]</p><h2 id="基础安装"><a href="#基础安装" class="headerlink" title="基础安装"></a>基础安装</h2><p>略过…</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里我是使用一位大神的代码进行学习，稍微很多代码会有类似的地方地址放在这里：</p><p>(<a href="https://github.com/zimmermant/manim_tutorial/blob/master/manim_tutorial_P37.py">https://github.com/zimmermant/manim_tutorial/blob/master/manim_tutorial_P37.py</a>)   github。</p><p>这位大神将动画聚集在一个文件下，但我的学习不会使用它的形式，毕竟视频我是觉得分开先弄弄，减少问题的出现，等熟悉了，在把所有代码放到一起。</p><p>若你想使用大神代码学习，形成视频的时候执行<code>python -m manim file_name.py  Class_name -pl</code></p><p>file_name.py是代码存放的文件名</p><p>Class_name是类函数名</p><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><p>首先，打开  <code>Anaconda Prompt (Anaconda3)</code>右键<em><strong>管理员</strong></em>运行，cd到 manim 根目录：</p><p> <code>cd C:\Kuai8Games\manim\manim-master\manim-master</code></p><h2 id="测试命令解析"><a href="#测试命令解析" class="headerlink" title="测试命令解析"></a>测试命令解析</h2><h3 id="python-m-manim-manim-example-py-Class-name-pl"><a href="#python-m-manim-manim-example-py-Class-name-pl" class="headerlink" title="python -m manim manim_example.py Class_name -pl"></a><code>python -m manim manim_example.py Class_name -pl</code></h3><p>参数一<code>python</code>   调用python编译器进行编译；</p><p>参数二<code>-m</code>   处理模块，所有依赖都会在延缓队列中执行</p><p>参数三<code>manim</code> 执行manim.py的文件，不用<code>.py</code> ,-m就可以执行他</p><p>参数四  <code>manim_example.py</code> 是用来编写图形动画的脚本文件，该参数是需要.py 后缀的；</p><p>参数五 <code>Class_name</code>定义的一个类的类名；</p><p>参数六 <code>-pl</code> 更多参数下面命令可查看大全，这里为快速预览p(play播放)   低画质l(low)</p><h3 id="参数查看"><a href="#参数查看" class="headerlink" title="参数查看"></a>参数查看</h3><p>​参数的设置查看：</p><p>​<code>python -m manim --help</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">python -m manim --help</span><br><span class="line">##输出：</span><br><span class="line">usage: manim.py [-h] [-p] [-w] [-s] [-l] [-m] [--high_quality] [-g] [-i] [-f]</span><br><span class="line">                [-t] [-q] [-a] [-o FILE_NAME] [-n START_AT_ANIMATION_NUMBER]</span><br><span class="line">                [-r RESOLUTION] [-c COLOR] [--sound] [--leave_progress_bars]</span><br><span class="line">                [--media_dir MEDIA_DIR]</span><br><span class="line">                [--video_dir VIDEO_DIR | --video_output_dir VIDEO_OUTPUT_DIR]</span><br><span class="line">                [--tex_dir TEX_DIR]</span><br><span class="line">                file [scene_names [scene_names ...]]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  file                  path to file holding the python code for the scene</span><br><span class="line">  scene_names           Name of the Scene class you want to see</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -p, --preview         Automatically open the saved file once its done</span><br><span class="line">  -w, --write_to_movie  Render the scene as a movie file</span><br><span class="line">  -s, --save_last_frame</span><br><span class="line">                        Save the last frame</span><br><span class="line">  -l, --low_quality     Render at a low quality (for faster rendering)</span><br><span class="line">  -m, --medium_quality  Render at a medium quality</span><br><span class="line">  --high_quality        Render at a high quality</span><br><span class="line">  -g, --save_pngs       Save each frame as a png</span><br><span class="line">  -i, --save_as_gif     Save the video as gif</span><br><span class="line">  -f, --show_file_in_finder</span><br><span class="line">                        Show the output file in finder</span><br><span class="line">  -t, --transparent     Render to a movie file with an alpha channel</span><br><span class="line">  -q, --quiet</span><br><span class="line">  -a, --write_all       Write all the scenes from a file</span><br><span class="line">  -o FILE_NAME, --file_name FILE_NAME</span><br><span class="line">                        Specify the name of the output file, ifit should be</span><br><span class="line">                        different from the scene class name</span><br><span class="line">  -n START_AT_ANIMATION_NUMBER, --start_at_animation_number START_AT_ANIMATION_NUMBER</span><br><span class="line">                        Start rendering not from the first animation, butfrom</span><br><span class="line">                        another, specified by its index. If you passin two</span><br><span class="line">                        comma separated values, e.g. &quot;3,6&quot;, it will endthe</span><br><span class="line">                        rendering at the second value</span><br><span class="line">  -r RESOLUTION, --resolution RESOLUTION</span><br><span class="line">                        Resolution, passed as &quot;height,width&quot;</span><br><span class="line">  -c COLOR, --color COLOR</span><br><span class="line">                        Background color</span><br><span class="line">  --sound               Play a success/failure sound</span><br><span class="line">  --leave_progress_bars</span><br><span class="line">                        Leave progress bars displayed in terminal</span><br><span class="line">  --media_dir MEDIA_DIR</span><br><span class="line">                        directory to write media</span><br><span class="line">  --video_dir VIDEO_DIR</span><br><span class="line">                        directory to write file tree for video</span><br><span class="line">  --video_output_dir VIDEO_OUTPUT_DIR</span><br><span class="line">                        directory to write video</span><br><span class="line">  --tex_dir TEX_DIR     directory to write tex</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">##翻译：</span><br><span class="line">用途：manim.py [-h] [-p] [-w] [-s] [-l] [-m] [-高质量] [-g] [-i] [-f)</span><br><span class="line">                [-t] [-q] [-a] [-o 文件名] [-n 开始于动画编号]</span><br><span class="line">                [-r分辨率] [-c颜色] [-声音] [--留下进度条]</span><br><span class="line">                [--media dir MEDIA DIR]</span><br><span class="line">                [--video dir VIDEO DIR |--video output dir VIDEO OUTPUT DIR]</span><br><span class="line">                [--tex dir TEX DIR]</span><br><span class="line">                文件 [scene_names [场景名称...]]</span><br><span class="line"></span><br><span class="line">位置参数。</span><br><span class="line">  file存放场景的python代码的文件路径</span><br><span class="line">  scene_names 您要查看的场景类的名称。</span><br><span class="line"></span><br><span class="line">可选参数。</span><br><span class="line">  -h, --help 显示帮助信息并退出。</span><br><span class="line">  -p, --preview 保存的文件完成后自动打开。</span><br><span class="line">  -w, --write_to_movie 将场景渲染成电影文件。</span><br><span class="line">  -s，-save_last_frame，-save_last_frame。</span><br><span class="line">                        保存最后一帧</span><br><span class="line">  -l, --low_quality 以较低的质量进行渲染（为了更快的渲染）。</span><br><span class="line">  -m, --medium_quality 以中等质量进行渲染。</span><br><span class="line">  --high_quality 高质量渲染。</span><br><span class="line">  -g, --save_pngs 将每一帧画面保存为png格式。</span><br><span class="line">  -i, -save_as_gif 将视频保存为gif格式。</span><br><span class="line">  -f, --show_file_in_finder。</span><br><span class="line">                        在finder中显示输出文件</span><br><span class="line">  -t, --透明 渲染成带有alpha通道的电影文件。</span><br><span class="line">  -q, --安静</span><br><span class="line">  -a, --write_all 从文件中写入所有场景。</span><br><span class="line">  -o FILE_NAME, --file_name FILE_NAME。</span><br><span class="line">                        指定输出文件的名称，如果应该是</span><br><span class="line">                        与场景类名称不同</span><br><span class="line">  -n START_AT_ANIMATION_NUMBER, --start_at_animation_number START_AT_ANIMATION_NUMBER。</span><br><span class="line">                        不是从第一段动画开始渲染，而是从第二段动画开始渲染。</span><br><span class="line">                        另一个，由其索引指定。如果你传入两个</span><br><span class="line">                        逗号分隔的值，例如 &quot;3,6&quot;，它将结束于 &quot;3&quot;。</span><br><span class="line">                        在第二个值上呈现</span><br><span class="line">  -r RESOLUTION, --resolution RESOLUTION(决议)</span><br><span class="line">                        决议，以 &quot;高度、宽度 &quot;通过</span><br><span class="line">  -c COLOR, --color COLOR。</span><br><span class="line">                        背景色</span><br><span class="line">  --播放成功/失败的声音。</span><br><span class="line">  --leave_progress_bars</span><br><span class="line">                        让进度条在终端显示</span><br><span class="line">  --media_dir MEDIA_DIR</span><br><span class="line">                        介质目录</span><br><span class="line">  --video_dir VIDEO_DIR</span><br><span class="line">                        编写视频文件树的目录</span><br><span class="line">  --video_output_dir VIDEO_OUTPUT_DIR</span><br><span class="line">                        写视频的目录</span><br><span class="line">  --tex_dir TEX_DIR目录下写入tex的内容。</span><br></pre></td></tr></table></figure><h2 id="代码思路结构与制作"><a href="#代码思路结构与制作" class="headerlink" title="代码思路结构与制作"></a>代码思路结构与制作</h2><h3 id="代码实践一"><a href="#代码实践一" class="headerlink" title="代码实践一"></a>代码实践一</h3><p>文件命名为：first.py，保存到 manim-master 根目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用from 导入模块  </span></span><br><span class="line"><span class="keyword">from</span> manimlib.imports <span class="keyword">import</span> *  <span class="comment">#最重要的文件，manim的最核心的库文件</span></span><br><span class="line"><span class="keyword">import</span> os  <span class="comment">#系统导入文件</span></span><br><span class="line"><span class="keyword">import</span> pyclbr    <span class="comment">#可用于确定有关模块中定义的类，方法和顶级函数的一些有限信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类函数，主要是用于 封装、继承、多态</span></span><br><span class="line"><span class="comment">#封装：隐藏对象的属性和实现细节，只对外提供必要的方法。</span></span><br><span class="line"><span class="comment">#继承：(代码复用)，减少重复代码。</span></span><br><span class="line"><span class="comment">#多态：同一个方法调用，由于对象不同可能会产生不同的行为。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chang</span>(<span class="title class_ inherited__">Scene</span>):<span class="comment">##Scene-&gt;场景，使用继承的方法，继承作者写好的空场景代码。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">##定义一个方法，输入本身为参数，python建议学一点点类。</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self</span>):<span class="comment">#构建函数</span></span><br><span class="line">    circle = Circle()<span class="comment">#定义一个圆</span></span><br><span class="line">    square = Square()  <span class="comment">#定义一个方</span></span><br><span class="line">    line=Line(np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]),np.array([<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>]))<span class="comment">#定义线  </span></span><br><span class="line">    triangle=Polygon(np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]),np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]),np.array([<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>]))</span><br><span class="line">     <span class="comment">#定义一个三角</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">#实例化对象的方法</span></span><br><span class="line">     self.add(line)  <span class="comment">#添加线段到场景中</span></span><br><span class="line">     self.play(ShowCreation(square))  <span class="comment">#绘图出圆  &#123;这里很像PPT的制作&#125;</span></span><br><span class="line">     self.play(FadeOut(square))  <span class="comment">#淡出圆   </span></span><br><span class="line">     self.play(GrowFromCenter(circle))  <span class="comment">#中心扩张生成正方形</span></span><br><span class="line">     self.play(Transform(square,triangle))<span class="comment">#正方形到三角形</span></span><br><span class="line">                      </span><br><span class="line"><span class="comment">#注：我这里为了排版好看，缩进放为两个空格，若你要试试，那便将缩进改为4个空格，或按“Tab”。</span></span><br></pre></td></tr></table></figure><h3 id="使用Anaconda-Prompt-将代码变为视频"><a href="#使用Anaconda-Prompt-将代码变为视频" class="headerlink" title="使用Anaconda Prompt 将代码变为视频"></a>使用<code>Anaconda Prompt </code>将代码变为视频</h3><p>打开  <code>Anaconda Prompt (Anaconda3)</code>右键<em><strong>管理员</strong></em>运行，cd到 manim 根目录：</p><p> <code>cd C:\Kuai8Games\manim\manim-master\manim-master</code></p><p>然后<code>python -m manim first.py Chang -pl</code></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>代码编写有点像PPT的制作。</p><p>首先python少不了的库引用，几乎不会改变。</p><p>其次，使用类继承空场景的方法，创建一个场景。</p><p>然后，定义一个方法，“初始化素材”。先准备好要用的图像</p><p>接着，ppt就是准备好素材，组装，然后素材的出现，然后消失。</p><p>最后，通过命令将文件输出</p><p>代码的结构基本如此，大同小异。不过要更加精彩的话，我们慢慢学。</p><h2 id="实践代码与讲解"><a href="#实践代码与讲解" class="headerlink" title="实践代码与讲解"></a>实践代码与讲解</h2><h3 id="代码实践二"><a href="#代码实践二" class="headerlink" title="代码实践二"></a>代码实践二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MoreShapes</span>(<span class="title class_ inherited__">Scene</span>):</span><br><span class="line">    <span class="comment">#解锁更多的形状  ————依旧先先使用继承，获取</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">self</span>):</span><br><span class="line">        circle = Circle(color=PURPLE_A)</span><br><span class="line">        square = Square(fill_color=GOLD_B, fill_opacity=<span class="number">1</span>, color=GOLD_A)</span><br><span class="line">        square.move_to(UP+LEFT)</span><br><span class="line">        circle.surround(square)</span><br><span class="line">        rectangle = Rectangle(height=<span class="number">2</span>, width=<span class="number">3</span>)</span><br><span class="line">        ellipse=Ellipse(width=<span class="number">3</span>, height=<span class="number">1</span>, color=RED)</span><br><span class="line">        ellipse.shift(<span class="number">2</span>*DOWN+<span class="number">2</span>*RIGHT)</span><br><span class="line">        pointer = CurvedArrow(<span class="number">2</span>*RIGHT,<span class="number">5</span>*RIGHT,color=MAROON_C)</span><br><span class="line">        arrow = Arrow(LEFT,UP)</span><br><span class="line">        arrow.next_to(circle,DOWN+LEFT)</span><br><span class="line">        rectangle.next_to(arrow,DOWN+LEFT)</span><br><span class="line">        ring=Annulus(inner_radius=<span class="number">.5</span>, outer_radius=<span class="number">1</span>, color=BLUE)</span><br><span class="line">        ring.next_to(ellipse, RIGHT)</span><br><span class="line"></span><br><span class="line">        self.add(pointer)</span><br><span class="line">        self.play(FadeIn(square))</span><br><span class="line">        self.play(Rotating(square),FadeIn(circle))</span><br><span class="line">        self.play(GrowArrow(arrow))</span><br><span class="line">        self.play(GrowFromCenter(rectangle), GrowFromCenter(ellipse), GrowFromCenter(ring))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">mainim学习</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Learn PyTorch—张量</title>
    <link href="https://javis-yu.github.io/archives/bea8daa3.html"/>
    <id>https://javis-yu.github.io/archives/bea8daa3.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:52:48.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Learn-PyTorch—张量"><a href="#Learn-PyTorch—张量" class="headerlink" title="Learn PyTorch—张量"></a>Learn PyTorch—张量</h1><p>[TOC]</p><blockquote><p>​张量如同数组和矩阵一样, 是一种特殊的数据结构。在<code>PyTorch</code>中, 神经网络的输入、输出以及网络的参数等数据, 都是使用张量来进行描述。</p></blockquote><h2 id="张量初始化"><a href="#张量初始化" class="headerlink" title="张量初始化"></a>张量初始化</h2><h3 id="1-直接生成张量"><a href="#1-直接生成张量" class="headerlink" title="1. 直接生成张量"></a><strong>1. 直接生成张量</strong></h3><p>由原始数据直接生成张量, 张量类型由原始数据类型决定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">x_data = torch.tensor(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-通过Numpy数组来生成张量"><a href="#2-通过Numpy数组来生成张量" class="headerlink" title="2. 通过Numpy数组来生成张量"></a><strong>2. 通过Numpy数组来生成张量</strong></h3><p>由已有的<code>Numpy</code>数组来生成张量。张量与Numpy可以相互转化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np_array = np.array(data)</span><br><span class="line">x_np = torch.from_numpy(np_array)</span><br></pre></td></tr></table></figure><h3 id="3-通过已有的张量来生成新的张量"><a href="#3-通过已有的张量来生成新的张量" class="headerlink" title="3. 通过已有的张量来生成新的张量"></a><strong>3. 通过已有的张量来生成新的张量</strong></h3><p>新的张量将继承已有张量的数据属性(结构、类型), 也可以重新指定新的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x_ones = torch.ones_like(x_data)   <span class="comment"># 保留 x_data 的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;x_ones&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">x_rand = torch.rand_like(x_data, dtype=torch.<span class="built_in">float</span>)   <span class="comment"># 重写 x_data 的数据类型</span></span><br><span class="line">                                                      <span class="comment"># int -&gt; float</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;x_rand&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ones Tensor:</span><br><span class="line"> tensor([[1, 1],</span><br><span class="line">         [1, 1]])</span><br><span class="line"></span><br><span class="line">Random Tensor:</span><br><span class="line"> tensor([[0.0381, 0.5780],</span><br><span class="line">         [0.3963, 0.0840]])</span><br></pre></td></tr></table></figure><h3 id="4-通过指定数据维度来生成张量"><a href="#4-通过指定数据维度来生成张量" class="headerlink" title="4. 通过指定数据维度来生成张量"></a><strong>4. 通过指定数据维度来生成张量</strong></h3><p><code>shape</code>是元组类型, 用来描述张量的维数, 下面3个函数通过传入</p><p><code>shape</code>来指定生成张量的维数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shape = (<span class="number">2</span>,<span class="number">3</span>,)</span><br><span class="line">rand_tensor = torch.rand(shape)</span><br><span class="line">ones_tensor = torch.ones(shape)</span><br><span class="line">zeros_tensor = torch.zeros(shape)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Random Tensor: \n <span class="subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Ones Tensor: \n <span class="subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Zeros Tensor: \n <span class="subst">&#123;zeros_tensor&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Random Tensor:</span><br><span class="line"> tensor([[0.0266, 0.0553, 0.9843],</span><br><span class="line">         [0.0398, 0.8964, 0.3457]])</span><br><span class="line"></span><br><span class="line">Ones Tensor:</span><br><span class="line"> tensor([[1., 1., 1.],</span><br><span class="line">         [1., 1., 1.]])</span><br><span class="line"></span><br><span class="line">Zeros Tensor:</span><br><span class="line"> tensor([[0., 0., 0.],</span><br><span class="line">         [0., 0., 0.]])</span><br></pre></td></tr></table></figure><h2 id="张量属性"><a href="#张量属性" class="headerlink" title="张量属性"></a>张量属性</h2><p>得到张量的维数、数据类型以及它们所存储的设备(CPU或GPU)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor = torch.rand(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Shape of tensor: <span class="subst">&#123;tensor.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Datatype of tensor: <span class="subst">&#123;tensor.dtype&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Device tensor is stored on: <span class="subst">&#123;tensor.device&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape of tensor: torch.Size([3, 4])   # 维数</span><br><span class="line">Datatype of tensor: torch.float32     # 数据类型</span><br><span class="line">Device tensor is stored on: cpu       # 存储设备</span><br></pre></td></tr></table></figure><h2 id="张量运算"><a href="#张量运算" class="headerlink" title="张量运算"></a>张量运算</h2><p>这些运算都可以在GPU上运行(相对于CPU来说可以达到更高的运算速度)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断当前环境GPU是否可用, 然后将tensor导入GPU内运行</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">  tensor = tensor.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-张量的索引和切片"><a href="#1-张量的索引和切片" class="headerlink" title="1.张量的索引和切片"></a><strong>1.张量的索引和切片</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tensor = torch.ones(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">tensor[:,<span class="number">1</span>] = <span class="number">0</span>            <span class="comment"># 将第1列(从0开始)的数据全部赋值为0</span></span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br></pre></td></tr></table></figure><h3 id="2-张量的拼接"><a href="#2-张量的拼接" class="headerlink" title="2. 张量的拼接"></a><strong>2. 张量的拼接</strong></h3><p>通过<code>torch.cat</code>方法将一组张量按照指定的维度进行拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 = torch.cat([tensor, tensor, tensor], dim=<span class="number">1</span>)   <span class="comment"># dim=1 为横向拼接</span></span><br><span class="line">t2 = torch.cat([tensor, tensor, tensor], dim=<span class="number">0</span>)   <span class="comment"># dim=0 为纵向拼接</span></span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(t2)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.]])</span><br><span class="line">        </span><br><span class="line">tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br></pre></td></tr></table></figure><h3 id="3-张量的乘积和矩阵乘法"><a href="#3-张量的乘积和矩阵乘法" class="headerlink" title="3. 张量的乘积和矩阵乘法"></a><strong>3. 张量的乘积和矩阵乘法</strong></h3><h4 id="逐个元素相乘"><a href="#逐个元素相乘" class="headerlink" title="逐个元素相乘"></a>逐个元素相乘</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐个元素相乘结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;tensor.mul(tensor): \n <span class="subst">&#123;tensor.mul(tensor)&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价写法:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;tensor * tensor: \n <span class="subst">&#123;tensor * tensor&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tensor.mul(tensor):</span><br><span class="line"> tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br><span class="line"></span><br><span class="line">tensor * tensor:</span><br><span class="line"> tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br></pre></td></tr></table></figure><h4 id="张量与张量的矩阵乘法"><a href="#张量与张量的矩阵乘法" class="headerlink" title="张量与张量的矩阵乘法"></a>张量与张量的矩阵乘法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;tensor.matmul(tensor.T): \n <span class="subst">&#123;tensor.matmul(tensor.T)&#125;</span> \n&quot;</span>)</span><br><span class="line"><span class="comment"># 等价写法:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;tensor @ tensor.T: \n <span class="subst">&#123;tensor @ tensor.T&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tensor.matmul(tensor.T):</span><br><span class="line"> tensor([[3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.]])</span><br><span class="line"></span><br><span class="line">tensor @ tensor.T:</span><br><span class="line"> tensor([[3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.],</span><br><span class="line">        [3., 3., 3., 3.]])</span><br></pre></td></tr></table></figure><h3 id="4-自动赋值运算"><a href="#4-自动赋值运算" class="headerlink" title="4. 自动赋值运算"></a><strong>4. 自动赋值运算</strong></h3><p>自动赋值运算通常在方法后有 <code>_</code> 作为后缀, 例如: <code>x.copy_(y)</code>, <code>x.t_()</code>操作会改变 <code>x</code> 的取值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(tensor, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">tensor.add_(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tensor)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tensor([[1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.],</span><br><span class="line">        [1., 0., 1., 1.]])</span><br><span class="line"></span><br><span class="line">tensor([[6., 5., 6., 6.],</span><br><span class="line">        [6., 5., 6., 6.],</span><br><span class="line">        [6., 5., 6., 6.],</span><br><span class="line">        [6., 5., 6., 6.]])</span><br></pre></td></tr></table></figure><blockquote><p>自动赋值运算虽然可以节省内存, 但在求导时会因为丢失了中间过程而导致一些问题。</p></blockquote><h2 id="Tensor与Numpy的转化"><a href="#Tensor与Numpy的转化" class="headerlink" title="Tensor与Numpy的转化"></a>Tensor与Numpy的转化</h2><p>张量和<code>Numpy array</code>数组在CPU上可以共用一块内存区域, <code>改变其中一个另一个也会随之改变</code>。</p><h3 id="1-由张量变换为Numpy-array数组"><a href="#1-由张量变换为Numpy-array数组" class="headerlink" title="1. 由张量变换为Numpy array数组"></a><strong>1. 由张量变换为Numpy array数组</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = torch.ones(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line">n = t.numpy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t: tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">n: [<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br></pre></td></tr></table></figure><p>修改张量的值，则<code>Numpy array</code>数组值也会随之改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.add_(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t: tensor([<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>])</span><br><span class="line">n: [<span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span> <span class="number">2.</span>]</span><br></pre></td></tr></table></figure><h2 id="2-由Numpy-array数组转为张量"><a href="#2-由Numpy-array数组转为张量" class="headerlink" title="2. 由Numpy array数组转为张量"></a><strong>2. 由Numpy array数组转为张量</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = np.ones(<span class="number">5</span>)</span><br><span class="line">t = torch.from_numpy(n)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t:tensor([1., 1., 1., 1., 1.], dtype=torch.float64)</span><br><span class="line">t:[1. 1. 1. 1. 1.]</span><br></pre></td></tr></table></figure><p>修改<code>Numpy array</code>数组的值，则张量值也会随之改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.add(n, <span class="number">1</span>, out=n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;t: <span class="subst">&#123;t&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t: tensor([2., 2., 2., 2., 2.], dtype=torch.float64)</span><br><span class="line">n: [2. 2. 2. 2. 2.]</span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1>]]></content>
    
    
    <summary type="html">Learn PyTorch—张量学习</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>mainim学习2</title>
    <link href="https://javis-yu.github.io/archives/54fadd01.html"/>
    <id>https://javis-yu.github.io/archives/54fadd01.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-08T19:27:33.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mainim数学动画演示"><a href="#mainim数学动画演示" class="headerlink" title="mainim数学动画演示"></a>mainim数学动画演示</h1><p>[toc]</p><p>上一节我们介绍了关于mainim基础使用，及生成视频的命令简单讲解，和程序的实现。这一节，我们学习更多的实例，进行实例讲解。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] MK成员制作  <a href="https://manim.ml/index.html">https://manim.ml/index.html</a></p><p>[2] manim中文教程 <a href="https://github.com/cai-hust/manim-tutorial-CN">https://github.com/cai-hust/manim-tutorial-CN</a></p><p>[3] manim官方 <a href="https://github.com/3b1b/manim">https://github.com/3b1b/manim</a></p><p>[4] 动画课程<a href="https://github.com/Elteoremadebeethoven/AnimationsWithManim">https://github.com/Elteoremadebeethoven/AnimationsWithManim</a></p><p>[5] <em>manim</em>教程 <a href="https://github.com/malhotra5/Manim-Tutorial">https://github.com/malhotra5/Manim-Tutorial</a></p>]]></content>
    
    
    <summary type="html">mainim数学动画演示</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>pytorch 学习网站</title>
    <link href="https://javis-yu.github.io/archives/3f74665c.html"/>
    <id>https://javis-yu.github.io/archives/3f74665c.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:52:48.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pytorch-学习网站"><a href="#pytorch-学习网站" class="headerlink" title="pytorch 学习网站"></a>pytorch 学习网站</h1><p>官网：<a href="https://pytorch.org/">https://pytorch.org/</a></p><p>教程官网：<a href="https://pytorch.org/tutorials/">https://pytorch.org/tutorials/</a></p><p>中文教程：<a href="https://pytorch.apachecn.org/#/">https://pytorch.apachecn.org/#/</a></p><p><a href="https://www.latexlive.com/">在线LaTeX公式编辑器-编辑器 (latexlive.com)</a></p>]]></content>
    
    
    <summary type="html">pytorch 学习网站</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>torch.autograd 的简要介绍</title>
    <link href="https://javis-yu.github.io/archives/90c0b5a1.html"/>
    <id>https://javis-yu.github.io/archives/90c0b5a1.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:52:48.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="torch-autograd-的简要介绍"><a href="#torch-autograd-的简要介绍" class="headerlink" title="torch.autograd 的简要介绍"></a>torch.autograd 的简要介绍</h1><p>[TOC]</p><p><code>torch.autograd</code>是 PyTorch 的自动差分引擎，可为神经网络训练提供支持。</p><p>神经网络（NN）是在某些输入数据上执行的嵌套函数的集合。 这些函数由<em>参数</em>（由权重和偏差组成）定义，这些参数在 PyTorch 中存储在张量中。</p><blockquote><p>训练 NN 分为两个步骤：</p><ol><li><strong>正向传播</strong>：在正向传播中，NN 对正确的输出进行最佳猜测。 它通过其每个函数运行输入数据以进行猜测。</li><li><strong>反向传播</strong>：在反向传播中，NN 根据其猜测中的误差调整其参数。 它通过从输出向后遍历，收集有关函数参数（<em>梯度</em>）的误差导数并使用梯度下降来优化参数来实现。</li></ol></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>首先，需要加载数据，利用<code>torchvision</code>加载准备训练的<code>resnet18</code>模型。</p><p>其次，创建一个随机数据张量，具有 3 个通道的单个图像，高度&amp;宽度为 64，其对应的<code>label</code>初始化为一些随机值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch, torchvision<span class="comment">#引入训练库</span></span><br><span class="line">model = torchvision.models.resnet18(pretrained=<span class="literal">True</span>) <span class="comment">#引入模型</span></span><br><span class="line">data = torch.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>) <span class="comment">#创建一个随机张量</span></span><br><span class="line">labels = torch.rand(<span class="number">1</span>, <span class="number">1000</span>)<span class="comment">#设置随机labels标签</span></span><br></pre></td></tr></table></figure><p>接着利用<code>正向传播</code>进行预测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prediction = model(data) <span class="comment"># forward pass</span></span><br></pre></td></tr></table></figure><p>接着我们利用预测的模型和对应标签计算误差<code>loss</code>。进行<code>反向传播</code>此误差。<code>.backward()</code>进行反向传播时，<code>Autograd </code>会为每个模型参数计算梯度并将其存储在参数的<code>.grad</code>属性中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss = (prediction - labels).<span class="built_in">sum</span>()</span><br><span class="line">loss.backward() <span class="comment"># backward pass</span></span><br></pre></td></tr></table></figure><p>加载一个优化器，使用 梯度下降法(SGD) ，学习率为 0.01，步长为 0.9。 然后在优化器中注册模型的所有参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optim = torch.optim.SGD(model.parameters(), lr=<span class="number">1e-2</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><p>然后再调用 <code>.step()</code>启动 梯度下降 模型，优化器利用<code>.grad</code>中存储的梯度来进行调整参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optim.step() <span class="comment">#gradient descent</span></span><br></pre></td></tr></table></figure><p>于是便具备训练神经网络的所需数据。</p><h2 id="Autograd-的微分"><a href="#Autograd-的微分" class="headerlink" title="Autograd 的微分"></a>Autograd 的微分</h2><p>观察<code>autograd</code>如何收集梯度。利用<code>requires_grad=True</code>创建两个张量<code>a</code>和<code>b</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.tensor([<span class="number">2.</span>, <span class="number">3.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.tensor([<span class="number">6.</span>, <span class="number">4.</span>], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>利用a和b创建张量Q。<br>$$<br>Q&#x3D;3a^3-b^2<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q = <span class="number">3</span>*a**<span class="number">3</span> - b**<span class="number">2</span></span><br></pre></td></tr></table></figure><p>设<code>a</code>和<code>b</code>是神经网络的参数，<code>Q</code>是误差。在NN训练中，我们要Q分别对a、b的梯度<br>$$<br>\begin{cases}<br>    \frac{\partial Q}{\partial a} &#x3D; 9a^2<br> \<br> \ \frac{\partial Q}{\partial b} &#x3D; -2b</p><p>\end{cases}<br>$$<br><code>Q</code>上调用<code>.backward()</code>时，Autograd 将计算这些梯度并将其存储在各个张量的<code>.grad</code>属性中。</p><p>在<code>Q.backward()</code>中显式传递<code>gradient梯度</code>参数，因为它是向量，也就是说梯度反向传播时，会将公式变成矩阵形式进行运算。 <code>gradient梯度</code>是与<code>Q</code>形状相同的张量，它表示<code>Q</code>相对于本身的梯度，即<br>$$<br>\frac{\partial Q}{\partial Q} &#x3D; 1<br>$$<br>我们也可以将<code>Q</code>聚合为一个标量，然后隐式地向后调用，例如<code>Q.sum().backward()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">external_grad = torch.tensor([<span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">Q.backward(gradient=external_grad)</span><br></pre></td></tr></table></figure><p>梯度现在沉积在<code>a.grad</code>和<code>b.grad</code>中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check if collected gradients are correct</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">9</span>*a**<span class="number">2</span> == a.grad)</span><br><span class="line"><span class="built_in">print</span>(-<span class="number">2</span>*b == b.grad)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([True, True])</span><br><span class="line">tensor([True, True])</span><br></pre></td></tr></table></figure><h2 id="使用-autograd-的向量微积分"><a href="#使用-autograd-的向量微积分" class="headerlink" title="使用 autograd 的向量微积分"></a>使用 autograd 的向量微积分</h2><p>$$<br>\begin{cases}<br>    \vec{y}&#x3D;f(\vec{x})……（\mathcal{1}）\<br>    l&#x3D;g(\vec{y})……（\mathcal{2}）</p><p>\end{cases}<br>$$</p><p>由公式1，我们可以知道    向量y相对于向量x的雅可比矩阵有J：<br>$$<br>J&#x3D;<br>\begin{pmatrix}<br> \frac{\partial y}{\partial x_{1}}  &amp; \dots &amp;\frac{\partial y}{\partial x_{n}}<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br> \frac{\partial y_{1}}{\partial x_{1}} &amp; \dots  &amp; \frac{\partial y_{1}}{\partial x_{n}} \<br> \vdots    &amp; \ddots &amp; \vdots\<br> \frac{\partial y_{m}}{\partial x_{1}} &amp; \dots  &amp; \frac{\partial y_{m}}{\partial x_{n}}<br>\end{pmatrix}<br>$$<br>如果<code>v</code>恰好是标量函数的梯度:<br>$$<br>\vec{v}<br>&#x3D;<br>\begin{pmatrix}<br> \frac{\partial l}{\partial y_{1}}  &amp; \dots &amp;\frac{\partial l}{\partial y_{m}}<br>\end{pmatrix} ^T<br>$$</p><p><code>torch.autograd </code> 是用于计算向量雅可比积的引擎。 也就是说，给定任何<code>向量v</code>，计算乘积<code>J^T · v</code></p><p>也就是 <code> l 相对于 向量x 的 梯度</code>：<br>$$<br>\frac{\partial l}{\partial \vec{x} }</p><h1 id="x3D-J-T-cdot-vec-v"><a href="#x3D-J-T-cdot-vec-v" class="headerlink" title="&#x3D;J^T \cdot \vec{v} "></a>&#x3D;J^T \cdot \vec{v} </h1><p>\begin{pmatrix}<br> \frac{\partial y_{1}}{\partial x_{1}} &amp; \dots  &amp; \frac{\partial y_{1}}{\partial x_{n}} \<br> \vdots    &amp; \ddots &amp; \vdots\<br> \frac{\partial y_{m}}{\partial x_{1}} &amp; \dots  &amp; \frac{\partial y_{m}}{\partial x_{n}}<br>\end{pmatrix}</p><p>\begin{pmatrix}<br>\frac{\partial l}{\partial y_{1}} \<br>\vdots  \<br>\frac{\partial l}{\partial y_{m}}<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br>\frac{\partial l}{\partial x_{1}} \<br>\vdots  \<br>\frac{\partial l}{\partial x_{n}}<br>\end{pmatrix}<br>$$<br><code>external_grad</code>表示<code>v</code></p><h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><p>Autograd 在由函数对象组成的有向无环图（DAG）中记录数据（张量）和所有已执行的操作（以及由此产生的新张量）。</p><p>在正向传播中，Autograd 同时执行两项操作：</p><ul><li>运行请求的操作以计算结果张量，并且</li><li>在 DAG 中维护操作的<em>梯度函数</em>。</li></ul><p>当在 DAG 根目录上调用<code>.backward()</code>时，后退通道开始。 <code>autograd</code>然后：</p><ul><li>从每个<code>.grad_fn</code>计算梯度，</li><li>将它们累积在各自的张量的<code>.grad</code>属性中，然后</li><li>使用链式规则，一直传播到叶子张量。</li></ul><p><img src="https://pytorch.apachecn.org/docs/1.7/img/1270bde38f2cfccd4900a5df8ac70a7d.png" alt="../../_img/dag_autograd.png"></p><p>箭头指向前进的方向。</p><p>节点代表正向传播中每个操作的反向函数。 </p><p>蓝色的叶节点代表我们的叶张量<code>a</code>和<code>b</code>。</p><p>可以修改属性从而达到将齐排除在DAG中：</p><blockquote><p><code>torch.autograd</code>跟踪所有将其<code>requires_grad</code>标志设置为<code>True</code>的张量的操作。 对于不需要梯度的张量，将此属性设置为<code>False</code>会将其从梯度计算 DAG 中排除。</p></blockquote><p>所以可以修改  <code>requires_grad</code>的属性为 “False” ，从而达到不进行梯度运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">y = torch.rand(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">z = torch.rand((<span class="number">5</span>, <span class="number">5</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">a = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Does `a` require gradients? : <span class="subst">&#123;a.requires_grad&#125;</span>&quot;</span>)</span><br><span class="line">b = x + z</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Does `b` require gradients?: <span class="subst">&#123;b.requires_grad&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Does `a` require gradients? : False</span><br><span class="line">Does `b` require gradients?: True</span><br></pre></td></tr></table></figure><p>在 NN 中，不计算梯度的参数通常称为<strong>冻结参数</strong>。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>将部分参数进行冻结的话，会达到不需要的函数不会进行梯度运算，从而达到减少自动梯度计算，这会带来性能优势。</p><p>在微调中，我们冻结了大部分模型，通常仅修改分类器层以对新标签进行预测。</p><p>和上面一样，先加载模型并将所有参数进行冻结。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"></span><br><span class="line">model = torchvision.models.resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Freeze all the parameters in the network</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">    param.requires_grad = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>假设我们要在具有 10 个标签的新数据集中微调模型。 在 resnet 中，分类器是最后一个线性层<code>model.fc</code>。 我们可以简单地将其替换为充当我们的分类器的新线性层（默认情况下未冻结）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fc = nn.Linear(<span class="number">512</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>除了<code>model.fc</code>的参数外，模型中的所有参数都将冻结。 计算梯度的唯一参数是<code>model.fc</code>的权重和偏差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Optimize only the classifier</span></span><br><span class="line">optimizer = optim.SGD(model.fc.parameters(), lr=<span class="number">1e-2</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><p>因此分类器的权重和偏差会在梯度下降运算中进行调整。</p>]]></content>
    
    
    <summary type="html">torch.autograd 的简要介绍学习</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>串行口通信</title>
    <link href="https://javis-yu.github.io/archives/bd38da92.html"/>
    <id>https://javis-yu.github.io/archives/bd38da92.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:34:27.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串行口通信"><a href="#串行口通信" class="headerlink" title="串行口通信"></a>串行口通信</h1><p>[toc]</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk42.png" alt="pk42"></p><p>波特率发生器由定时器1产生。</p><p>发送接收用的是一个寄存器</p><p>RXD 接外设的 TXD、TXD 接外设的RXD</p><p>TI 发送标志位  TI&#x3D;1 发送完成   TI&#x3D;0 允许发送(需要手动清0)</p><p>RI 接收标志位  RI&#x3D;1 接收完成   RI&#x3D;0 允许接收(需要手动清0)</p><h2 id="串行口控制寄存器SCON"><a href="#串行口控制寄存器SCON" class="headerlink" title="串行口控制寄存器SCON"></a>串行口控制寄存器SCON</h2><table><thead><tr><th>SCON</th><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>98H</td><td>SM0</td><td>SM1</td><td>SM2</td><td>REN</td><td>TB8</td><td>RB8</td><td>TI</td><td>RI</td></tr></tbody></table><p> SM0、SM1：串行口工作方式选择位</p><table><thead><tr><th>SM0</th><th>SM1</th><th>方式</th><th>功能</th><th>波特率</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>移位寄存器方式</td><td>f&#x2F;12</td></tr><tr><td>0</td><td>1</td><td>1</td><td>8位异步通信方式</td><td>可变</td></tr><tr><td>1</td><td>0</td><td>2</td><td>8位异步通信方式</td><td>f&#x2F;32或f&#x2F;64</td></tr><tr><td>1</td><td>1</td><td>3</td><td>9位异步通信方式</td><td>可变</td></tr></tbody></table><p>SM2:多机通信控制位</p><p>REN :   REN&#x3D;1 允许接收 ；  REN&#x3D;0  禁止接收</p><p>TB8  :  发送数据第9位</p><p>RB8  :  接收数据第9位</p><p>TI      :  发送中断标志位</p><p>RI      :  接收中断标志位</p><h2 id="电源控制寄存器PCON"><a href="#电源控制寄存器PCON" class="headerlink" title="电源控制寄存器PCON"></a>电源控制寄存器PCON</h2><table><thead><tr><th>PCON</th><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>87H</td><td>SMOD</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>当SMOD 为1时，波特率加倍</p><h2 id="八位异步通信方式"><a href="#八位异步通信方式" class="headerlink" title="八位异步通信方式"></a>八位异步通信方式</h2><p>RXD 接外设的 TXD、TXD 接外设的RXD</p><p>TXD：发送数据端     RXD：接收数据段</p><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>1位起始位（0）,SUBD 的8位数据位（低位在前高位在后）和一位停止位（1）</p><h3 id="波特率计算"><a href="#波特率计算" class="headerlink" title="波特率计算"></a>波特率计算</h3><p>波特率(只能由T1产生，所以要回到定时计数器，且为8位可重载的方式产生)</p><p>波特率：2<sup>SMOD</sup> *（T1的溢出率）&#x2F; 32 </p><p>T1的溢出率 &#x3D; f &#x2F; （12*（256-初值））  256为八位的，所以是2^8&#x3D;256.</p><p>T1的初值&#x3D;256 - [f * 2<sup>SMOD</sup> &#x2F; ( 12 * 波特率 *32 )]</p><h4 id="12MHz-x3D-12000000"><a href="#12MHz-x3D-12000000" class="headerlink" title="12MHz &#x3D; 12000000"></a>12MHz &#x3D; 12000000</h4><p>有小数，误差很多 &#x3D; 256 - [ 12000000 * 2<sup>0</sup> &#x2F; 12 &#x2F; ( 12 * 9600 * 32 )] </p><h4 id="11-0592MHz-x3D-11059200"><a href="#11-0592MHz-x3D-11059200" class="headerlink" title="11.0592MHz &#x3D; 11059200"></a>11.0592MHz &#x3D; 11059200</h4><p> 是整数，所以保证通信不会出错  256 - [ 11059200 * 2<sup>0</sup> &#x2F; 12 &#x2F; ( 12 * 9600 * 32 )] &#x3D; 3 </p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>（1）发送</p><p>条件：TI &#x3D; 0 </p><p>结果： 发送完毕，TI 置 1   TI 不会自动清0，需要手动清0</p><p>（2） 接收</p><p>条件：RI &#x3D; 0  , REN(SCON.4) 置 1</p><p>结果： 8位的数据存入缓存器SBUF中，同时，RI 置 1 ，向CPU申请中断</p><h3 id="串行口初始化编程"><a href="#串行口初始化编程" class="headerlink" title="串行口初始化编程"></a>串行口初始化编程</h3><p>1.串行口控制寄存器SCON位的确定。</p><ul><li>根据工作方式确定SM0,SM1 位。</li><li>方式2，3确定SM2位</li><li>如果接收端，则允许接收 使得 REN&#x3D;1</li><li>方式2，3发送数据，则发送数据的第9位写入TB8中</li></ul><p>2.设置波特率</p><p>波特率(只能由T1产生，所以要回到定时计数器，且为8位可重载的方式产生)</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> recdat=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initscon</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">SCON=<span class="number">0x50</span>; <span class="comment">//串口通信:0101 0000    串行口控制寄存器SCON位的确定</span></span><br><span class="line">TMOD=<span class="number">0x20</span>; <span class="comment">//串口通信:0010 0000    设置波特率，只能由T1产生，回到定时计数器，8位可重载的方式产生</span></span><br><span class="line">TH1=<span class="number">256</span><span class="number">-3</span>;</span><br><span class="line">TL1=<span class="number">256</span><span class="number">-3</span>;</span><br><span class="line">ES=<span class="number">1</span>;<span class="comment">//中断：串行口中断的允许位</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//中断：开启总中断</span></span><br><span class="line">TR1=<span class="number">1</span>;  <span class="comment">//定时器：设置定时计数器1启动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">senddat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">SBUF=recdat;<span class="comment">//发送接收的数据</span></span><br><span class="line"><span class="keyword">while</span>(!TI);<span class="comment">//判断是否发送完成，完成TI置1</span></span><br><span class="line">TI=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">initscon();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">senddat();</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">scon_isr</span><span class="params">()</span> interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">recdat=SBUF;<span class="comment">//读取数据</span></span><br><span class="line">RI=<span class="number">0</span>;<span class="comment">//清0标志位，继续接收</span></span><br><span class="line">flag=<span class="number">1</span>;     <span class="comment">//表示接收完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">STM32的串行口通信</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>中断程序</title>
    <link href="https://javis-yu.github.io/archives/b25d1379.html"/>
    <id>https://javis-yu.github.io/archives/b25d1379.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:52:17.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>[toc]</p><p>中断就是某种原因，使得主程序先执行其他程序。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk40.png" alt="pk40"></p><h2 id="中断的允许控制位"><a href="#中断的允许控制位" class="headerlink" title="中断的允许控制位"></a>中断的允许控制位</h2><table><thead><tr><th>IE</th><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>A8H</td><td>EA</td><td></td><td>ET2</td><td>ES</td><td>ET1</td><td>EX1</td><td>ET0</td><td>EX0</td></tr></tbody></table><p>EA    :中断的总控制位。EA&#x3D;0 屏蔽所有中断请求，EA&#x3D;1，开放中断</p><p>ET2  :定时器&#x2F;计数器T2的溢出中断允许位     1开启，0屏蔽</p><p>ES    :串行口中断的允许位  1开启，0屏蔽</p><p>ET1  :定时器&#x2F;计数器T1的溢出中断允许位 1开启，0屏蔽</p><p>EX1  :外部中断INT1的中断允许位。  1开启，0屏蔽</p><p>ET0  :定时器&#x2F;计数器T0的溢出中断允许位     1开启，0屏蔽</p><p>EX0 :外部中断INT0的中断允许位。   1开启，0屏蔽</p><h2 id="优先权控制"><a href="#优先权控制" class="headerlink" title="优先权控制"></a>优先权控制</h2><table><thead><tr><th>IP</th><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>B8H</td><td></td><td></td><td>PT2</td><td>PS</td><td>PT1</td><td>PX1</td><td>PT0</td><td>PX0</td></tr></tbody></table><p>PT2  :定时&#x2F;计数器T2的中断优先权控制位。  52系列才有  1高优先级，0低优先级</p><p>PS    :串行口中断优先级控制位 1高优先级，0低优先级</p><p>PT1  :定时器&#x2F;计数器T1的中断优先权控制位    1高优先级，0低优先级</p><p>PX1  :外部中断INT1的中断优先权控制位     1高优先级，0低优先级</p><p>PT0  :定时器&#x2F;计数器T0的中断优先权控制位        1高优先级，0低优先级</p><p>PX0  :外部中断INT0的中断优先权控制位     1高优先级，0低优先级</p><h3 id="默认顺序"><a href="#默认顺序" class="headerlink" title="默认顺序"></a>默认顺序</h3><p>​中断源优先级顺序</p><p>外部中断0高</p><p>定时计数器T0中断   |</p><p>外部中断0 |</p><p>定时计数器T1中断    |</p><p>串行口中断|</p><p>定时计数器T2中断（52的）   低</p><h2 id="各中断服务程序入口编号-interrupt-number"><a href="#各中断服务程序入口编号-interrupt-number" class="headerlink" title="各中断服务程序入口编号 interrupt [number]"></a>各中断服务程序入口编号 interrupt [number]</h2><p>​中断源入口编号</p><p>外部中断0（P3.2）0</p><p>定时计数器0    1</p><p>外部中断0（P3.3） 2</p><p>定时计数器1     3</p><p>串行口中断   4</p><h2 id="定时-x2F-计数器-的方式寄存器-TCON"><a href="#定时-x2F-计数器-的方式寄存器-TCON" class="headerlink" title="定时&#x2F;计数器 的方式寄存器 TCON"></a>定时&#x2F;计数器 的方式寄存器 TCON</h2><table><thead><tr><th align="center">TCON</th><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td align="center">88H</td><td>TF1</td><td>TR1</td><td>TF0</td><td>TR0</td><td>IE1</td><td>IT1</td><td>IE0</td><td>IT0</td></tr></tbody></table><p>  TF   定时&#x2F;计数器溢出位,超出上限值就会置1,若进入中断自动清0  定时&#x2F;计数器范围（0—-2<sup>几位定时</sup>-1）</p><p>  TR   设置定时计数器是否启动</p><p>  IE    外部中断请求标志位</p><p>  IT    外部中断的触发方式位   &#x3D;&#x3D;0 电平触发      &#x3D;&#x3D;1边缘触发</p><p>$$<br>外部中断\ \ \ \ \  \ \overline{\text{INT0}}\ \ 和  \ \ \overline{\text{INT1}}<br>$$<br>​加了上划线，则代表为  低电平触发  或者  下降沿触发</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line">sbit ex=P3^<span class="number">2</span>;</span><br><span class="line"><span class="type">char</span> s[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>&#125;;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">initex</span><span class="params">()</span><span class="comment">//外部中断0</span></span><br><span class="line">&#123;</span><br><span class="line">IT0=<span class="number">1</span>;<span class="comment">//下降沿触发</span></span><br><span class="line">EX0=<span class="number">1</span>;<span class="comment">//外部中断INT0的中断允许位开启</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//开启中断总控制位</span></span><br><span class="line">ex=<span class="number">1</span>;<span class="comment">//设置外部中断P3.2口下降沿触发，开始要高电位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">P2=s[num];</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">num=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">initex();  <span class="comment">//外部中断初始化</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">51单片机的中断</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>code play</title>
    <link href="https://javis-yu.github.io/archives/13e0c365.html"/>
    <id>https://javis-yu.github.io/archives/13e0c365.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-08T17:27:24.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="code-演示"><a href="#code-演示" class="headerlink" title="code 演示"></a>code 演示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    hi !!!saklnda</span><br><span class="line">    <span class="title function_">printf</span><span class="params">(<span class="string">&quot;sdhaskhdo&quot;</span>)</span>;<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sdhaskhdo&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">code 演示</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>仿真电路三-数码管</title>
    <link href="https://javis-yu.github.io/archives/bacfcaba.html"/>
    <id>https://javis-yu.github.io/archives/bacfcaba.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:52:48.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="仿真电路三-数码管"><a href="#仿真电路三-数码管" class="headerlink" title="仿真电路三-数码管"></a>仿真电路三-数码管</h1><p>[toc]</p><h2 id="用到的材料"><a href="#用到的材料" class="headerlink" title="用到的材料"></a>用到的材料</h2><p>AT89c51、7seg数码管、led灯</p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>上一节我们讲过控制LED灯的程序。这一节讲个类似的-&gt;数码管。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk27.png" alt="pk27"></p><p>将电路变换，8个LED灯便组成了一个数码管.(这里虽然数码管的排列有些乱，但总的意思是数码管链接不变，仅仅改变了摆放位置，使得能够做成简单的数码管LED。)<img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk30.png" alt="pk30"></p><p>下面便是官方将摆放好的LED做成专门的器件。这里有一个引脚没有使用，是因为在实际的数码管中，还会携带一个小数点在数字的右下角。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk32.png" alt="pk32"></p><p>这便是数码管一步步改进组成新的器件的过程。</p><h2 id="数码管一：静态数码管"><a href="#数码管一：静态数码管" class="headerlink" title="数码管一：静态数码管"></a>数码管一：静态数码管</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk33.png" alt="pk33"></p><p>这里的上拉电位和下拉电位一定要分清楚，不同的器件改变了电位会使得程序也有所改变。</p><p>这里我们通过程序控制他运行。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk34.png" alt="pk34"></p><h3 id="实战-程序"><a href="#实战-程序" class="headerlink" title="实战+程序"></a>实战+程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数码管的静态显示</span></span><br><span class="line"><span class="comment">//共阳极和共阴级</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> num[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>&#125;;</span><br><span class="line"><span class="comment">//共阴极</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">500</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">P0=<span class="number">0x3F</span>;     <span class="comment">//0011 1111  显示0</span></span><br><span class="line">delay(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">P0=~num[i]; <span class="comment">//共阳</span></span><br><span class="line">P2=num[i];   <span class="comment">//共阴</span></span><br><span class="line">delay(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">smg();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很像我们曾经写过的LED程序。只是这里使用了一个数组，让整个程序显示从1-9的数字。（共阳极和共阴极取反，就可以保证相同了。）</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk35.png" alt="pk35"></p><p>列出显示字符的代码。<img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk31.png" alt="pk31"></p><h2 id="数码管二：动态数码管"><a href="#数码管二：动态数码管" class="headerlink" title="数码管二：动态数码管"></a>数码管二：动态数码管</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>动态数码管虽然说是动态的，但实际却是静态的组合。依靠视觉暂留的效应，使得数码管能够持续显示动画。</p><p>这里举个例子，在许多的LED广告牌中，你感觉他的广告牌是动画移动的，但是单独拿出来看，却是相近的几个LED灯顺序闪烁罢了，这里也要使用这个东西。<img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk36.png" alt="pk36"></p><h3 id="段码与位码"><a href="#段码与位码" class="headerlink" title="段码与位码"></a>段码与位码</h3><p>这里分为段码与位码。</p><p>段码即每个数字的一段，并且要强调的是，这里每个数字的段码都是链接在一起的，就是表明，当位码全部接通时，段码只要显示一段，每一个数字的相同一段都会亮，这便是段码。</p><p>位码即选择要亮的一个数字，即当我选择第一个数字接通，其他的数字不管段码怎么样都不会亮，只有第一个数字才会亮。位码选择了要亮的数字，这便是位码。</p><h3 id="实战-代码"><a href="#实战-代码" class="headerlink" title="实战+代码"></a>实战+代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//数码管的动态显示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;reg51.h&quot;</span><br><span class="line">char duan[]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F&#125;; //段码  显示什么</span><br><span class="line">char wei[]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;  //位码  哪一位显示</span><br><span class="line"></span><br><span class="line">void delay(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">int i,j;</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">for(j=0;j&lt;120;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void smg()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">P3=wei[i];</span><br><span class="line">P2=~duan[i];</span><br><span class="line">delay(500);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">smg();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数码管在这八位上循环显示。位码控制第几个数码管亮，段码控制显示什么数字。</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/pk37.png" alt="pk37"></p>]]></content>
    
    
    <summary type="html">仿真电路三-数码管学习</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>安装 HEXO</title>
    <link href="https://javis-yu.github.io/archives/55b8db93.html"/>
    <id>https://javis-yu.github.io/archives/55b8db93.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-08T19:27:33.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-HEXO"><a href="#安装-HEXO" class="headerlink" title="安装 HEXO"></a>安装 HEXO</h2><p>首先先创建一个文件夹，我创建文件夹 blog1</p><p>然后进入博客文件夹 </p><h3 id="创建github账户"><a href="#创建github账户" class="headerlink" title="创建github账户"></a>创建github账户</h3><p><a href="https://github.com/join?source=header-home">https://github.com/join?source=header-home</a></p><h3 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h3><p>下载网页    <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>安装win对应版本</p><h4 id="设置npm淘宝镜像站"><a href="#设置npm淘宝镜像站" class="headerlink" title="设置npm淘宝镜像站"></a>设置npm淘宝镜像站</h4><blockquote><p>npm config set registry “<a href="https://registry.npm.taobao.org&quot;/">https://registry.npm.taobao.org&quot;</a></p></blockquote><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p><a href="https://git-scm.com/">Git (git-scm.com)</a></p><h4 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h4><p>打开blog1文件夹，右键打开git bash终端。</p><p>设置user.name和user.email。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的GitHub用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><h4 id="将公匙添加到github上"><a href="#将公匙添加到github上" class="headerlink" title="将公匙添加到github上"></a>将公匙添加到github上</h4><p>用户头像→Settings→SSH and GPG keys→New SSH key→将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮。</p><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装hexo</span></span><br><span class="line">npm install hexo-cli g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化博客文件夹</span></span><br><span class="line">hexo init blog1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到该路径</span></span><br><span class="line"><span class="built_in">cd</span> blog1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装hexo的扩展插件</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装其它插件</span></span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-admin --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态页面</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启本地服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="安装-Butterfly-主题"><a href="#安装-Butterfly-主题" class="headerlink" title="安装 Butterfly 主题"></a>安装 Butterfly 主题</h2><p>首先进入 blog1 目录下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>修改 Hexo 根目录下的 ，把主题改为_config.ymlbutterfly</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>在 hexo 的根目录创建一个文件，并把主题目录的内容复制到 去。 （ 注意： 复制的是<code>主题的 _config.yml</code> ，而不是 <code>hexo 的 _config.yml _config.butterfly.yml _config.yml_config.butterfly.yml</code>)</p><blockquote><p>注意： 以后只需要在 进行配置就行。<br>如果使用了 ， 配置主题的 将不会有效果。_config.butterfly.yml _config.butterfly.yml _config.yml</p></blockquote><p>Hexo会自动合并主题中的和里的配置，如果存在同名配置，会使用的配置，其优先度较高。</p><p>_config.yml &gt;_config.butterfly.yml &gt;_config.butterfly.yml</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean   <span class="comment">#清除编译</span></span><br><span class="line">$ hexo g<span class="comment">#编译</span></span><br><span class="line">$ hexo s<span class="comment">#展示</span></span><br><span class="line">$ hexo d <span class="comment">#上传git</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">安装 HEXO 的一小部分</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>独立按键</title>
    <link href="https://javis-yu.github.io/archives/2537ab1f.html"/>
    <id>https://javis-yu.github.io/archives/2537ab1f.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-08T19:27:33.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="仿真电路四-独立按键"><a href="#仿真电路四-独立按键" class="headerlink" title="仿真电路四-独立按键"></a>仿真电路四-独立按键</h1><p>[toc]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line">sbit key=P0^<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> num[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>&#125;;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">500</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">keyfun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(key==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">delay(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">if</span>(key==<span class="number">0</span>)</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">10</span>)</span><br><span class="line">n=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">P2=num[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">keyfun();</span><br><span class="line">smg();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line">sbit key=P0^<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> num[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>&#125;;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>,sign=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">500</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">keyfun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(key==<span class="number">0</span>&amp;&amp;sign==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(key==<span class="number">0</span>&amp;&amp;sign==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sign=<span class="number">1</span>;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;sign==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;sign==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sign=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">10</span>)</span><br><span class="line">n=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">P2=num[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">keyfun();</span><br><span class="line">smg();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">仿真电路四-独立按键</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>定时/计数器</title>
    <link href="https://javis-yu.github.io/archives/3c1196df.html"/>
    <id>https://javis-yu.github.io/archives/3c1196df.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-08T19:27:33.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定时-x2F-计数器"><a href="#定时-x2F-计数器" class="headerlink" title="定时&#x2F;计数器"></a>定时&#x2F;计数器</h1><p>[toc]</p><h2 id="一、定时-x2F-计数器-的方式寄存器-TMOD"><a href="#一、定时-x2F-计数器-的方式寄存器-TMOD" class="headerlink" title="一、定时&#x2F;计数器 的方式寄存器 TMOD"></a>一、定时&#x2F;计数器 的方式寄存器 TMOD</h2><table><thead><tr><th align="center">TMOD</th><th align="center">D7</th><th align="center">D6</th><th align="center">D5</th><th align="center">D4</th><th align="center">D3</th><th align="center">D2</th><th align="center">D1</th><th align="center">D0</th></tr></thead><tbody><tr><td align="center">(89H)</td><td align="center">GATE</td><td align="center">C&#x2F;T</td><td align="center">M1</td><td align="center">M0</td><td align="center">GATE</td><td align="center">C&#x2F;T</td><td align="center">M1</td><td align="center">M0</td></tr><tr><td align="center"></td><td align="center">定时器1</td><td align="center">定时器1</td><td align="center">定时器1</td><td align="center">定时器1</td><td align="center">定时器0</td><td align="center">定时器0</td><td align="center">定时器0</td><td align="center">定时器0</td></tr></tbody></table><h3 id="M1-M0-定时计数器的方式"><a href="#M1-M0-定时计数器的方式" class="headerlink" title="M1  M0 定时计数器的方式"></a>M1  M0 定时计数器的方式</h3><p>T0的4个工作方式、T1的3个工作方式:</p><table><thead><tr><th align="center">M1</th><th align="center">M0</th><th align="center">工作方式</th><th align="center">方式说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">13位定时计数器</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">16位定时计数器</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">2</td><td align="center">8位自动重置定时计数器</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">两个8位自动重置定时计数器  (仅T0有)</td></tr></tbody></table><h3 id="C-x2F-T-定时-或-计数器"><a href="#C-x2F-T-定时-或-计数器" class="headerlink" title="C&#x2F;T  定时  或  计数器"></a>C&#x2F;T  定时  或  计数器</h3><p>C&#x2F;T  &#x3D;  1   计数方式</p><p>C&#x2F;T  &#x3D;  0   定时方式</p><h3 id="GATE"><a href="#GATE" class="headerlink" title="GATE"></a>GATE</h3><p>  门控位，用于定时或计数是否受外部中断请求信号的影响。</p><h2 id="二、定时-x2F-计数器-的方式寄存器-TCON"><a href="#二、定时-x2F-计数器-的方式寄存器-TCON" class="headerlink" title="二、定时&#x2F;计数器 的方式寄存器 TCON"></a>二、定时&#x2F;计数器 的方式寄存器 TCON</h2><table><thead><tr><th align="center">TCON</th><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td align="center">88H</td><td>TF1</td><td>TR1</td><td>TF0</td><td>TR0</td><td>IE1</td><td>IT1</td><td>IE0</td><td>IT0</td></tr></tbody></table><p>  TF   定时&#x2F;计数器溢出位,超出上限值就会置1,若进入中断自动清0  定时&#x2F;计数器范围（0—-2<sup>几位定时</sup>-1）</p><p>  TR   设置定时计数器是否启动</p><p>  IE    外部中断请求标志位</p><p>  IT    外部中断的触发方式位   &#x3D;&#x3D;0 电平触发      &#x3D;&#x3D;1边缘触发</p><p>初值保存在TH&#x2F;L  高八位：TH0&#x2F;1  和 低八位：TL0&#x2F;1</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="定时器工作方式计算"><a href="#定时器工作方式计算" class="headerlink" title="定时器工作方式计算"></a>定时器工作方式计算</h3><p>（单片机的定时器是微秒 um）1000000um&#x3D;1000ms&#x3D;1s</p><p>f： 晶振频率  51单片机有  12MHz  或者   11.0592MHz（用于通信）</p><h4 id="方式0：-13位定时器"><a href="#方式0：-13位定时器" class="headerlink" title="方式0：  13位定时器"></a>方式0：  13位定时器</h4><p>计数值  N：要获得的时间（微秒um） </p><p>初值  X &#x3D; 8192 - N &#x2F; ( 12 &#x2F; f )          2<sup>13</sup>&#x3D; 8192</p><p>数值保存在：<strong>高八位：TH0&#x2F;1  和 低八位：TL0&#x2F;1</strong></p><p>计数完后，计数器值为0，重新计数要重置初值</p><h4 id="方式1：-16位定时器"><a href="#方式1：-16位定时器" class="headerlink" title="方式1：  16位定时器"></a>方式1：  16位定时器</h4><p>计数值  N：计数的时间（微秒um） </p><p>初值  X &#x3D; 65536- N &#x2F; ( 12 &#x2F; f )          2<sup>16</sup>&#x3D; 65536</p><p>数值保存在： 高八位：TH0&#x2F;1  和 低八位：TL0&#x2F;1</p><p>计数完后，计数器值为0，重新计数要重置初值</p><h4 id="方式2：8位自动重置定时器"><a href="#方式2：8位自动重置定时器" class="headerlink" title="方式2：8位自动重置定时器"></a>方式2：8位自动重置定时器</h4><p>自动装填，保持上次的初值，不需要重复赋初值。</p><p>初值  X &#x3D; 256- N &#x2F; ( 12 &#x2F; f )          2<sup>8</sup>&#x3D; 256</p><h4 id="方式3：只有T0才有"><a href="#方式3：只有T0才有" class="headerlink" title="方式3：只有T0才有"></a>方式3：只有T0才有</h4><p>自动装填，保持上次的初值，不需要重复赋初值。</p><p>初值  X &#x3D; 256- N &#x2F; ( 12 &#x2F; f )          2<sup>8</sup>&#x3D; 256</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> s[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>&#125;;</span><br><span class="line"><span class="type">char</span> count=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用定时器0 所以高四位设置为0，低四位配置。使用16位，定时器 所以第四位为：0001</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inittimer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD=<span class="number">0x01</span>;<span class="comment">// TMOD: 0000 0001</span></span><br><span class="line">TH0=(<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>;<span class="comment">// 这里是高八位</span></span><br><span class="line">TL0=(<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;<span class="comment">// 取余是低八位</span></span><br><span class="line">ET0=<span class="number">1</span>;<span class="comment">// 开启定时器0的中断</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">// 开启总中断</span></span><br><span class="line">TR0=<span class="number">1</span>;<span class="comment">// 启动定时器0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">P2=s[num];</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">num=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">inittimer();<span class="comment">// 初始化寄存器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入中断</span></span><br><span class="line"><span class="comment">// 0表示外部中断0；1表示定时器中断0 ；2表示外部中断1； 3表示定时器中断1； 4表示串口中断；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_isr</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">TH0=(<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>;  <span class="comment">// 这里要重新赋初值</span></span><br><span class="line">TL0=(<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span>(count==<span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">count=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="定时器工作方式计算-1"><a href="#定时器工作方式计算-1" class="headerlink" title="定时器工作方式计算"></a>定时器工作方式计算</h3><h4 id="方式0：-13位计数器"><a href="#方式0：-13位计数器" class="headerlink" title="方式0：  13位计数器"></a>方式0：  13位计数器</h4><p>计数值  N：要获得的时间（微秒um） </p><p>初值  X &#x3D; 8192 - N           2<sup>13</sup>&#x3D; 8192</p><p>计数完后，计数器值为0，重新计数要重置初值</p><h4 id="方式1：-16位计数器"><a href="#方式1：-16位计数器" class="headerlink" title="方式1：  16位计数器"></a>方式1：  16位计数器</h4><p>计数值  N：计数的时间（微秒um） </p><p>初值  X &#x3D; 65536- N           2<sup>16</sup>&#x3D; 65536</p><p>计数完后，计数器值为0，重新计数要重置初值</p><h4 id="方式2：8位自动重置计数器"><a href="#方式2：8位自动重置计数器" class="headerlink" title="方式2：8位自动重置计数器"></a>方式2：8位自动重置计数器</h4><p>自动装填，保持上次的初值，不需要重复赋初值。</p><p>初值  X &#x3D; 256- N           2<sup>8</sup>&#x3D; 256</p><h4 id="方式3：只有T0才有-1"><a href="#方式3：只有T0才有-1" class="headerlink" title="方式3：只有T0才有"></a>方式3：只有T0才有</h4><p>自动装填，保持上次的初值，不需要重复赋初值。</p><p>初值  X &#x3D; 256- N          2<sup>8</sup>&#x3D; 256</p><h3 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;reg51.h&quot;</span><br><span class="line"></span><br><span class="line">char s[]=&#123;0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F&#125;; //段码</span><br><span class="line">int num=0;</span><br><span class="line"></span><br><span class="line">void initcounter()  //初始化计数器</span><br><span class="line">&#123;</span><br><span class="line">TMOD=0x06; // 0000 0110</span><br><span class="line">TH0=256-3;  </span><br><span class="line">TL0=256-3;</span><br><span class="line">ET0=1;</span><br><span class="line">EA=1;</span><br><span class="line">TR0=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">P2=s[num];</span><br><span class="line">if(num==10)</span><br><span class="line">num=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">initcounter(); </span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">display();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void counter_isr() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">stm32的定时/计数器</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>树莓派系统</title>
    <link href="https://javis-yu.github.io/archives/94d4c7d.html"/>
    <id>https://javis-yu.github.io/archives/94d4c7d.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:33:34.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树莓派-ROS-melodic-Ubuntu-meta桌面-安装大全"><a href="#树莓派-ROS-melodic-Ubuntu-meta桌面-安装大全" class="headerlink" title="树莓派+ROS_melodic+Ubuntu+meta桌面 安装大全"></a>树莓派+ROS_melodic+Ubuntu+meta桌面 安装大全</h1><p>[toc]</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>​您首先是将ROS系统安装于Ubuntu对应的版本上，时常我们会因为不是统一版本，导致安装失败。其次是换源操作，但倘若你是在树莓派上安装对应的版本，这个时候要小心，因为树莓派4B属于Arm64位系统，所以换源一定是属于树莓派的源。</p><p><em><strong>许多的电脑系统学习，时常会因为环境的安装，导致一半的人放弃；这里我要说，倘若你是真的爱，环境安装即使数十次，任不能阻挡你，那便是成功的一半了。</strong></em></p><h2 id="安装Ubuntu系统"><a href="#安装Ubuntu系统" class="headerlink" title="安装Ubuntu系统"></a>安装Ubuntu系统</h2><p>这里我使用树莓派4B安装此操作系统，倘若你说虚拟机版本的ubuntu的话，基本上一模一样。(树莓派的问题和系统前的操作更加复杂。)</p><p>基础配置：树莓派4B一个内存16GB</p><p>软件下载：</p><p>[1] SD Memory Card formatter 格式化软件   <a href="https://www.sdcard.org/chs/downloads/formatter/index.html">https://www.sdcard.org/chs/downloads/formatter/index.html</a></p><p>[2] Raspberry Pi Imager for Windows <a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a></p><p>[3] 系统(我用的是Ubuntu 18.04树莓派4下载64位)  <a href="https://ubuntu.com/download/raspberry-pi">https://ubuntu.com/download/raspberry-pi</a></p><p>[4] MobaXterm  <a href="https://moba.en.softonic.com/">https://moba.en.softonic.com/</a></p><h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><p>第一次启动树莓派，要插入一个键盘，鼠标，HDMI线，连接网线</p><h3 id="格式化SD卡"><a href="#格式化SD卡" class="headerlink" title="格式化SD卡"></a>格式化SD卡</h3><p>首先，下载好SD格式化软件，使用读卡器读取TF卡，然后打开SD格式化软件</p><p>【图片】</p><p>选择好要格式的卡，选择Quock format ，然后点击Format直接快速格式化SD卡</p><h3 id="烧录ubuntu系统"><a href="#烧录ubuntu系统" class="headerlink" title="烧录ubuntu系统"></a>烧录ubuntu系统</h3><p>选择下载好的 Raspberry Pi Imager直接安装，然后双击打开，OS选择下载好的Ubuntu 18.04系统,SD卡选择烧录的卡，然后写入。</p><p>写入完成后，将烧录好的SD卡插入树莓派背面的SD(TF)卡槽。</p><h3 id="直接设置"><a href="#直接设置" class="headerlink" title="直接设置"></a>直接设置</h3><p>连接好电源、网线，然后打开树莓派，（其实键盘，鼠标，HDMI线非必须，可以使用ssh连接），连接会提示修改ubuntu用户密码。第一次到第三次输入<code>ubuntu</code>，然后输入两次新密码。设置完成。</p><h3 id="ssh连接（仅适用于命令行系统）"><a href="#ssh连接（仅适用于命令行系统）" class="headerlink" title="ssh连接（仅适用于命令行系统）"></a>ssh连接（仅适用于命令行系统）</h3><p>这里我们先使用ssh连接，用MobaXterm软件。首先连接好电源、网线，然后打开树莓派，要通过路由器的设置网站（一般会在路由器上能找到），找到一个叫pi名字的，记住pi的地址。</p><p>在MobaXterm中，打开找到ssh，输入ip地址。</p><p>然后会让我们输入用户名，这里输入<code>ubuntu</code>,然后输入密码便打开了。</p><h3 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h3><p>这里如果想深入了解的话建议访问这个网址：<code>https://blog.csdn.net/CharlesSimonyi/article/details/89346473</code></p><p>不要在网站上随便复制，对应的系统架构不同，导致库文件和包不相同，所以建议如下操作：</p><p>在命令行中输入<code>cp /etc/apt/sources.list ./sources.list.backup</code>先备份地址。</p><p>然后输入 <code>sudo vim /etc/apt/sources.list</code>打开软件源。这里使用Vim来进行编辑。附录中有简单的对Vim的使用。</p><p>将所有的<a href="http://ports.ubuntu.com/ubuntu-ports%E5%85%A8%E9%83%A8%E6%9B%BF%E6%8D%A2%E4%B8%BA%E4%BD%A0%E8%A6%81%E7%9A%84%E6%BA%90%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9A">http://ports.ubuntu.com/ubuntu-ports全部替换为你要的源，例如：</a></p><p>中国科技大学地址：<code>http://mirrors.ustc.edu.cn/ubuntu-ports</code></p><p>阿里地址：<a href="https://mirrors.aliyun.com/ubuntu-ports/">https://mirrors.aliyun.com/ubuntu-ports/</a></p><p>然后<code>:wq</code>退出</p><p>最后输入<code>sudo apt update</code>和<code>sudo apt upgrade</code>这里时常会有些问题，可以在网络上查找，或者在评论区说出来，我会区看看帮帮忙。</p><h3 id="安装桌面系统-耗时很长"><a href="#安装桌面系统-耗时很长" class="headerlink" title="安装桌面系统(耗时很长)"></a>安装桌面系统(耗时很长)</h3><p>这里的任何几个桌面系统应该都是可以的</p><p>sudo apt-get install ubuntu-mate-desktop&#96;</p><p><code>sudo apt-get install xubuntu-desktop</code></p><p><code>sudo apt-get install lubuntu-desktop</code></p><p><code>sudo apt-get install kubuntu-desktop</code></p><h3 id="远程连接屏幕"><a href="#远程连接屏幕" class="headerlink" title="远程连接屏幕"></a>远程连接屏幕</h3><p>方法一:</p><p>安装xrdp</p><p><code>sudo apt-get install xrdp</code></p><p>重启xrdp服务</p><p><code>sudo service xrdp restart</code></p><p>Javis123</p><p>方法二:</p><p>安装VNC服务</p><p><code>sudo apt-get install tightvncserver</code></p><p>设置密码(输入连接客户端密码两次)</p><p><code> vncpasswd</code></p><p>开启服务功能(其中一定要记住他给出来的一个端口)</p><p><code>vncserver </code></p><p>记住端口(New ‘X’ desktop is  …. :2&#x2F;3&#x2F;4…)</p><p>在MobaXterm输入地址的时候,比如:192.162.169.2:2  &lt;—这里一定加上<code>:x</code>x为输出端口</p><h2 id="安装ROS"><a href="#安装ROS" class="headerlink" title="安装ROS"></a>安装ROS</h2><h3 id="多说几句"><a href="#多说几句" class="headerlink" title="多说几句"></a>多说几句</h3><p>几乎和官网的方法一致,但是总会有出现错误的地方.因为我们这里使用的是ubuntu 18.04系统,所以对应的ROS版本为Melodic;每个版本对应的不一样,一定要去官网查看好.这里我没有使用ubuntu20.04的原因是:树莓派可以安装好系统,但是无法找到ROS的完整软件包.但也有大神完成了树莓派官方系统的安装ROS…我这里不建议,因为官方系统没有对ros有较高的支持,而且 ROS的安装会出现一大堆意想不到的问题.这里我是经历过痛的,从树莓派官方系统到ubuntu的20.04版本,再到国外开发的ubuntu18.04桌面版本到现在的ubuntu mate18.04版本.只有少几次成功.</p><h3 id="安装前的设置"><a href="#安装前的设置" class="headerlink" title="安装前的设置"></a>安装前的设置</h3><p>打开<code>Ubuntu的设置</code>-&gt;<code>软件与更新</code>-&gt;<code>Ubuntu软件</code>-&gt;勾选关键字<code>universe</code>,<code>restricted</code>,<code>multiverse</code>三项。 如图所示:</p><p>[图片]</p><h3 id="添加sources-list"><a href="#添加sources-list" class="headerlink" title="添加sources.list"></a>添加sources.list</h3><p><code>$ sudo sh -c &#39;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;</code></p><p>建议使用国内或镜像源,官网使用的是外国的网站,这里使用的是中国科技大学的源.</p><h3 id="添加keys"><a href="#添加keys" class="headerlink" title="添加keys"></a>添加keys</h3><p><code>$ sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116</code></p><h3 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h3><p><code>$ sudo apt-get update </code></p><p><code>$ sudo apt-get upgrade</code></p><p>建议重启下树莓派 <code>sudo reboot</code></p><h3 id="安装完整工具箱"><a href="#安装完整工具箱" class="headerlink" title="安装完整工具箱"></a>安装完整工具箱</h3><p>安装桌面完整版安装（包含ROS、rqt、rviz、通用机器人函数库、2D&#x2F;3D仿真器、导航以及2D&#x2F;3D感知功能）</p><p><code>$ sudo apt-get install ros-melodic-desktop-full</code></p><h3 id="配置ROS"><a href="#配置ROS" class="headerlink" title="配置ROS"></a>配置ROS</h3><h4 id="初始化rosdep"><a href="#初始化rosdep" class="headerlink" title="初始化rosdep"></a>初始化rosdep</h4><p><code>$ sudo apt install python-rosdep</code>  避免后面出现sudo rosdep：找不到命令提示</p><p><code>$ sudo rosdep init</code></p><p>这里一般都会出现问题,<strong>rosdep init 或者rosdep update 连接错误的解决办法:</strong></p><p> ERROR: unable to process source <a href="https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/xxxxx">https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/xxxxx</a> </p><p>则:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#打开hosts文件</span><br><span class="line">sudo gedit /etc/hosts</span><br><span class="line">#在文件末尾添加</span><br><span class="line">151.101.84.133  raw.githubusercontent.com</span><br><span class="line">#保存后退出再尝试</span><br></pre></td></tr></table></figure><p>成功之后输入:</p><p><code>$ rosdep update</code></p><h4 id="ROS环境配置"><a href="#ROS环境配置" class="headerlink" title="ROS环境配置"></a>ROS环境配置</h4><h5 id="添加ros环境变量"><a href="#添加ros环境变量" class="headerlink" title="添加ros环境变量"></a>添加ros环境变量</h5><p><code>$ echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc</code></p><p><code>$ source ~/.bashrc</code></p><h5 id="安装rosinstall"><a href="#安装rosinstall" class="headerlink" title="安装rosinstall"></a>安装rosinstall</h5><p>ROS中一个独立分开的常用命令行工具，它可以方便让你通过一条命令就可以给某个ROS软件包下载很多源码树。</p><p><code>$ sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential </code></p><h2 id="安装完成-测试"><a href="#安装完成-测试" class="headerlink" title="安装完成+测试"></a>安装完成+测试</h2><p>ROS服务开启的第一的命令,一般使用ROS都要先执行这个:</p><p><code>$ roscore</code></p><p>启动乌龟的终端:</p><p><code>$ rosrun turtlesim turtlesim_node</code></p><p>连接键盘命令的节点:</p><p><code>$ rosrun turtlesim  turtle_teleop_key</code></p><p>选择好键盘命令的节点终端窗口,通过键盘上的方向键，进行操作小海龟.</p><h2 id="恭喜你，ROS已经成功的安装、配置并且运行！"><a href="#恭喜你，ROS已经成功的安装、配置并且运行！" class="headerlink" title="恭喜你，ROS已经成功的安装、配置并且运行！"></a>恭喜你，ROS已经成功的安装、配置并且运行！</h2><p>下面就正式开启ROS精彩的旅程！</p><p>我个人已经成功,这是我对于成功后的总结,当然,其中我也面对了许多的问题,没有在文章中说明,是因为尝试前还不知是否可以,当写完这篇文章的时候,已经是安装完成的形态了.</p><p>但我相信还是有许多同学总是卡在安装的过程中,这里您们可以留言在讨论区,共同解决问题.倘若有问题已经在讨论区中出现,请先查找讨论区的问题是否有,进行相对应的调试.</p><p>尽量每一层都是新的问题.</p><p>参考地址:</p><p>[1] <a href="https://ismango.blog.csdn.net/article/details/106049992">https://ismango.blog.csdn.net/article/details/106049992</a></p><p>[2]  <a href="https://community.bwbot.org/topic/811/rosdep-init-%E6%88%96%E8%80%85rosdep-update-%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">https://community.bwbot.org/topic/811/rosdep-init-%E6%88%96%E8%80%85rosdep-update-%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95</a></p><p>[3] <a href="https://wiki.ros.org/melodic/Installation/Ubuntu">https://wiki.ros.org/melodic/Installation/Ubuntu</a></p><p>[4] <a href="https://www.cnblogs.com/wjundong/p/10701160.html">https://www.cnblogs.com/wjundong/p/10701160.html</a></p><p>[5]  <a href="https://www.bilibili.com/video/BV1zt411G7Vn?t=7&amp;p=5">https://www.bilibili.com/video/BV1zt411G7Vn?t=7&amp;p=5</a></p><p>[6]  <a href="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/chapter1/1.4.html">https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/chapter1/1.4.html</a></p><p>基础命令</p><p>启动小海龟：</p><p>$ roscore 运行节点管理器</p><p>$ rosrun turtlesim turtesim_node打开仿真器节点</p><p>$ rosrun turtlesim turtle_teleop_key      键盘控制键</p><p>$ rqt_graph显示图</p><p>$ rosnode显示节点相关信息的指令</p><p>​$ rosnode list列出所有节点</p><p>​$ rosnode info  +上面列出的节点信息  查询某节点具体信息</p><p>​例如：$ rosnode info &#x2F;rosout</p><p>$ rostopic 显示话题相关的指令</p><p>​$ rostopic list列出所有话题</p><p>$rostopic pub &#x2F;turtle1&#x2F;cmd_vel 后面的内容双击Tab键进行补齐</p><p>​解释：rostopic是使用话题的命令   pub  发布数据给某个topic   &#x2F;turtle1&#x2F;cmd_vel控制海龟运动的话题 </p><p>里面linear 为海龟的线速度  angular 为海龟的角速度  可修改</p><p>其中加了  -r 10     代表：重复发布，即一直执行  10 每秒10次</p><p>$ rosmsg  与消息有关</p><p>​$ rosmsg show +要展示的消息</p><p>​例子：rosmsg show geometry_msgs&#x2F;Twist</p><p>​geometry_msgs&#x2F;Twist 为海龟运动时补全的第一个命令</p><p>$ rosservice服务有关</p><p>​$ rosservice list 显示服务的相关功能</p><p>​其中&#x2F;spawn  产生新的海龟</p><p>​操作:</p><p>​$ rosservice call &#x2F;spawn  [2次Tab补全]</p><p>​call  发布请求    x、y、theta为xy坐标，角度  name为名字，不要出现重复</p><p>$ rosbag record -a -O cmd_record 话题记录工具</p><p>record 记录功能  -a  也就是 -all记录所有  -O保存为压缩包   cmd_record压缩包名字</p><p>重启后：</p><p>$ roscore 运行节点管理器</p><p>$ rosrun turtlesim turtesim_node打开仿真器节点</p><p>$ rosbag play cmd_record.bag   复现记入的路径数据  cmd_record.bag  为压缩包名字</p><p>创建工作空间与功能包</p><p>工程空间：workspace 存放<strong>工程</strong>发开发相关文件的文件夹</p><p>src : 代码空间   功能包</p><p>build : 编译空间中间文件</p><p>devel : 开发空间    放置最后的文件</p><p>install : 安装空间安装的位置</p><p>空间结构图</p><p>创建工作空间：</p><p>$ mkdir -p ~&#x2F;project_name&#x2F;src</p><p>$ cd ~&#x2F;project_name&#x2F;src</p><p>$ catkin_init_workspace</p><p>编译空间：</p><p>$ cd ~&#x2F;project_name&#x2F;</p><p>$ catkin_make</p><p>设置环境变量：</p><p>$ source devel&#x2F;setup.bash</p><p>检查环境变量：</p><p> $   echo $ROS_PACKAGE_PATH</p>]]></content>
    
    
    <summary type="html">树莓派+ROS_melodic+Ubuntu+meta桌面 安装大全</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数学建模</title>
    <link href="https://javis-yu.github.io/archives/a66872a2.html"/>
    <id>https://javis-yu.github.io/archives/a66872a2.html</id>
    <published>2020-08-05T04:34:45.000Z</published>
    <updated>2022-05-10T05:32:43.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h1><p>[toc]</p><h1 id="数学建模学习"><a href="#数学建模学习" class="headerlink" title="数学建模学习"></a>数学建模学习</h1><h3 id="建模方法："><a href="#建模方法：" class="headerlink" title="建模方法："></a>建模方法：</h3><p>模型假设-建模与求-模型评价-模型改进-模型检验</p><h3 id="微分方程建模方法"><a href="#微分方程建模方法" class="headerlink" title="微分方程建模方法"></a>微分方程建模方法</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p>1.要根据问题确定要研究的量，设好所有用到的变量（自变量、未知变量、必要参数），确定坐标系等方法。</p><p>2.找到量所满足的基本规律。</p><p>3.运用规律列出方程和确定解  使用到导数</p><h4 id="1-按规律直接列方程"><a href="#1-按规律直接列方程" class="headerlink" title="1.    按规律直接列方程"></a><strong>1.</strong>    <strong>按规律直接列方程</strong></h4><p>例题1：</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo.png" alt="shumo"></p><p>牛顿冷却定律：温度高于周围环境的物体向周围媒质传递热量逐渐冷却时所遵循的规律。当物体表面与周围存在温度差时，单位时间从单位面积散失的热量与温度差成正比，比例系数称为热传递系数。牛顿冷却定律是牛顿在1701年用实验确定的，在强制对流时与实际符合较好，在自然对流时只在温度差不太大时才成立。 是传热学的基本定律之一，用于计算对流热量的多少。<br>$$<br>设物体在t时刻温度为u&#x3D;u(t),牛顿冷却定律得:\frac{du}{dt}&#x3D;-\frac{u(t)-u(t_\infty )}{\tau }&#x3D;-k(u-\widetilde{u})   \ \ 其中\widetilde{u}为常温的温度 \ \ k&gt;0  \ 令\widetilde{u}&#x3D;24 \ \ 且(u-\widetilde{u})&gt;0<br>$$<br>则：<br>$$<br>\frac{du}{u-24}&#x3D;-k \ dt \ &#x3D;&#x3D;&gt; \frac{d(u-24)}{u-24}&#x3D;-k \ dt 这里用了积分的性质，积分号里面不变\<br>求微分：<br>\int_{150}^{u}\frac{d(u-24)}{u-24}&#x3D;\int_{0}^{t}-k \ dt \ \ \ \<br>得：ln(u-24)|<em>{150}^{u} &#x3D; -kt|</em>{t}^{0} \ \ \<br>u&#x3D;24+126e^{-kt}\ \ 带入t&#x3D;0，u_0&#x3D;150 \ \ 与 \ \ t&#x3D;10,u&#x3D;100 \<br>得k&#x3D;0.0506  \ \ \ \ 所以u&#x3D;24+126e^{-0.0506t}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line">sp.var(<span class="string">&#x27;t,k&#x27;</span>)<span class="comment">#设置变量t和k</span></span><br><span class="line">u=sp.var(<span class="string">&#x27;u&#x27;</span>,cls=sp.Function)   <span class="comment">#设置cls参数为Function表示它是数学函数的符号。</span></span><br><span class="line">eq=sp.diff(u(t),t)+k*(u(t)-<span class="number">24</span>)  <span class="comment">#建立等式 u(t)对t求积分=-k(u-24)</span></span><br><span class="line">uu=sp.dsolve(eq,ics=&#123;u(<span class="number">0</span>):<span class="number">150</span>&#125;)<span class="comment">#求符号方程的解  这里相当于微分后u(0):150--&gt;u:150-u  t:0-t.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;微分方程的符号解为：&#x27;</span>,uu)<span class="comment">#输出方程</span></span><br><span class="line"></span><br><span class="line">kk=sp.solve(uu,k) <span class="comment">#这里是求解k的所有符合的值</span></span><br><span class="line"><span class="built_in">print</span>(kk,<span class="string">&#x27;= 0&#x27;</span>)</span><br><span class="line">k0=kk[<span class="number">0</span>].subs(&#123;t:<span class="number">10.0</span>,u(t):<span class="number">100</span>&#125;)<span class="comment">#得到</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k0 =&#x27;</span>,k0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k的值为：&#x27;</span>,k0.evalf())    <span class="comment">#k0.evalf()表示转化为浮点数</span></span><br><span class="line">u1=uu.args[<span class="number">1</span>]                   <span class="comment">#提出符号表达式24 + 126*exp(-k*t)</span></span><br><span class="line"><span class="comment">#print(u1)</span></span><br><span class="line">u0=u1.subs(&#123;t:<span class="number">20</span>,k:k0&#125;)         <span class="comment">#代入具体值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;20分钟后的温度为：&#x27;</span>,u0)</span><br></pre></td></tr></table></figure><h4 id="2-微元分析法"><a href="#2-微元分析法" class="headerlink" title="2.    微元分析法"></a><strong>2.</strong>    <strong>微元分析法</strong></h4><p>例题2：</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shuxue0.png" alt="shuxue0"></p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo1.png" alt="shumo1" style="zoom: 50%;" /><p>设流量为Q  通过孔的水的体积V  时间t   g为重力加速度（9.8m&#x2F;s<sup>2</sup>）  0.62为流量系数  h为高cm  S为孔的面积cm<sup>2</sup></p><p>流量系数：是指单位时间内、在测试条件中管道保持恒定的压力，管道介质流经阀门的体积流量，或是质量流量。 即阀门的流通能力。 流量系数值越大说明流体流过阀门时的压力损失越小。</p><p>得到公式为：<br>$$<br>Q&#x3D;\frac{dV}{dt}&#x3D;0.62S\sqrt{2gh}<br>$$<br>同一单位后：<br>$$<br>dV&#x3D;0.000062S\sqrt{2gh}\ dt<br>$$<br>在微小的一段时间里面：[t , t+dt ] 内，高度变化 [ h , h+dh ] ( dh&lt;0 ) , 容器中水的体积的改变：<br>$$<br>dV &#x3D; - \pi r^2 \ dh \<br>r为液面的半径\ \ \ \ R为球的半径\ \ \ \ h 为液面的高度 \<br>r^2 &#x3D; [R^2-(R-h)^2]&#x3D;2h-h^2<br>$$</p><p>所以带入r<sup>2</sup>&#x3D;2h-h<sup>2</sup><br>$$<br>0.000062 \sqrt{2gh}\ dt &#x3D; -\pi (2h-h^2)\ dh<br>$$<br>回到题目求 高度h 与 时间t 的变化：<br>$$<br>\begin{equation}<br>\left{<br>             \begin{array}{lr}<br>              \frac{dt}{dh}&#x3D;\frac{-\pi (2h-h^2)}{0.000062 \sqrt{2gh}} \<br>              h(0)&#x3D;1<br>             \end{array}<br>\right.<br>\end{equation} \<br>$$</p><p>$$<br>{\color{Red}eq} &#x3D; \frac{dt}{dh}-\frac{-\pi (2h-h^2)}{0.000062 \sqrt{2gh}}&#x3D;\color{Red}\frac{dt}{dh}-\frac{1000000\pi (h^{\frac{3}{2}}-2h^{\frac{1}{2}})}{62 \sqrt{2g}}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line">sp.var(<span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">sp.var(<span class="string">&#x27;t&#x27;</span>,cls=sp.Function)</span><br><span class="line">g  = <span class="number">9.8</span></span><br><span class="line">eq=t(h).diff(h)-<span class="number">10000</span>*sp.pi/<span class="number">0.62</span>/sp.sqrt(<span class="number">2</span>*g)*(h**(<span class="number">3</span>/<span class="number">2</span>)-<span class="number">2</span>*h**(<span class="number">1</span>/<span class="number">2</span>)) <span class="comment">#求解等式</span></span><br><span class="line">t=sp.dslove(eq,ics=&#123;t(<span class="number">1</span>):<span class="number">0</span>&#125;)  <span class="comment">#带入初始值求符号解</span></span><br><span class="line">t=sp.simplify(t)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;符号解为：&#x27;</span>,t)<span class="comment">#输出符号解</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;方程的解为：&#x27;</span>,t.args[<span class="number">1</span>].evalf())   <span class="comment">#将方程的解的系数用实数值表示 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以方程的解为：<br>$$<br>\color{Red}t(h)&#x3D;-15260.5042h^{\frac{3}{2}}+4578.1513h^{\frac{5}{2}}+10682.3530<br>$$</p><h4 id="3-模拟近似法"><a href="#3-模拟近似法" class="headerlink" title="3.    模拟近似法"></a><strong>3.</strong>    模拟近似法</h4><p><strong>例3</strong> （交通管理问题）在交通十字路口，都会设置红绿灯。为了让那些正行驶在交叉路口太近而无法停下的车辆通过路口，红绿灯转换中间还要亮起一段时间的黄灯。那么，黄灯应亮多长时间才最为合理？</p><p>首先考虑问的是黄灯亮多长时间，则要考虑：司机反应时间+刹车距离的时间+车通过交叉入口的时间。</p><p>首先设：v<sub>0</sub>是法定速度      I是交通路口长度     L是车长   </p><p>则：车通过路口的正常时间为：(I+L)&#x2F;v<sub>0</sub></p><p>求 开始刹车到速度为0 的距离。</p><p>设： W 为汽车的重量   μ为摩擦系数     所以摩擦力为f&#x3D;μW   方向与运动方向相反<br>$$<br>f&#x3D;μW  \ \ \ \ \ W&#x3D;mg \ \ \ \ \ f&#x3D;-ma&#x3D;-m\frac{dv}{dt}&#x3D;-\frac{W}{g}\frac{d^2 x}{dt^2} \<br>μmg&#x3D;-\frac{W}{g}\frac{d^2 x}{dt^2}\<br>{\color{Red}-μg&#x3D;\frac{d^2 x}{dt^2}}\<br>$$<br>所以得到：<br>$$<br>\begin{equation}<br>\left{<br>             \begin{array}{lr}<br>              -μg&#x3D;\frac{d^2 x}{dt^2} \<br>              x|<em>{t&#x3D;0}&#x3D;0, \ \frac{dx}{dt}|</em>{t&#x3D;0}&#x3D;v_0<br>             \end{array}<br>\right.<br>\end{equation} \<br>$$</p><p>化简并积分<br>$$<br>d^2 x&#x3D;-μgdt^2 \ \</p><p> \int_{0}^{x} d^2 x &#x3D; \int_{0}^{t}-μgdt^2<br>$$<br>得：<br>$$<br>\frac{dx}{dt}&#x3D;-μgt+v_0 \ \ \<br>$$<br>二次积分：<br>$$<br>\int_{0}^{x}dx  &#x3D;  \int_{0}^{t}(-μgt+v_0)dt\<br>$$<br>得：<br>$$<br>{\color{Red}x(t)&#x3D;-\frac{1}{2}μgt^2+v_0t}<br>$$</p><p>当利用前面的公式：<br>$$<br>\frac{dx}{dt}&#x3D;0 \ \ \ \ \ \ 和 \ \ \ \ \ \frac{dx}{dt}&#x3D;-μgt+v_0<br>$$<br>得到：<br>$$<br>-μgt+v_0&#x3D;0<br>$$<br>所以    刹车所用时间为：<br>$$<br>t_0&#x3D;\frac{v_0}{μg}<br>$$<br>然后将时间带入x(t)的公式：<br>$$<br>x(t_0)&#x3D;-\frac{1}{2}μgt^2 |_{t_0&#x3D;\frac{v_0}{μg}}<br>$$<br>所以刹车距离为：<br>$$<br>{\color{Red}x(t_0)&#x3D;}-\frac{1}{2}μg\frac{v_0^2}{μ^2g^2}&#x3D;\color{Red}-\frac{v_0^2}{2μg}<br>$$<br>计算黄灯的时间T：黄灯的时间<br>$$<br>T&#x3D;\frac{x(t_0)+I+L}{v_0}+T_0<br>$$<br>总路程为x(t<sub>0</sub>)+I+L   +  T<sub>0</sub> 反应时间   x（t<sub>0</sub>） 得：<br>$$<br>T&#x3D;\frac{I+L}{v_0}+T_0+\frac{v_0}{2μg}<br>$$<br>取<strong>μ&#x3D;0.7   T<sub>0</sub>&#x3D;1s   L&#x3D;4.5m  I&#x3D;9m    令：v<sub>0</sub> &#x3D;45km&#x2F;h     65km&#x2F;h      80km&#x2F;h</strong></p><table><thead><tr><th>v<sub>0</sub>  &#x2F;  (km&#x2F;h)</th><th>45</th><th>65</th><th>80</th></tr></thead><tbody><tr><td>T   &#x2F;   s</td><td>4.58</td><td>5.95</td><td>7.00</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line">v0 = array([<span class="number">45</span>,<span class="number">65</span>,<span class="number">80</span>])   <span class="comment"># v0向量</span></span><br><span class="line">T0 = <span class="number">1</span><span class="comment"># T0反应时间</span></span><br><span class="line">L  = <span class="number">4.5</span><span class="comment"># L是车长4.5m</span></span><br><span class="line">I  = <span class="number">9</span><span class="comment"># 交通路口长度9m</span></span><br><span class="line">mu = <span class="number">0.7</span><span class="comment"># 摩擦系数0.7</span></span><br><span class="line">g  = <span class="number">9.8</span><span class="comment"># 重力加速度</span></span><br><span class="line">T = v0/(<span class="number">2</span>*mu*g)+(I+L)/v0+T0 <span class="comment"># 黄灯时间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当速度分别是45、65、80(km/s)时黄灯的时长为&#x27;</span>,T)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Lorenz模型的混沌效应"><a href="#Lorenz模型的混沌效应" class="headerlink" title="Lorenz模型的混沌效应"></a>Lorenz模型的混沌效应</h3><p>Lorenz模型是由美国气象学家Lorenz在研究大气运动时，通过简化对流模型，只保留3个变量提出的一个完全确定性的一阶自治常微分方程组（不显含时间变量），其方程为<br>$$<br>\begin{cases}<br> &amp; \overset{.}{x}&#x3D; \sigma(y-x)\<br> &amp; \overset{.}{y}&#x3D; \rho x-y-xz\<br> &amp; \overset{.}{z}&#x3D; xy-\beta z<br>\end{cases}<br>$$<br>其中，参数&amp;sigma; 为Prandtl数，&amp;rho;为Rayleigh数，&amp;beta;为方向比.</p><p>第一个混沌吸引子——Lorenz吸引子也是在这个系统中被发现的. 系统中三个参数的选择对系统会不会进入混沌状态其着重要的作用.</p><p>蝴蝶效应：  &amp;sigma; &#x3D; 10            &amp;rho; &#x3D; 28              &amp;beta; &#x3D; 8&#x2F;3</p><p>给出了系统从两个靠得很近的初值出发（相差仅0.0001）后，解的偏差演化曲线. 随着时间的增大，可以看到两个解的差异越来越大，这正是动力学系统对初值敏感性的直观表现，由此可断定此系统的这种状态为混沌态. 混沌运动是确定性系统中存在随机性，它的运动轨道对初始条件极端敏感.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> odeint</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lorenz</span>(<span class="params">w,t</span>):<span class="comment">#定义求解函数</span></span><br><span class="line">    sigma=<span class="number">10</span></span><br><span class="line">    rho=<span class="number">28</span></span><br><span class="line">    beta=<span class="number">8</span>/<span class="number">3</span></span><br><span class="line">    x,y,z=w</span><br><span class="line">    <span class="keyword">return</span> np.array([sigma*(y-x),rho*x-y-x*z,x*y-beta*z])</span><br><span class="line"></span><br><span class="line">t=np.arange(<span class="number">0</span>,<span class="number">50</span>,<span class="number">0.01</span>) <span class="comment">#创建时间点</span></span><br><span class="line">sol1=odeint(lorenz,[<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>],t) <span class="comment">#第一个初值问题求解</span></span><br><span class="line">sol2=odeint(lorenz,[<span class="number">0.0</span>,<span class="number">1.0001</span>,<span class="number">0.0</span>],t) <span class="comment">#第二个初值问题求解</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sol1:\n&#x27;</span>,sol1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sol2:\n&#x27;</span>,sol2)</span><br><span class="line"></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,family=<span class="string">&#x27;SimHei&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">plt.rc(<span class="string">&#x27;axes&#x27;</span>,unicode_minus=<span class="literal">False</span>) <span class="comment">#用来正常显示负号</span></span><br><span class="line"></span><br><span class="line">ax1=plt.subplot(<span class="number">121</span>,projection=<span class="string">&#x27;3d&#x27;</span>,title=<span class="string">&#x27;图a&#x27;</span>)</span><br><span class="line">ax2=plt.subplot(<span class="number">122</span>,projection=<span class="string">&#x27;3d&#x27;</span>,title=<span class="string">&#x27;图b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax1.plot(sol1[:,<span class="number">0</span>],sol1[:,<span class="number">1</span>],sol1[:,<span class="number">2</span>],<span class="string">&#x27;r&#x27;</span>) <span class="comment">#r表示红色</span></span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;$y$&#x27;</span>)</span><br><span class="line">ax1.set_zlabel(<span class="string">&#x27;$z$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(sol1[:,<span class="number">0</span>]-sol2[:,<span class="number">0</span>],sol1[:,<span class="number">1</span>]-sol2[:,<span class="number">1</span>],sol1[:,<span class="number">2</span>]-sol2[:,<span class="number">2</span>],<span class="string">&#x27;g&#x27;</span>) <span class="comment">#g表示绿色</span></span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;$y$&#x27;</span>)</span><br><span class="line">ax2.set_zlabel(<span class="string">&#x27;$z$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个初值问题的解sol1=&#x27;</span>,sol1)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个初值问题的解sol2=&#x27;</span>,sol2)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;解的偏差sol1-sol2=&#x27;</span>,sol1-sol2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Malthus模型"><a href="#Malthus模型" class="headerlink" title="Malthus模型"></a>Malthus<strong>模型</strong></h3><p>1789年，英国神父Malthus在分析了一百多年人口统计资料之后，提出了Malthus模型.</p><h4 id="1-模型假设"><a href="#1-模型假设" class="headerlink" title="1.模型假设"></a>1.模型假设</h4><ul><li>设x（t）表示t时刻的人口数，并且x（t）连续且可微</li><li>设人口的增长率r是常数（增长率 &#x3D; 出生率 - 死亡率）</li><li>人口的变化封闭，人口数量的增加与减少只取决于人口中个体的生育和死亡，且每一个体都具有同样的生育能力与死亡率。</li></ul><h4 id="2-建模与求解"><a href="#2-建模与求解" class="headerlink" title="2.建模与求解"></a><strong>2.建模与求解</strong></h4><p>设：t-&gt;t+&amp;Delta;t    人口的增量为：x(t+&amp;Delta;t) - x(t)  &#x3D;  r x(t) &amp;Delta;t<br>$$<br>\begin{cases}<br> &amp; \frac{dx}{dt}&#x3D;rx \ \ \ \ \ \ 增长的人数&#x3D;增长率*总人口\<br> &amp; x(0)&#x3D;x_0       \ \ \  初始人口为一定值<br>\end{cases}<br>$$<br>求解：<br>$$<br>\int_{0}^{x}\frac{1}{x}dx&#x3D;\int_{0}^{t}r\ dt<br>$$<br>所以：<br>$$<br>lnx|_0^x&#x3D;rt|^t_0<br>$$<br>解的：<br>$$<br>lnx-lnx_0&#x3D;ln\frac{x}{x0}&#x3D;rt<br>$$<br>所以：<br>$$<br>\frac{x}{x_0}&#x3D;e^{rt}<br>$$<br>方程的解为：<br>$$<br>x(t)&#x3D;x_0\ e^{rt}<br>$$</p><h4 id="3-模型评价"><a href="#3-模型评价" class="headerlink" title="3.模型评价"></a>3.模型评价</h4><p>考虑二百多年来人口增长的实际情况，1961年世界人口总数为3.06x10<sup>9</sup>,在1961~1970年这段时间内，每年平均人口自然增长率为2%，则带入上式有：<br>$$<br>x(t)&#x3D;3.06\times 10^9\cdot e^{0.02(t-1961)}<br>$$<br>因为在这期间地球人口大约每35年增加1倍，而(3) 式算出每34.6年增加1倍.短期内，计算结果相当符合事实。但当t&#x3D;2670年时，x(t)&#x3D;4.4x10<sup>15</sup>,即4400万亿，相当于地球没平方米容纳至少20人。显然是不对的， 误差的原因是增长率r的估计过高，由此，可以队r这个常数提出假设。</p><h4 id="4-模型改进"><a href="#4-模型改进" class="headerlink" title="4.模型改进"></a>4.模型改进</h4><p><strong>一、</strong> <strong>当增长率不是常数时的模型</strong>**</p><p>因为地球资源是有限的，他只提供一定量的生命生存所需的条件。人口增加，自然资源、环境资源等会对人口再增长的限制越来月显著。当人过少时，可以r看为常数，但一定量后，r随着人口的增加而减少，即增长率r表示为x(t)的函数r(x(t))，记为r(x)，且r(x)为x的减函数。</p><h5 id="模型再次假设"><a href="#模型再次假设" class="headerlink" title="模型再次假设"></a>模型再次假设</h5><ul><li>设r（x）为x的线性函数，r（x）&#x3D;  r - sx  (工程署原则，首先用线性)</li><li>自然资源与环境条件所能容纳的最大人口数为x<sub>m</sub>,当x&#x3D;x<sub>m</sub>时，增长率r（x<sub>m</sub>）&#x3D; 0</li></ul><h5 id="模型建立与求解"><a href="#模型建立与求解" class="headerlink" title="模型建立与求解"></a>模型建立与求解</h5><p>由公式这个：<br>$$<br>\frac{dx}{dt}&#x3D;rx<br>$$<br>可以想到斜率会是s型。那么：<br>$$<br>令r(x)&#x3D;r(1-\frac{x}{x_m}) \ 保证了x大于x_m时会负增长 \ x&#x3D;x_m时0增长 \<br>而且增长率虽人口增加而减少<br>$$<br>假设了一个增长率函数，然后求解：<br>$$<br>\begin{cases}<br> &amp; \frac{dx}{dt}&#x3D;r(1-\frac{x}{x_m})x \<br> &amp; x(t_0)&#x3D;x_0<br>\end{cases}<br>$$<br>对第一个求积分并化简<br>$$<br>\int_{0}^{x}\frac{1}{(1-\frac{x}{x_m})x}dx&#x3D;\int_{0}^{x}\frac{x_m}{xx_m-x^2}dx&#x3D;\int_{0}^{t}r\ dt  \ \ \ \ \ \ \  \ \ \ \ \   (x_m为定值)<br>$$<br>求解：<br>$$<br>x(t)&#x3D;\frac{x_m}{1+(\frac{x_m}{x_0}-1)e^{-r(t-t_0)}}<br>$$<br>这个就是<strong>Logistic模型</strong></p><h5 id="模型检验"><a href="#模型检验" class="headerlink" title="模型检验"></a>模型检验</h5><p>$$<br>\frac{dx}{dt}求导得：\frac{d^2x}{dt^2}&#x3D;r^2(1-\frac{x}{x^m})(1-\frac{2x}{x_m})x<br>$$</p><p>人口总数x(t)有如下规律：<br>$$<br>\lim_{t\rightarrow\infty}x(t)&#x3D;x_m \ \ \ \ \ \ \ \ \ \ \ \ 即无论人口初值  如何，人口总数以  为极限.<br>$$</p><p>$$<br>当0&lt;x_0&lt;x_m时，\frac{dx}{dt}&#x3D;r(1-\frac{x}{x_m})x &gt; 0 \ \ \ 说明x(t)是单调增加的；<br>$$</p><p>$$<br>当x&lt;\frac{x_m}{2}时，\frac{d^2x}{dt^2}&gt;0,x&#x3D;x(t)为凹函数<br>$$</p><p>$$<br>当x&gt;\frac{x_m}{2}时，\frac{d^2x}{dt^2}&lt;0,x&#x3D;x(t)为凸函数<br>$$</p><p>$$<br>人口变化率\frac{dx}{dt}在x&#x3D;\frac{x_m}{2}时取最大值 \即人口总数达到极限值一半以前是加速生长，过了这一点后，会逐渐减小，最终达到0。<br>$$</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>利用下表给出的近两个世纪的美国人口统计数据（以百万为单位），建立人口预测模型，最后用它估计2010年美国的人口。</p><center>数据</center><table><thead><tr><th>年份</th><th>1790</th><th>1800</th><th>1810</th><th>1820</th><th>1830</th></tr></thead><tbody><tr><td>人口</td><td>3.9</td><td>5.3</td><td>7.2</td><td>9.6</td><td>12.9</td></tr><tr><td>年份</td><td>1840</td><td>1850</td><td>1860</td><td>1870</td><td>1880</td></tr><tr><td>人口</td><td>17.1</td><td>23.2</td><td>31.4</td><td>38.6</td><td>50.2</td></tr><tr><td>年份</td><td>1890</td><td>1900</td><td>1910</td><td>1920</td><td>1930</td></tr><tr><td>人口</td><td>62.9</td><td>76.0</td><td>92.0</td><td>106.5</td><td>123.2</td></tr><tr><td>年份</td><td>1940</td><td>1950</td><td>1960</td><td>1970</td><td>1980</td></tr><tr><td>人口</td><td>131.7</td><td>150.7</td><td>179.3</td><td>204.0</td><td>226.5</td></tr><tr><td>年份</td><td>1990</td><td>2000</td><td></td><td></td><td></td></tr><tr><td>人口</td><td>251.4</td><td>281.4</td><td></td><td></td><td></td></tr></tbody></table><h5 id="建立模型与求解"><a href="#建立模型与求解" class="headerlink" title="建立模型与求解"></a>建立模型与求解</h5><p>记x（t）为第t年的人口数量，设人口年增长率r(x)为x的线性函数，r(x) &#x3D; r - sx , 自然资源与环境条件所容纳的最大人口数为x<sub>m</sub>，即当x &#x3D; x<sub>m</sub>时，增长率r(x<sub>m</sub>) &#x3D; 0 ，得<br>$$<br>r(x)&#x3D;r(1-\frac{x}{x_m})<br>$$<br>建立 Logistic 人口模型：<br>$$<br>\begin{cases}<br> &amp; \frac{dx}{dt}&#x3D;r(1-\frac{x}{x_m})x \<br> &amp; x(t_0)&#x3D;x_0<br>\end{cases}<br>$$<br>解的：<br>$$<br>x(t)&#x3D;\frac{x_m}{1+(\frac{x_m}{x_0}-1)e^{-r(t-t_0)}}<br>$$</p><h5 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h5><h6 id="非线性最小二乘法"><a href="#非线性最小二乘法" class="headerlink" title="非线性最小二乘法"></a>非线性最小二乘法</h6><p>将第一个数据为初始条件，用余下的数据来拟合 Logistic 函数的参数x<sub>m</sub>和r 。解的r&#x3D;0.0274，x<sub>m</sub>&#x3D;342.4419</p><p>带入公式得：<br>$$<br>x(t)&#x3D;\frac{342.4419}{1+(\frac{342.4419}{x_0}-1)e^{-0.0274(t-t_0)}}<br>$$<br>将数据2010年的数据带入预测值为：2010—-282.6798（百万）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#非线性最小二乘法</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"></span><br><span class="line">a=[]</span><br><span class="line">b=[]</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取文件，一行一行读取，偶数行为年份，奇数行为数量</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡14.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s=f.read().splitlines()  </span><br><span class="line"><span class="built_in">print</span>(s,<span class="string">&#x27;\n&#x27;</span>)    </span><br><span class="line"><span class="comment">#print(len(s))  s=6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取年份</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s),<span class="number">2</span>):</span><br><span class="line">    d1 = s[i].split(<span class="string">&#x27;\t&#x27;</span>) <span class="comment">#将年份数据按&#x27;\t&#x27;分割</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(d1)):   <span class="comment">#将分割开的年份数据用append的方法放到列表</span></span><br><span class="line">        <span class="keyword">if</span> d1[j]!=<span class="string">&#x27;&#x27;</span>:<span class="comment">#判断是否为空</span></span><br><span class="line">            a.append(<span class="built_in">eval</span>(d1[j]))</span><br><span class="line"><span class="built_in">print</span>(a,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s),<span class="number">2</span>):<span class="comment">#同样的道理分割数量的数据</span></span><br><span class="line">    d2=s[i].split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(d2)):</span><br><span class="line">        <span class="keyword">if</span> d2[j]!=<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            b.append(<span class="built_in">eval</span>(d2[j]))</span><br><span class="line"><span class="built_in">print</span>(b,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c=np.vstack((a,b))</span><br><span class="line">np.savetxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡14_例1_数据.txt&#x27;</span>,c) </span><br><span class="line"></span><br><span class="line">x0=<span class="number">3.9</span></span><br><span class="line">t0=<span class="number">1790</span></span><br><span class="line">x=<span class="keyword">lambda</span> t,r,xm:xm/(<span class="number">1</span>+(xm/x0-<span class="number">1</span>)*np.exp(-r*(t-t0)))</span><br><span class="line">bd=((<span class="number">0</span>,<span class="number">200</span>),(<span class="number">0.1</span>,<span class="number">1000</span>))  <span class="comment">#约束两个参数的下界和上界</span></span><br><span class="line">popt,pcov=curve_fit(x,a[<span class="number">1</span>:],b[<span class="number">1</span>:],bounds=bd)</span><br><span class="line"><span class="comment"># 参数r与xm的估计值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;返回参数r与xm的值&#x27;</span>,popt,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2010年的预测值为：&#x27;</span>,x(<span class="number">2010</span>,*popt))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="线性最小二乘法"><a href="#线性最小二乘法" class="headerlink" title="线性最小二乘法"></a>线性最小二乘法</h6><p>简单的线性最小二乘估计这个模型的参数 x<sub>m</sub> 和 r ，把Logistic方程表示为：<br>$$<br>\frac{1}{x}\frac{dx}{dt}&#x3D;r-sx \ \ \ \ ,\ \  \ s&#x3D;\frac{r}{x_m}<br>$$<br>记1790,1800，…… ，2000年分别用 k &#x3D; 1，2，3，……，21  表示，利用向前差分，得到差分方程：<br>$$<br>\frac{1}{x(k)}\cdot \frac{x(k+1)-x(k)}{\Delta t}&#x3D;r-sx(k)\ \ \ \ \ ,\ \ \ \ \ \ k&#x3D;1,2,3,…,21<br>$$<br>其中步长&amp;Delta;t&#x3D;10。拟合数据，求得r&#x3D;0.0325，x(m)&#x3D;294.3860 ，再求得2010年人口预测值为277.9634百万。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#线性最小二乘法</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">d=np.loadtxt(<span class="string">&#x27;暑假打卡14_例1_数据.txt&#x27;</span>) <span class="comment">#加载文件中的数据</span></span><br><span class="line"><span class="built_in">print</span>(d)<span class="comment"># 观察完数据可注释掉</span></span><br><span class="line">t0=d[<span class="number">0</span>] <span class="comment"># 提取年代数据</span></span><br><span class="line">x0=d[<span class="number">1</span>] <span class="comment"># 提取对应的人口数据</span></span><br><span class="line"><span class="built_in">print</span>(t0)</span><br><span class="line"><span class="built_in">print</span>(x0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(x0[:-<span class="number">1</span>]) <span class="comment"># 获取数据除去最后一位</span></span><br><span class="line">b=np.diff(x0)/<span class="number">10</span>/x0[:-<span class="number">1</span>]<span class="comment"># 构造线性方程组的常数项列</span></span><br><span class="line">a=np.vstack([np.ones(<span class="built_in">len</span>(x0)-<span class="number">1</span>),-x0[:-<span class="number">1</span>]]).T <span class="comment">#构造线性方程组系数矩阵</span></span><br><span class="line">rs=np.linalg.pinv(a)@b </span><br><span class="line"><span class="comment">#pinv表示矩阵a的伪逆pinv(X) ，此处不懂可百度最小二乘法的公式以及伪逆。</span></span><br><span class="line"><span class="comment">#这里的@指矩阵的乘法</span></span><br><span class="line">r=rs[<span class="number">0</span>]</span><br><span class="line">xm=r/rs[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;人口增长率r和人口最大值xm的拟合值分别为&#x27;</span>,np.<span class="built_in">round</span>([r,xm],<span class="number">4</span>)) <span class="comment">#round函数表示四舍五入，此处4表示保留4位小数</span></span><br><span class="line">xhat=xm/(<span class="number">1</span>+(xm/<span class="number">3.9</span>-<span class="number">1</span>)*np.exp(-r*(<span class="number">2010</span>-<span class="number">1790</span>))) <span class="comment">#求预测值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;2010年的预测值为：&#x27;</span>,<span class="built_in">round</span>(xhat,<span class="number">4</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="传染病模型"><a href="#传染病模型" class="headerlink" title="传染病模型"></a>传染病模型</h3><p> 传染病动力学是用数学模型研究某种传染病在某的一地区是否蔓延下去，成为当地的“地方病”，或最终该病将被消除. 下面以Kermack和Mckendrick 提出的阈值模型为例说明传染病动力学模型的建模过程。</p><h4 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h4><ol><li><p>被研究人群是封闭的，总人数为 n 。s(t) , i(t) , r(t) 分别代表：t 时刻  易感染着、已感染着、免疫者。  起始条件：s<sub>0</sub>个易感染者 ， i<sub>0</sub> 个感染者 ，n-s<sub>0 </sub>- i<sub>0</sub> 个</p></li><li><p>易感染人数的变化率与当时的易感染人数和感染人数之积成正比 ， 系数为  &amp;lambda;。</p></li><li><p>免疫者人数的变化率与当时的感染者人数成正比，比例系数为 &amp;mu; 。</p></li><li><p>三类人总的变化率代数和为零.</p></li></ol><h4 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h4><p>根据上述假设，可以建立如下模型：</p><p>$$<br>\begin{cases}<br> &amp; \frac{ds}{dt}&#x3D;  -\lambda si\<br> &amp; \frac{dr}{dt}&#x3D;  \mu i\<br> &amp; \frac{di}{dt}+\frac{ds}{dt}+\frac{dr}{dt}&#x3D;0  \<br> &amp; \frac{di}{dt}&#x3D;  \lambda si-\mu i\<br> &amp; s(t)+i(t)+r(t)&#x3D;n<br>\end{cases}<br>$$<br>模型又称Kermack-Mckendrick方程</p><h4 id="模型求解与分解"><a href="#模型求解与分解" class="headerlink" title="模型求解与分解"></a>模型求解与分解</h4><p>上面的方程无法求解出任何一个  s(t) , i(t) , r(t) 的解析解。转到平面 s-i 讨论解的性质。<br>$$<br>由 得：\begin{cases}<br>\frac{di}{ds}&#x3D;\frac{1}{\sigma s}-1\<br>\sigma&#x3D;\frac{\lambda}{\mu}\<br>i|_{s&#x3D;s_0}&#x3D;i_0 \<br>\end{cases}<br>$$</p><p>$$<br>\mu是易感人数的变化率系数、\lambda是免疫者人数的变化率系数、\sigma则为一个传染期内每个患者有效接触的平均人数<br>$$</p><p>则&amp;sigma;为接触数.</p><p>分离变量法求解：<br>$$<br>di&#x3D;(\frac{1}{\sigma s}-1)ds<br>$$<br>然后对两边积分：<br>$$<br>\int_{i_0}^{i}di&#x3D;\int_{s_0}^{s}(\frac{1}{\sigma s}-1)ds<br>$$<br>得：<br>$$<br>i|<em>{i_0}^{i}&#x3D;(\frac{1}{\sigma}lns-s)|</em>{s_0}^{s}<br>$$<br>所以：<br>$$<br>i-i_0 &#x3D;\frac{1}{\sigma}lns-s-\frac{1}{\sigma}lns_0+s_0<br>$$<br>化简：<br>$$<br>i&#x3D;i_0+s_0-s+\frac{1}{\sigma}(lns-lns_0)<br>$$<br>解的：<br>$$<br>i&#x3D;i_0+s_0-s+\frac{1}{\sigma}(ln\frac{s}{s_0})<br>$$<br>由公式得知：</p><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo3.png" alt="shumo3"></p><ul><li><p>当初始值s<sub>0</sub> &amp;le; 1&#x2F; &amp;sigma; 时，患者人数会增加，传染病开始蔓延，健康者的人数在减少。</p></li><li><p>当初始值s(t) 减少至 1&#x2F; &amp;sigma; 时,患者在人群中的比例达到最大值，然后患者数逐渐减少至零</p></li><li><p>1&#x2F; &amp;sigma; 是阈值，所以要想控制传染病的流行，应控制s<sub>0</sub> 使之小于阈值.</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>提高卫生和医疗水平，卫生水平越高，使传染性接触率 &amp;lambda; 就越小；医疗水平越高，恢复系数 &amp;mu;  就越大。</li></ol><p>这样子就提高了1&#x2F; &amp;sigma; 阈值 。提高卫生和医疗水平有助于控制传染病的蔓延</p><ol start="2"><li>降低s<sub>0</sub>来控制传染病的蔓延. 由 s<sub>0 </sub>+ i<sub>0 </sub>+ r<sub>0</sub> &#x3D; n  可知道，减少s<sub>0</sub>可以通过提高r<sub>0</sub> 来实现。</li></ol><h4 id="参数估计-1"><a href="#参数估计-1" class="headerlink" title="参数估计"></a>参数估计</h4><p>参数&amp;sigma; 的值可由实际的数据估计得：<br>$$<br>令s_\infty 与 i_\infty 分别是传染病流行结束后的 健康者人数 和 患者人数。<br>$$<br>当流行结束后，患者都将转化为免疫者<br>$$<br>i_\infty &#x3D; 0 \ ;\ \therefore i_\infty&#x3D;i_0+s_0-s_\infty+\frac{1}{\sigma}(ln\frac{s_\infty}{s_0}),<br>$$<br>解的：<br>$$<br>\sigma&#x3D;-\frac{lns_0-lns_\infty}{s_\infty-i_0-s_0}<br>$$<br>于是，当已知某地区某种传染病流行结束后的 $s_\infty$ 时，则可以算出 $\sigma$ ， $\sigma$ 值可再今后同种传染病和同类地区的研究中使用。</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>1950年上海市某全托幼儿所发生的一起水痘流行过程中各代病例数、易感染者数及间隔时间如下，应用K-M模型进行模拟，并对模拟结果进行讨论. 该所儿童总人数n 为196人；既往患过水痘而此次未感染者40人，查不出水痘患病史而本次流行期间感染水痘者96人，既往无明确水痘史，本次又未感染的幸免者60人. 全部流行期间79人，病例成代出现，每代间隔约15人. </p><center>表1 某全托幼儿所水痘流行过程中各代病例数<table><thead><tr><th>代</th><th>病例数</th><th>易感染者</th><th>间隔时间&#x2F;天</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>155</td><td></td></tr><tr><td>2</td><td>2</td><td>153</td><td>15</td></tr><tr><td>3</td><td>14</td><td>139</td><td>32</td></tr><tr><td>4</td><td>38</td><td>101</td><td>46</td></tr><tr><td>5</td><td>34</td><td>67</td><td></td></tr><tr><td>6</td><td>7</td><td>33</td><td></td></tr><tr><td>合计</td><td>96</td><td></td><td></td></tr></tbody></table><p>以初始值s<sub>0</sub>，$s_\infty$代入$\sigma&#x3D;-\frac{lns_0-lns_\infty}{s_\infty-i_0-s_0}$ 可得  $ \sigma&#x3D;0.0099 $ . </p><p>将代入$i&#x3D;i_0+s_0-s+\frac{1}{\sigma}(ln\frac{s}{s_0})$ 可得该流行过程的模拟结果如下表2.</p><center>表2 用K-M模型模拟水痘流行过程的数值解 <table><thead><tr><th>易感染者</th><th>155</th><th>153</th><th>139</th><th>101</th></tr></thead><tbody><tr><td>病例数i</td><td>1</td><td>1.7</td><td>6.0</td><td>11.7</td></tr></tbody></table><h5 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s0=<span class="number">155</span></span><br><span class="line">i0=<span class="number">1.0</span></span><br><span class="line">s_inf=<span class="number">60.0</span></span><br><span class="line"></span><br><span class="line">sigma=(np.log(s0)-np.log(s_inf))/(s0+i0-s_inf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sigma=&#x27;</span>,sigma,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">S=np.array([<span class="number">155</span>,<span class="number">153</span>,<span class="number">139</span>,<span class="number">101</span>])</span><br><span class="line">I=(s0+i0)-S+<span class="number">1</span>/sigma * np.log(S/s0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;所求的解为：&#x27;</span>, I)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插值与拟合"><a href="#插值与拟合" class="headerlink" title="插值与拟合"></a>插值与拟合</h3><p>​        在数学建模过程中，通常要处理由试验、测量得到的大量数据或一些过于复杂而不方便计算的函数表达式，针对此情况，很自然的想法就是，构造一个简单的函数作为要考察数据或复杂函数的近似. 插值和拟合就可以解决这样的问题</p><p>​        给定一组数据，需要确定满足特定要求的曲线（或曲面），如果所求曲线通过所给定的有限个数据点，这就是<strong>插值</strong>. 有时由于给定的数据存在测量误差，往往具有一定的随机性. 因而，通过所有数据点求曲线不现实也不必要. 如果不要求曲线通过所有数据点，而是要求它反映对象整体的变化态势，得到简单实用的近似函数，这就是<strong>拟合</strong>.</p><h4 id="拟合函数的选择"><a href="#拟合函数的选择" class="headerlink" title="拟合函数的选择"></a>拟合函数的选择</h4><p>数据拟合时，首要也是最关键的一步就是恰当的拟合函数. 如果能够根据问题的背景通过机理分析得到变量之间的函数关系，那么只需估计相应的参数即可. 但很多情况下，问题的机理并不清楚. 此时，一个较为自然的方法是先做出<strong>数据的散点图</strong>，从直观上判断应选用什么样的拟合函数.</p><ul><li><p>如果数据分布<strong>接近于直线</strong>，则拟合函数宜选用<strong>线性函数</strong> $f(x)&#x3D;a_1x+a_2$ ;</p></li><li><p>如果数据分布接近于<strong>抛物线</strong>，则拟合函数宜选用二次多项式  $f(x)&#x3D;a_1x^2+a_2x+a_3$ ;</p></li><li><p>如果数据分布特点是开始上升较快随后逐渐变缓，则宜选用双曲线型函数或指数型函数，即用 $f(x)&#x3D;\frac{x}{a_1x+a_2}$ 或  $ f(x)&#x3D;a_1e^{-\frac{a_2}{x}}$ ; </p></li><li><p>如果数据分布特点是开始下降较快随后逐渐变缓，则宜选用$f(x)&#x3D;\frac{1}{a_1x+a_2}$,$f(x)&#x3D;\frac{1}{a_1x^2+a_2}$ , $f(x)&#x3D;a_1e^{-a_2x}$</p></li><li><p>常被选用的非线性拟合函数有$y&#x3D;a_1+a_2\ lnx$  ，S形曲线函数为$y&#x3D;\frac{1}{a+be^{-x}}$</p></li></ul><h4 id="数据拟合python程序实现："><a href="#数据拟合python程序实现：" class="headerlink" title="数据拟合python程序实现："></a>数据拟合python程序实现：</h4><p>python中有多个模块的多种方法可以进行拟合未知参数. </p><p>Numpy中的多项式拟合函数polyfit</p><p>Scipy.optimize中的leastsq（最小二乘）、curve_fit</p><h5 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h5><p>对下表1的数据进行拟合，并求当x&#x3D;0.25 ,0.35 时, y的预测值.</p><center>表1 待拟合数据<table><thead><tr><th>x</th><th>0</th><th>0.1</th><th>0.2</th><th>0.3</th><th>0.4</th><th>0.5</th><th>0.6</th><th>0.7</th><th>0.8</th><th>0.9</th><th>1.0</th></tr></thead><tbody><tr><td>y</td><td>-0.447</td><td>1.978</td><td>3.28</td><td>6.16</td><td>7.08</td><td>7.34</td><td>7.66</td><td>9.56</td><td>9.48</td><td>9.30</td><td>11.2</td></tr></tbody></table><p>解:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示点</span></span><br><span class="line"><span class="keyword">import</span> numpy  <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x=np.arange(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0.1</span>)</span><br><span class="line"><span class="comment">#print(x)</span></span><br><span class="line">y=np.array([-<span class="number">0.447</span>,<span class="number">1.978</span>,<span class="number">3.28</span>,<span class="number">6.16</span>, <span class="number">7.08</span>, <span class="number">7.34</span>, <span class="number">7.66</span>, <span class="number">9.56</span>, <span class="number">9.48</span>, <span class="number">9.30</span>, <span class="number">11.2</span>])</span><br><span class="line">plt.plot(x,y,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo4.png" alt="shumo4"></p><p>可以看出,接近于直线或抛物线.这里抛物线更加准确.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy  <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x0=np.arange(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0.1</span>) <span class="comment">#设置初始为0,末尾1.1以前,步长0.1</span></span><br><span class="line">y0=np.array([-<span class="number">0.447</span>,<span class="number">1.978</span>,<span class="number">3.28</span>,<span class="number">6.16</span>, <span class="number">7.08</span>, <span class="number">7.34</span>, <span class="number">7.66</span>, <span class="number">9.56</span>, <span class="number">9.48</span>, <span class="number">9.30</span>, <span class="number">11.2</span>])</span><br><span class="line">p=np.polyfit(x0,y0,<span class="number">2</span>) <span class="comment">#拟合二次多项式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合二次多项式的从高次幂到低次幂系数分别为：&#x27;</span>,p)</span><br><span class="line">yhat=np.polyval(p,[<span class="number">0.25</span>,<span class="number">0.35</span>])  <span class="comment">#令x= 0.25,0.35 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测值分别为：&#x27;</span>,yhat)</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">plt.plot(x0,y0,<span class="string">&#x27;*&#x27;</span>,x0,np.polyval(p,x0),<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo5.png" alt="shumo5"></p><p>拟合二次多项式的从高次幂到低次幂系数分别为： [-9.81083916 20.12929371 -0.03167133]<br>预测值分别为： [4.38747465 5.81175367]</p><h5 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h5><p>对例1的数据用  <strong>curve_fit 函数</strong>拟合二次多项式，并求预测值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">y=<span class="keyword">lambda</span> x,a,b,c: a*x**<span class="number">2</span>+b*x+c</span><br><span class="line">x0=np.arange(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0.1</span>)</span><br><span class="line">y0=np.array([-<span class="number">0.447</span>,<span class="number">1.978</span>,<span class="number">3.28</span>,<span class="number">6.16</span>, <span class="number">7.08</span>, <span class="number">7.34</span>, <span class="number">7.66</span>, <span class="number">9.56</span>, <span class="number">9.48</span>, <span class="number">9.30</span>, <span class="number">11.2</span>])</span><br><span class="line"></span><br><span class="line">popt,pcov=curve_fit(y,x0,y0) <span class="comment">#返回值popt是拟合的参数，pcov是参数的协方差矩阵</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合的参数值为：&#x27;</span>,popt)</span><br><span class="line"><span class="comment">#此处*popt是序列解包，就是把列表popt的包装解开，得到几个元素，作为y的参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x=0.25时的预测值为：&#x27;</span>,y(<span class="number">0.25</span>,*popt)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x=0.35时的预测值为：&#x27;</span>,y(<span class="number">0.35</span>,*popt))</span><br><span class="line"></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>,family=<span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.plot(x0,y0,<span class="string">&#x27;*&#x27;</span>,x0,y(x0,*popt))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h5 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h5><p>用下标数据拟合二元函数  :  $z&#x3D;ae^{bx}+cy^2$ </p><table><thead><tr><th>x</th><th>6</th><th>2</th><th>6</th><th>7</th><th>4</th><th>2</th><th>5</th><th>9</th></tr></thead><tbody><tr><td>y</td><td>4</td><td>9</td><td>5</td><td>3</td><td>8</td><td>5</td><td>8</td><td>2</td></tr><tr><td>z</td><td>5</td><td>2</td><td>1</td><td>9</td><td>7</td><td>4</td><td>3</td><td>3</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"></span><br><span class="line">x0=np.array([<span class="number">6</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>])</span><br><span class="line">y0=np.array([<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>])</span><br><span class="line">z0=np.array([<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">xy0=np.vstack((x0,y0))  <span class="comment"># 将x和y变为二维数组</span></span><br><span class="line"><span class="comment">#print(xy0)</span></span><br><span class="line"></span><br><span class="line">z_fun=<span class="keyword">lambda</span> t,a,b,c: a*np.exp(b*t[<span class="number">0</span>]) + c*t[<span class="number">1</span>]**<span class="number">2</span></span><br><span class="line">popt,pcov=curve_fit(z_fun,xy0,z0) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a,b,c的拟合值为：&#x27;</span>,popt)</span><br></pre></td></tr></table></figure><h5 id="例题四"><a href="#例题四" class="headerlink" title="例题四"></a>例题四</h5><p>利用模拟数据拟合曲面 $z&#x3D;e^{-\frac{(x-\mu_1)^2+(y-\mu_2)^2}{2\sigma^2}}$ , 并画出拟合曲面的图形</p><p>其中$\mu_1&#x3D;1$,$\mu_2 &#x3D;2$,$\sigma&#x3D;3$，生成加噪声的模拟数据$\mu_1&#x3D;1.0097$,$\mu_2 &#x3D;1.9968$,$\sigma&#x3D;3.0028$</p><p>画出拟合曲面:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">m=<span class="number">200</span></span><br><span class="line">n=<span class="number">300</span></span><br><span class="line">x=np.linspace(-<span class="number">6</span>,<span class="number">6</span>,m)  <span class="comment">#生成200个点</span></span><br><span class="line">y=np.linspace(-<span class="number">8</span>,<span class="number">8</span>,n)  <span class="comment">#生成300个点</span></span><br><span class="line">x2,y2=np.meshgrid(x,y) <span class="comment">#相当于在xoy平面生成所有的网格点</span></span><br><span class="line"></span><br><span class="line">x3=np.reshape(x2,(<span class="number">1</span>,-<span class="number">1</span>)) <span class="comment">#把x2的数据转换成一行，1表示1行，-1是通配符</span></span><br><span class="line">y3=np.reshape(y2,(<span class="number">1</span>,-<span class="number">1</span>)) </span><br><span class="line">xy=np.vstack((x3,y3)) <span class="comment">#叠加成两行的数组</span></span><br><span class="line"><span class="comment">#print(&#x27;xy=&#x27;,xy) #不懂vstack函数时可以用print输出观察，然后再注释掉</span></span><br><span class="line"></span><br><span class="line">pfun=<span class="keyword">lambda</span> t,mu1,mu2,sigma: np.exp(-((t[<span class="number">0</span>]-mu1)**<span class="number">2</span>+(t[<span class="number">1</span>]-mu2)**<span class="number">2</span>)/(<span class="number">2</span>*sigma**<span class="number">2</span>))</span><br><span class="line">z=pfun(xy,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">zr=z+<span class="number">0.2</span>*np.random.normal(size=z.shape) <span class="comment">#加了噪声的数据</span></span><br><span class="line"></span><br><span class="line">popt,pcov=curve_fit(pfun,xy,zr) <span class="comment">#拟合参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;三个参数的拟合值分别为：&#x27;</span>,popt)</span><br><span class="line">zn=pfun(xy,*popt) <span class="comment">#计算拟合函数的值</span></span><br><span class="line"></span><br><span class="line">zn2=np.reshape(zn,x2.shape)</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">ax=plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>) <span class="comment">#创建一个三维坐标轴对象</span></span><br><span class="line">ax.plot_surface(x2,y2,zn2,cmap=<span class="string">&#x27;gist_rainbow&#x27;</span>) <span class="comment">#gist_rainbow是曲面颜色参数</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://cdn.jsdelivr.net/gh/Javis-Yu/img/img/shumo6.png" alt="shumo6"></p><h3 id="数学建模之回归分析"><a href="#数学建模之回归分析" class="headerlink" title="数学建模之回归分析"></a>数学建模之回归分析</h3><h4 id="多元线性回归模型"><a href="#多元线性回归模型" class="headerlink" title="多元线性回归模型"></a>多元线性回归模型</h4><p>通过对变量实际观测的分析、计算，建立一个变量与另一组变量的定量关系即回归方程，经统计检验认为回归效果显著后，可用于<strong>预测与控制</strong></p><p>设随机变量 $y$ 与变量 $x_1,x_2,…,x_m$ 有关则其 $m$ 元线性回归模型为：<br>$$<br>y&#x3D;\beta_0+\beta_1x_1+…+\beta_mx_m+\varepsilon<br>$$<br>$\varepsilon$是随机误差服从正态分布  $N(0,\sigma^2)$  ,$\beta_0,\beta_1,…,\beta_m$ 为回归系数。</p><h4 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h4><h5 id="由观察确定回归系数"><a href="#由观察确定回归系数" class="headerlink" title="由观察确定回归系数"></a>由观察确定回归系数</h5><p>$\beta_0,\beta_1,…,\beta_m$  的估计值  $b_0,b_1,…,b_m$</p><p>将 $n$ 组数据  $(y_i,x_{i1},..,x_{im})$  ,$i&#x3D;1,…,n (n&gt;m)$  带入 $y&#x3D;\beta_0+\beta_1x_1+…+\beta_mx_m+\varepsilon$ 有<br>$$<br>y_i&#x3D;\beta_0+\beta_1x_{i1}+…+\beta_mx_{im}+\varepsilon_i<br>$$</p><p>$$<br>记\ \ X&#x3D;<br>\begin{bmatrix}<br>1   &amp; x_{11} &amp; x_{12} &amp; \cdots  &amp; x_{1m}\<br>1   &amp; x_{21} &amp; x_{22} &amp; \cdots  &amp; x_{2m}\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>1   &amp; x_{n1} &amp; x_{n2} &amp; \cdots  &amp; x_{nm}<br>\end{bmatrix},</p><p>Y&#x3D;<br>\begin{bmatrix}<br>y_{1} \<br>y_{2} \<br>\vdots \<br>y_{n}<br>\end{bmatrix},</p><p>\varepsilon&#x3D;<br>\begin{bmatrix}<br>\varepsilon_1 \ \varepsilon_2 \ \cdots \varepsilon_n<br>\end{bmatrix}^T,</p><p>\beta&#x3D;<br>\begin{bmatrix}<br>\beta_1 \ \beta_2 \ \cdots \beta_n<br>\end{bmatrix}^T.<br>$$</p><p> 则正规方程组为：$Y&#x3D;X \ \beta + \varepsilon$ , 正规方程组的回归系数的最小二乘法估计 $\hat{\beta}$ 为：<br>$$<br>\hat{\beta} &#x3D; (X^TX)^{-1}X^TY<br>$$<br>将$\hat{\beta}&#x3D;[b_0,b_1,…,b_m]$ 带入$y&#x3D;\beta_0+\beta_1x_1+…+\beta_mx_m+\varepsilon$   得到方程：<br>$$<br>y&#x3D;b_0+b_1x_1+…+b_mx_m<br>$$<br>将数据代入，则得 $y$ 的估计值:<br>$$<br>\hat{y} &#x3D; b_0+b_1x_1+…+b_mx_m<br>$$<br>估计值的残差平方和为:<br>$$<br>SSE&#x3D;\sum_{i&#x3D;1}^{n}e_i^2&#x3D;\sum_{i&#x3D;1}^{n}(y_i-\hat{y_i})^2<br>$$<br>回归平方和为:<br>$$<br>SSR&#x3D;\sum_{i&#x3D;1}^{n}(\overline{y}-\hat{y_i})^2<br>$$</p><h5 id="对线性关系、自变量的显著性进行统计检验"><a href="#对线性关系、自变量的显著性进行统计检验" class="headerlink" title="对线性关系、自变量的显著性进行统计检验"></a>对线性关系、自变量的显著性进行统计检验</h5><p>上面完美建立的线性回归方程是假定了变量$y$与$x_1,x_2,…,x_m$ 是有关系的，但真的是否有线性关系吗？需要做统计检验。</p><p>首先，因变量 $y$ 与 自变量$x_1,x_2,…,x_m$ 之间关系的检验方式，令原假设成立：<br>$$<br>H_0:\beta_1&#x3D;\beta_2&#x3D;…&#x3D;\beta_m&#x3D;0<br>$$<br>选择统计量$F&#x3D;\frac{SSR&#x2F;m}{SSE&#x2F;(n-m-1)}&#x3D;\frac{SSR\cdot(n-m-1)}{SSE\cdot  m}$~$F(m,n-m-1)$ 进行假设检验，对显著性水平$\alpha$ 和上分位数$F_\alpha(m,n-m-1)$ ,检验准则为：</p><ul><li><p>若 $ F&gt;F_\alpha(m,n-m-1)$,回归方程显著。</p></li><li><p>若 $ F&lt;F_\alpha(m,n-m-1)$,回归方程效果不显著。</p></li></ul><p>也可以采用复判定系数(也称拟合优度) $R^2&#x3D;\frac{SSR}{SSR+SSE}$ 作为权衡  $y$ 与 $x_1,x_2,…,x_m$ 相关程度的指标，$R&#x3D;\sqrt{R^2}$成为复相关系数，R越大，  $y$ 与 $x_1,x_2,…,x_m$ 相关关系越密切，通常R&gt;0.8&#x2F;0.9才认为相关关系成立。</p><h5 id="利用回归方程进行预测"><a href="#利用回归方程进行预测" class="headerlink" title="利用回归方程进行预测"></a>利用回归方程进行预测</h5><p>对于给定的$x_1^{(0)},x_2^{(0)},…,x_m^{(0)},$ 代入回归方程: $y&#x3D;b_0+b_1x_1+…+b_mx_m $ 得：<br>$$<br>\hat{y_0} &#x3D; b_0+b_1x_1^{(0)}+…+b_mx_m^{(0)},<br>$$<br>用 $\hat{y_0}$做 $y$ 在点$x_1^{(0)},x_2^{(0)},…,x_m^{(0)}$ 的预测值。</p><p>也可以进行区间的估计，记$s&#x3D;\sqrt{\frac{SSE}{n-m-1}} ， x_0&#x3D;[1,x_1^{(0)},x_2^{(0)},…,x_m^{(0)}]$ , 则$y_0$的置信度为$1-\alpha$ 的车预测区间为：<br>$$<br>(\ \hat{y}-t_{1-\alpha&#x2F;2}(n-m-1)s\sqrt{1+x_0^T(X^TX)^{-1}x_0}\ ,\ \hat{y}+t_{1-\alpha&#x2F;2}(n-m-1)s\sqrt{1+x_0^T(X^TX)^{-1}x_0}\ )<br>$$</p><h4 id="例题一："><a href="#例题一：" class="headerlink" title="例题一："></a>例题一：</h4><p>水泥凝固时放出的热量 y 与水泥中两种主要化学分成 x<sub>1</sub>,x<sub>2</sub> 有关，今测得一组数据如表1所示，试确定一个线性回归模型$y&#x3D;a_0+a_1x_1+a_2x_2$.</p><table><thead><tr><th>序号</th><th>$x_1$</th><th>$x_2$</th><th>$y$</th><th>序号</th><th>$x_1$</th><th>$x_2$</th><th>$y$</th></tr></thead><tbody><tr><td>1</td><td>7</td><td>26</td><td>78.5</td><td>8</td><td>1</td><td>31</td><td>72.5</td></tr><tr><td>2</td><td>1</td><td>29</td><td>74.3</td><td>9</td><td>2</td><td>54</td><td>93.1</td></tr><tr><td>3</td><td>11</td><td>56</td><td>104.3</td><td>10</td><td>21</td><td>47</td><td>115.9</td></tr><tr><td>4</td><td>11</td><td>31</td><td>87.6</td><td>11</td><td>1</td><td>40</td><td>83.8</td></tr><tr><td>5</td><td>7</td><td>52</td><td>95.9</td><td>12</td><td>11</td><td>66</td><td>113.3</td></tr><tr><td>6</td><td>11</td><td>55</td><td>109.2</td><td>13</td><td>10</td><td>68</td><td>109.4</td></tr><tr><td>7</td><td>3</td><td>71</td><td>102.7</td><td></td><td></td><td></td><td></td></tr></tbody></table><h5 id="程序一：利用模块sklearn-linear-model中的函数LinearRegression求解"><a href="#程序一：利用模块sklearn-linear-model中的函数LinearRegression求解" class="headerlink" title="程序一：利用模块sklearn.linear_model中的函数LinearRegression求解"></a>程序一：利用模块sklearn.linear_model中的函数LinearRegression求解</h5><p>解：求得回归模型为<br>$$<br>y&#x3D;52.5773+1.4683x_1+0.6623x_2<br>$$<br>模型的拟合优度$R^2&#x3D;0.9787$,说明拟合效果很好.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">a = np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡17_例2.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">md = LinearRegression().fit(a[:,:<span class="number">2</span>],a[:,<span class="number">2</span>]) <span class="comment">#构建并拟合模型</span></span><br><span class="line"><span class="comment">#上行切片表示用数据的所有行、前两列数据作自变量，所有行、最后一列的数据作因变量</span></span><br><span class="line">y=md.predict(a[:,:<span class="number">2</span>])   <span class="comment">#求预测值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测值为&#x27;</span>,y)      <span class="comment">#输出拟合好后的预测值</span></span><br><span class="line">b0=md.intercept_        <span class="comment">#输出回归模型中的常数项</span></span><br><span class="line">b12=md.coef_            <span class="comment">#输出回归模型的回归系数（常数项以外）</span></span><br><span class="line">R2=md.score(a[:,:<span class="number">2</span>],a[:,<span class="number">2</span>]) <span class="comment">#计算R^2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;回归模型的常数项为&#x27;</span>,b0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;回归模型的自变量系数为&#x27;</span>,b12)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度R^2=&#x27;</span>,R2)</span><br></pre></td></tr></table></figure><h4 id="线性回归模型的正则化求解"><a href="#线性回归模型的正则化求解" class="headerlink" title="线性回归模型的正则化求解"></a>线性回归模型的正则化求解</h4><p>在多元线性回归中，解释变量$x_1,x_2,…,x_m$之间出现严重的多重线性时，普通的最小二乘法估计模型参数，往往参数估计方差太大，使普通最小二乘法的效果很不理想. 为改进线性回归模型，采用线性回归正则化方法，岭回归和Lasso回归是其中的两种方法</p><p>这里我认为是机器学习中次方过大，导致过拟合，于是得到的函数干扰太大拟合效果不好。</p><h5 id="法一：岭回归"><a href="#法一：岭回归" class="headerlink" title="法一：岭回归"></a>法一：岭回归</h5><h6 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h6><p>Malinvand于1966年提出的研究法国经济问题的一组数据，如下表1. 所考虑的因变量为进口总额<strong>y</strong> , 三个解释变量分别为：国内总产值<strong>x<sub>1</sub><strong>、储存量</strong>x<sub>2</sub><strong>、总消费</strong>x<sub>3</sub></strong>(单位均为10亿法郎). 建立<strong>y与x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub>的关系</strong></p><table><thead><tr><th align="center">年份</th><th align="center">$x_1$</th><th align="center">$x_2$</th><th align="center">$x_3$</th><th align="center">$y$</th><th align="center">年份</th><th align="center">$x_1$</th><th align="center">$x_2$</th><th align="center">$x_3$</th><th align="center">$y$</th></tr></thead><tbody><tr><td align="center">1949</td><td align="center">149.3</td><td align="center">4.2</td><td align="center">108.1</td><td align="center">15.9</td><td align="center">1955</td><td align="center">202.1</td><td align="center">2.1</td><td align="center">146.0</td><td align="center">22.7</td></tr><tr><td align="center">1950</td><td align="center">171.5</td><td align="center">4.1</td><td align="center">114.8</td><td align="center">16.4</td><td align="center">1956</td><td align="center">212.4</td><td align="center">5.6</td><td align="center">154.1</td><td align="center">26.5</td></tr><tr><td align="center">1951</td><td align="center">175.5</td><td align="center">3.1</td><td align="center">123.2</td><td align="center">19.0</td><td align="center">1957</td><td align="center">226.1</td><td align="center">5.0</td><td align="center">162.3</td><td align="center">28.1</td></tr><tr><td align="center">1952</td><td align="center">180.8</td><td align="center">3.1</td><td align="center">126.9</td><td align="center">19.1</td><td align="center">1958</td><td align="center">231.9</td><td align="center">5.1</td><td align="center">164.3</td><td align="center">27.6</td></tr><tr><td align="center">1953</td><td align="center">190.7</td><td align="center">1.1</td><td align="center">132.1</td><td align="center">18.8</td><td align="center">1959</td><td align="center">239.0</td><td align="center">0.7</td><td align="center">167.6</td><td align="center">26.3</td></tr><tr><td align="center">1954</td><td align="center">202.1</td><td align="center">2.2</td><td align="center">137.7</td><td align="center">20.4</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h6 id="用最小二乘估计建立模型"><a href="#用最小二乘估计建立模型" class="headerlink" title="用最小二乘估计建立模型"></a>用最小二乘估计建立模型</h6><p>对于上述问题，可以直接用普通的最小二乘估计建立$y$关于三个解释变量x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub> 的回归方程为$y&#x3D;-8.6203-0.0742x_1+0.5104x_2+0.3116x_3$ , 并且模型的统计检验指标都相当好，但是$x_1$的系数为负数，这是不符合经济意义的，因为法国是一个原材料进口国，当国内总产值$x_1$增大时，进口总额$y$肯定也会增加，所以符号应该时正的。原因可能是三个自变量x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub> 之间存在多重共线性。</p><p>计算$x_1,x_2,x_3$的相关系数矩阵为：<br>$$<br>R&#x3D;<br>\begin{pmatrix}<br>1&amp;  -0.0329&amp; 0.9869\<br>-0.0329 &amp;  1&amp; 0.0357\<br>0.9869&amp;  0.0357&amp; 1<br>\end{pmatrix}<br>$$<br>可以看到$x_1\text{与}x_2$的相关系数高达0.9869，说明$x_1与x_3$基本线性相关，若将$x_3$看为因变量，$x_1$看作解释变量，那么$x_3$关于$x_1$的一元线性回归方程为：<br>$$<br>x_3&#x3D;-4.9632+0.7297x_1<br>$$<br>说明$x_3与x_1$之间存在着多重共线性关系。</p><h6 id="利用statsmodels库求解线性回归分析"><a href="#利用statsmodels库求解线性回归分析" class="headerlink" title="利用statsmodels库求解线性回归分析"></a>利用statsmodels库求解线性回归分析</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基于数组构建并拟合模型的调用格式为:</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line">sm.OLS(y,X).fit()</span><br></pre></td></tr></table></figure><p>程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line">a=np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡18_例1.txt&#x27;</span>)</span><br><span class="line"><span class="comment">#print(a)</span></span><br><span class="line"><span class="comment">#print(a[:5])</span></span><br><span class="line">x=a[:,:<span class="number">3</span>] <span class="comment">#提取自变量观察值矩阵</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">XG=sm.add_constant(x) <span class="comment">#增加第一列全部元素为1得到增广矩阵</span></span><br><span class="line"><span class="built_in">print</span>(XG)</span><br><span class="line"></span><br><span class="line">md=sm.OLS(a[:,<span class="number">3</span>],XG).fit()<span class="comment">#构建并拟合模型</span></span><br><span class="line">b=md.params <span class="comment">#提取所有回归系数</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;$&#x27;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">y=md.predict(XG) <span class="comment">#求已知自变量值的预测值</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;$&#x27;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(md.summary()) <span class="comment"># 输出模型的所有结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;相关系数矩阵：\n&#x27;</span>,np.corrcoef(x.T))</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成新的矩阵，第1列全部是1，第2列是a的第1列数据</span></span><br><span class="line">X1=sm.add_constant(a[:,<span class="number">0</span>])</span><br><span class="line"><span class="comment">#print(X1)</span></span><br><span class="line">md1=sm.OLS(a[:,<span class="number">2</span>],X1).fit() <span class="comment">#构建并拟合模型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;回归系数为：&#x27;</span>,md1.params)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$ print(md.summary()) #这一步中输出为：</span><br><span class="line"></span><br><span class="line">UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=11</span><br><span class="line">warnings.warn(&quot;kurtosistest only valid for n&gt;=20 ... continuing &quot;</span><br><span class="line">                   </span><br><span class="line">                   OLS Regression Results              </span><br><span class="line">====================================================================</span><br><span class="line">Dep. Variable:y         R-squared:                  0.996</span><br><span class="line">Model:  OLS         Adj. R-squared:             0.994</span><br><span class="line">Method:     Least Squares         F-statistic:                542.0</span><br><span class="line">Date:    Wed, 12 Aug 2020         Prob (F-statistic):      1.20e-08</span><br><span class="line">Time:            11:52:08         Log-Likelihood:           -1.7480</span><br><span class="line">No. Observations:      11         AIC:                        11.50</span><br><span class="line">Df Residuals:           7         BIC:                        13.09</span><br><span class="line">Df Model:               3                                         </span><br><span class="line">Covariance Type:nonrobust    </span><br><span class="line"></span><br><span class="line">#本人注释：1. Method: Least Squares(最小二乘法)  </span><br><span class="line"> 2.R-squared: 0.996(复判定系数或叫拟合优度R^2,越高拟合越好)</span><br><span class="line"></span><br><span class="line">====================================================================</span><br><span class="line">          coef    std err      t       P&gt;|t|      [0.025      0.975]</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">const    -8.6203    0.897    -9.611     0.000    -10.741     -6.499</span><br><span class="line">x1       -0.0742    0.028    -2.691     0.031    -0.139      -0.009</span><br><span class="line">x2        0.5104    0.075     6.781     0.000     0.332       0.688</span><br><span class="line">x3        0.3116    0.037     8.357     0.000     0.223       0.400</span><br><span class="line">====================================================================</span><br><span class="line">Omnibus:           5.258        Durbin-Watson:              2.400</span><br><span class="line">Prob(Omnibus):     0.072        Jarque-Bera (JB):           2.250</span><br><span class="line">Skew:              1.080        Prob(JB):                   0.325</span><br><span class="line">Kurtosis:          3.495        Cond. No.                2.05e+03</span><br><span class="line"></span><br><span class="line">#本人注释：1.coef所对应的那一列 拟合系数</span><br><span class="line"></span><br><span class="line">====================================================================</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line">[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</span><br><span class="line">[2] The condition number is large, 2.05e+03. This might indicate that there are</span><br><span class="line">strong multicollinearity or other numerical problems.</span><br><span class="line"></span><br><span class="line">相关系数矩阵：</span><br><span class="line"> [[ 1.         -0.03291436  0.98690551]---&gt;&gt;0.9869很高x1与x2相关性很大</span><br><span class="line"> [-0.03291436  1.          0.03567322]</span><br><span class="line"> [ 0.98690551  0.03567322  1.        ]]</span><br><span class="line"> </span><br><span class="line">回归系数为： [-4.96322784  0.72966696]  ---&gt; x3=-4.963+0.72967*x1</span><br></pre></td></tr></table></figure><h5 id="改进的模型：岭回归方程"><a href="#改进的模型：岭回归方程" class="headerlink" title="改进的模型：岭回归方程"></a>改进的模型：岭回归方程</h5><p>为了消除变量之间的多重共线性关系的影响，即消除最小二乘解的参数估计$\hat{\beta} &#x3D; (X^TX)^{-1}X^TY中X^TY的奇异性$，采用岭回归模型，即参数估计为：<br>$$<br>\hat{\beta} (k)&#x3D; (X^TX+kI)^{-1}X^TY<br>$$<br>其中，k是岭参数.   岭参数的选择有岭迹法和均方误差法.</p><p>求上面那道例题的岭回归方程：</p><p>我们可以解得k&#x3D;0.15时，取得较好的拟合效果。对应的标准化岭回归方程为：<br>$$<br>\hat{y}^*&#x3D;0.0610x_1+0.2179x_2+0.8926x_3<br>$$<br>将标准化的回归方程还原后得:<br>$$<br>\hat{y}&#x3D;-9.5320+0.0410x_1+0.6231x_2+0.1520x_3<br>$$<br>拟合优度为 0.9899</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge,RidgeCV</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> zscore</span><br><span class="line"></span><br><span class="line">a=np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡18_例1.txt&#x27;</span>)</span><br><span class="line">n=a.shape[<span class="number">1</span>]-<span class="number">1</span>  <span class="comment">#设置自变量的总个数</span></span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line">aa=zscore(a) <span class="comment">#数据的标准化</span></span><br><span class="line">x=aa[:,:n]   <span class="comment">#提出自变量观察值矩阵 取前三列x1\x2\x3</span></span><br><span class="line">y=aa[:,n]    <span class="comment">#提出因变量矩阵      取最后一列y</span></span><br><span class="line">b=[]         <span class="comment">#用于存储回归系数的空列表</span></span><br><span class="line"></span><br><span class="line">kk=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)  <span class="comment">#设置的不同k值</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> kk:              <span class="comment">#循环迭代的不同k值</span></span><br><span class="line">    md=Ridge(alpha=k).fit(x,y)</span><br><span class="line">    b.append(md.coef_)    <span class="comment">#系数保存在列表中</span></span><br><span class="line"></span><br><span class="line">st=[<span class="string">&#x27;s-r&#x27;</span>,<span class="string">&#x27;*-k&#x27;</span>,<span class="string">&#x27;p-b&#x27;</span>]       <span class="comment">#下面画图的控制字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.plot(kk,np.array(b)[:,i],st[i]) <span class="comment">#作图</span></span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>,<span class="string">&#x27;x3&#x27;</span>],fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">mdcv=RidgeCV(alphas=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)).fit(x,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优alpha=&#x27;</span>,mdcv.alpha_)</span><br><span class="line"></span><br><span class="line"><span class="comment">#md0=Ridge(mdcv.alpha_).fit(x,y) #构建并拟合模型.先选择此行命令，得到最佳k值，但拟合出的x1的系数是负</span></span><br><span class="line">md0=Ridge(<span class="number">0.15</span>).fit(x,y)  <span class="comment">#x1的系数是负，所以这里主观选择k=0.15时得到的拟合优度高，而且变量的拟合系数都是正的</span></span><br><span class="line">cs0=md0.coef_ <span class="comment">#提取标准化数据的回归系数b1,b2,b3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准化数据的所有回归系数为：&#x27;</span>,cs0)</span><br><span class="line"></span><br><span class="line">mu=np.mean(a,axis=<span class="number">0</span>) <span class="comment">#计算所有指标的均值</span></span><br><span class="line">s=np.std(a,axis=<span class="number">0</span>,ddof=<span class="number">1</span>)  <span class="comment">#计算所有的标准差</span></span><br><span class="line">params=[mu[-<span class="number">1</span>]-s[-<span class="number">1</span>]*<span class="built_in">sum</span>(cs0*mu[:-<span class="number">1</span>]/s[:-<span class="number">1</span>]),s[-<span class="number">1</span>]*cs0/s[:-<span class="number">1</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数据的回归系数为：&#x27;</span>,params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度为&#x27;</span>,md0.score(x,y))</span><br></pre></td></tr></table></figure><h4 id="lasson-回归"><a href="#lasson-回归" class="headerlink" title="lasson  回归"></a>lasson  回归</h4><h5 id="数学原理简介"><a href="#数学原理简介" class="headerlink" title="数学原理简介"></a>数学原理简介</h5><p>多元回归中的普通最小二乘法是拟合参数向量$\beta$，使得$\left |X\beta-Y \right |^2_2$达到最小值. 岭回归是选择了合适的参数$k\geq 0$ ,拟合参数向量$\beta$ ,使得$\left |X\beta-Y \right |^2_2-\left |k\beta \right |^2_2$达到最小值，解决了$X^TX$不可逆的问题. Lasso回归，是选择合适的参数$k\geq 0$ ,拟合参数向量$\beta$ ,使得<br>$$<br>J(\beta)&#x3D;\left |X\beta-Y \right |^2_2-\left |k\beta \right |_1<br>$$<br>达到最小值，$\left |k\beta \right |_1$为目标函数的惩罚项，k为惩罚系数</p><p>lasson回归</p><p>由于拟合Lasso回归模型参数时，使用的损失函数（机器学习中的用语）中包含惩罚系数k,因此在计算模型回归系数之前，仍然需要得到最理想的k值，与岭回归模型类似，k值的确定可以通过定性的可视化方法.</p><h6 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h6><p>用此方法求解：（上面题的Lasso回归的题目）</p><p>Malinvand于1966年提出的研究法国经济问题的一组数据，如下表1. 所考虑的因变量为进口总额<strong>y</strong> , 三个解释变量分别为：国内总产值<strong>x<sub>1</sub><strong>、储存量</strong>x<sub>2</sub><strong>、总消费</strong>x<sub>3</sub></strong>(单位均为10亿法郎). 建立<strong>y与x<sub>1</sub>、x<sub>2</sub>、x<sub>3</sub>的关系</strong></p><table><thead><tr><th align="center">年份</th><th align="center">$x_1$</th><th align="center">$x_2$</th><th align="center">$x_3$</th><th align="center">$y$</th><th align="center">年份</th><th align="center">$x_1$</th><th align="center">$x_2$</th><th align="center">$x_3$</th><th align="center">$y$</th></tr></thead><tbody><tr><td align="center">1949</td><td align="center">149.3</td><td align="center">4.2</td><td align="center">108.1</td><td align="center">15.9</td><td align="center">1955</td><td align="center">202.1</td><td align="center">2.1</td><td align="center">146.0</td><td align="center">22.7</td></tr><tr><td align="center">1950</td><td align="center">171.5</td><td align="center">4.1</td><td align="center">114.8</td><td align="center">16.4</td><td align="center">1956</td><td align="center">212.4</td><td align="center">5.6</td><td align="center">154.1</td><td align="center">26.5</td></tr><tr><td align="center">1951</td><td align="center">175.5</td><td align="center">3.1</td><td align="center">123.2</td><td align="center">19.0</td><td align="center">1957</td><td align="center">226.1</td><td align="center">5.0</td><td align="center">162.3</td><td align="center">28.1</td></tr><tr><td align="center">1952</td><td align="center">180.8</td><td align="center">3.1</td><td align="center">126.9</td><td align="center">19.1</td><td align="center">1958</td><td align="center">231.9</td><td align="center">5.1</td><td align="center">164.3</td><td align="center">27.6</td></tr><tr><td align="center">1953</td><td align="center">190.7</td><td align="center">1.1</td><td align="center">132.1</td><td align="center">18.8</td><td align="center">1959</td><td align="center">239.0</td><td align="center">0.7</td><td align="center">167.6</td><td align="center">26.3</td></tr><tr><td align="center">1954</td><td align="center">202.1</td><td align="center">2.2</td><td align="center">137.7</td><td align="center">20.4</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso, LassoCV</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> zscore</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size=<span class="number">16</span>)</span><br><span class="line">a=np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡18_例1.txt&#x27;</span>)</span><br><span class="line">n=a.shape[<span class="number">1</span>]-<span class="number">1</span>              <span class="comment">#自变量的总个数</span></span><br><span class="line">aa=zscore(a)                <span class="comment">#数据标准化</span></span><br><span class="line">x=aa[:,:n]                  <span class="comment">#提取自变量观测值矩阵</span></span><br><span class="line">y=aa[:,n]                   <span class="comment">#提取因变量观察值矩阵</span></span><br><span class="line">b=[]                        <span class="comment">#用于存储回归系数的空列表</span></span><br><span class="line"></span><br><span class="line">kk=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)    <span class="comment">#生成从10的a次方到10的b次方之间按对数等分的n个元素的行向量</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> kk:                <span class="comment">#循环迭代的不同k值</span></span><br><span class="line">    md=Lasso(alpha=k).fit(x,y)</span><br><span class="line">    b.append(md.coef_)</span><br><span class="line"></span><br><span class="line">st=[<span class="string">&#x27;s-r&#x27;</span>,<span class="string">&#x27;*-k&#x27;</span>,<span class="string">&#x27;p-b&#x27;</span>]      <span class="comment">#下面画图的控制字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.plot(kk,np.array(b)[:,i],st[i])</span><br><span class="line">plt.legend([<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>,<span class="string">&#x27;x3&#x27;</span>],fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">mdcv=LassoCV(alphas=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)).fit(x,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优alpha=&#x27;</span>,mdcv.alpha_)</span><br><span class="line"></span><br><span class="line"><span class="comment">#md0=Lasso(mdcv.alpha_).fit(x,y) #构建并拟合模型</span></span><br><span class="line"></span><br><span class="line">md0=Lasso(<span class="number">0.21</span>).fit(x,y) <span class="comment">#构建并拟合模型</span></span><br><span class="line">cs0=md0.coef_  <span class="comment">#提出标准化数据回归系数b1,b2,b3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准化数据的所有回归系数为：&#x27;</span>,cs0)</span><br><span class="line"></span><br><span class="line">mu=np.mean(a,axis=<span class="number">0</span>)  <span class="comment">#计算所有指标的均值</span></span><br><span class="line">s=np.std(a,axis=<span class="number">0</span>,ddof=<span class="number">1</span>)  <span class="comment">#计算所有指标的标准差</span></span><br><span class="line"></span><br><span class="line">params=[mu[-<span class="number">1</span>]-s[-<span class="number">1</span>]*<span class="built_in">sum</span>(cs0*mu[:<span class="number">1</span>]/s[:-<span class="number">1</span>]),s[-<span class="number">1</span>]*cs0/s[:-<span class="number">1</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数据的回归系数为：&#x27;</span>,params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度：&#x27;</span>,md0.score(x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h6><p>在建立中国私人轿车拥有量模型时，主要考虑一下因素：</p><ul><li>城镇居民家庭人均可支配收入$x_1$元</li><li>全国城镇人口$x_2$亿元</li><li>全国汽车产量$x_3$万辆</li><li>全国公路长度$x_4$万千米</li><li>中国私人轿车拥有量为 $y$ 万辆</li></ul><p>求建立y的经验公式</p><table><thead><tr><th>年份</th><th>$x_1$</th><th>$x_2$</th><th>$x_3$</th><th>$x_4$</th><th>$y$</th></tr></thead><tbody><tr><td>1994</td><td>3496.2</td><td>3.43</td><td>136.69</td><td>111.78</td><td>205.42</td></tr><tr><td>1995</td><td>4283</td><td>3.52</td><td>145.27</td><td>115.7</td><td>249.96</td></tr><tr><td>1996</td><td>4838.9</td><td>3.73</td><td>147.52</td><td>118.58</td><td>289.67</td></tr><tr><td>1997</td><td>5160.3</td><td>3.94</td><td>158.25</td><td>122.64</td><td>358.36</td></tr><tr><td>1998</td><td>5425.1</td><td>4.16</td><td>163</td><td>127.85</td><td>423.65</td></tr><tr><td>1999</td><td>5854</td><td>4.37</td><td>183.2</td><td>135.17</td><td>533.88</td></tr><tr><td>2000</td><td>6280</td><td>4.59</td><td>207</td><td>140.27</td><td>625.33</td></tr><tr><td>2001</td><td>6859.6</td><td>4.81</td><td>234.17</td><td>169.8</td><td>770.78</td></tr><tr><td>2002</td><td>7702.8</td><td>5.02</td><td>325.1</td><td>176.52</td><td>968.98</td></tr></tbody></table><p>解 &#x3D;&#x3D;（建模思路：可先用普通最小二乘法建立模型，找出不足，然后提出用Lasso模型进行改进，这样体现了建模的逐渐深入和完善的过程，论文也有层次）&#x3D;&#x3D;</p><p>首先，最小二乘法建立y与变量之间的关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"></span><br><span class="line">a  = np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡19_例2.txt&#x27;</span>)</span><br><span class="line">n  = a.shape[<span class="number">1</span>]-<span class="number">1</span>               <span class="comment"># 算出自变量数目</span></span><br><span class="line">x  = a[:,:n]                    <span class="comment"># 得到所有的自变量</span></span><br><span class="line">XG = sm.add_constant(x)         <span class="comment"># 变量标准化</span></span><br><span class="line">md = sm.OLS(a[:,n],XG).fit()    <span class="comment"># 构建并拟合模型</span></span><br><span class="line"><span class="built_in">print</span>(md.summary())             <span class="comment"># 输出模型的所有结果</span></span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">                   OLS Regression Results                  </span><br><span class="line">====================================================================</span><br><span class="line">Dep. Variable:            y       R-squared:  拟合度            0.999</span><br><span class="line">Model:                  OLS       Adj. R-squared:              0.999</span><br><span class="line">Date:      Thu, 13 Aug 2020       Prob (F-statistic):       1.14e-06</span><br><span class="line">Time:              20:39:48       Log-Likelihood:            -28.919</span><br><span class="line">No. Observations:         9       AIC:                         67.84</span><br><span class="line">Df Residuals:             4       BIC:                         68.82</span><br><span class="line">Df Model:                 4                                        </span><br><span class="line">Covariance Type:  nonrobust                                         </span><br><span class="line">====================================================================</span><br><span class="line">          coef       std err    t      P&gt;|t|     [0.025     0.975]</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">const  -1028.4134    58.305   -17.638   0.000   -1190.294   -866.532</span><br><span class="line">x1        -0.0159     0.015    -1.043   0.356      -0.058      0.026</span><br><span class="line">x2       245.6120    34.213     7.179   0.002     150.622    340.602</span><br><span class="line">x3         1.6316     0.178     9.148   0.001       1.136      2.127</span><br><span class="line">x4         2.0294     0.580     3.500   0.025       0.420      3.639</span><br><span class="line">      这上面就是系数了                 0.356大于0.05</span><br><span class="line">                                    说明x1对y不显著</span><br><span class="line">====================================================================</span><br><span class="line">Omnibus:           0.575      Durbin-Watson:                   2.151</span><br><span class="line">Prob(Omnibus):     0.750      Jarque-Bera (JB):                0.560</span><br><span class="line">Skew:              0.368      Prob(JB):                        0.756</span><br><span class="line">Kurtosis:          2.025      Cond. No.                     1.24e+05</span><br><span class="line">====================================================================</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line">[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</span><br><span class="line">[2] The condition number is large, 1.24e+05. This might indicate that there are</span><br><span class="line">strong multicollinearity or other numerical problems.</span><br></pre></td></tr></table></figure><p>这里曲线拟合$R^2&#x3D;0.999$ 拟合效果很好，但是看到$x_1系数&lt;0$所以不符合现实，且在显著水平$\alpha&#x3D;0.05$下，x1对y不显著。</p><p>这里输出结果中，写出了所有变量前面的系数。<br>$$<br>\hat{y}&#x3D;-1028.4134-0.0159x_1+245.6120x_2+1.6316x_3+2.0294x_4<br>$$<br>所以我们要优化：Lasso回归部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso,LassoCV</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> zscore</span><br><span class="line"></span><br><span class="line">a  = np.loadtxt(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡19_例2.txt&#x27;</span>)</span><br><span class="line">n  = a.shape[<span class="number">1</span>]-<span class="number">1</span>               <span class="comment"># 算出自变量数目</span></span><br><span class="line">aa = zscore(a)                  <span class="comment"># 数据标准化</span></span><br><span class="line">x  = aa[:,:n]                   <span class="comment"># 提出自变量的观测值</span></span><br><span class="line">y  = aa[:, n]                   <span class="comment"># 提出因变量的观测值矩阵</span></span><br><span class="line"></span><br><span class="line">b  = []                         <span class="comment"># 用于存储回归系数的空列表</span></span><br><span class="line">kk = np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)      <span class="comment"># 将-4到0进行99等分得到100个数的等差数列，再生成以10为底的，以等差数列的值为指数的等比数列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> kk :</span><br><span class="line">    md=Lasso(alpha=k).fit(x,y)  <span class="comment"># 循环遍历所有的k</span></span><br><span class="line">    b.append(md.coef_)          <span class="comment"># 得到系数</span></span><br><span class="line"></span><br><span class="line">st=[<span class="string">&#x27;s-r&#x27;</span>,<span class="string">&#x27;*-k&#x27;</span>,<span class="string">&#x27;p-b&#x27;</span>,<span class="string">&#x27;^-y&#x27;</span>]    <span class="comment">#下面画图的控制字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    plt.plot(kk,np.array(b)[:,i],st[i])</span><br><span class="line">plt.legend([<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>,<span class="string">&#x27;x3&#x27;</span>,<span class="string">&#x27;x4&#x27;</span>],fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">mdcv = LassoCV(alphas=np.logspace(-<span class="number">4</span>,<span class="number">0</span>,<span class="number">100</span>)).fit(x,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优 alpha=&#x27;</span>,mdcv.alpha_)</span><br><span class="line"><span class="comment">#md0=Lasso(mdcv.alpha_).fit(x,y)  # 构建并拟合模型</span></span><br><span class="line">md0 = Lasso(<span class="number">0.05</span>).fit(x,y)</span><br><span class="line"></span><br><span class="line">cs0=md0.coef_                     <span class="comment"># 取出标准化数据的回归系数b1.b2,b3,b4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准化数据的所有回归系数为：&#x27;</span>,cs0)</span><br><span class="line"></span><br><span class="line">mu = a.mean(axis=<span class="number">0</span>)               <span class="comment">#计算所有指标的均差</span></span><br><span class="line">s  = a.std(axis=<span class="number">0</span>,ddof=<span class="number">1</span>)         <span class="comment">#计算所有指标的方差</span></span><br><span class="line">params = [mu[-<span class="number">1</span>]-s[-<span class="number">1</span>]*<span class="built_in">sum</span>(cs0*mu[:-<span class="number">1</span>]),s[-<span class="number">1</span>]*cs0/s[:-<span class="number">1</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数据的回归系数为:&#x27;</span>,params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合优度：&#x27;</span>,md0.score(x,y))</span><br></pre></td></tr></table></figure><p>拓展阅读：（了解就可以了，明白什么时候选择Lasso回归合适.）</p><p>对于高维数据，维数灾难所带来的过拟合问题，其解决思路是：1）增加样本量；2）减少样本特征，而对于现实情况，会存在所能获取到的样本数据量有限的情况，甚至远小于数据维度，即：d&gt;&gt;n。如证券市场交易数据、多媒体图形图像视频数据、航天航空采集数据、生物特征数据等。 </p><p>主成分分析作为一种数据降维方法，其出发点是通过整合原本的单一变量来得到一组新的综合变量，综合变量所代表的意义丰富且变量间互不相关，综合变量包含了原变量大部分的信息，这些综合变量称为主成分。主成分分析是在保留所有原变量的基础上，通过原变量的线性组合得到主成分，选取少数主成分就可保留原变量的绝大部分信息，这样就可用这几个主成分来代替原变量，从而达到降维的目的。</p><p>主成分分析法只适用于数据空间维度小于样本量的情况，当数据空间维度很高时，将不再适用。</p><p><strong>Lasso是另一种数据降维方法，该方法不仅适用于线性情况，也适用于非线性情况。Lasso是基于惩罚方法对样本数据进行变量选择，通过对原本的系数进行压缩，将原本很小的系数直接压缩至0，从而将这部分系数所对应的变量视为非显著性变量，将不显著的变量直接舍弃。</strong></p><h2 id="常用的数据清洗方法"><a href="#常用的数据清洗方法" class="headerlink" title="常用的数据清洗方法"></a>常用的数据清洗方法</h2><p>在数据处理的过程中，一般都需要进行数据的清洗工作，如数据集是否存在重复、缺失，数据是否具有完整性和一致性、数据中是否存在异常值等. 当发现数据中存在如上可能的问题时，都需要有针对性地处理。现在介绍如何识别和处理重复观察、缺失值和异常值.</p><h3 id="重复观测处理"><a href="#重复观测处理" class="headerlink" title="重复观测处理"></a>重复观测处理</h3><p>运用pandas对读入的数据进行重复项检查，以及如何删除数据中的重复项。</p><center>数据一</center><table><thead><tr><th>appcategory</th><th>appname</th><th>comments</th><th>install</th><th>love</th><th>size</th><th>update</th></tr></thead><tbody><tr><td>网上购物-商城-团购-优惠-快递</td><td>每日优鲜</td><td>1297</td><td>204.7万</td><td>89.00%</td><td>15.16MB</td><td>2017年10月11日</td></tr><tr><td>网上购物-商城</td><td>苏宁易购</td><td>577</td><td>7996.8万</td><td>73.00%</td><td>58.9MB</td><td>2017年09月21日</td></tr><tr><td>网上购物-商城-优惠</td><td>唯品会</td><td>2543</td><td>7090.1万</td><td>86.00%</td><td>41.43MB</td><td>2017年10月13日</td></tr><tr><td>网上购物-商城-优惠</td><td>唯品会</td><td>2543</td><td>7090.1万</td><td>86.00%</td><td>41.43MB</td><td>2017年10月13日</td></tr><tr><td>网上购物-商城</td><td>拼多多</td><td>1921</td><td>3841.9万</td><td>95.00%</td><td>13.35MB</td><td>2017年10月11日</td></tr><tr><td>网上购物-商城-优惠</td><td>寺库奢侈品</td><td>1964</td><td>175.4万</td><td>100.00%</td><td>17.21MB</td><td>2017年09月30日</td></tr><tr><td>网上购物-商城</td><td>淘宝</td><td>14244</td><td>4.6亿</td><td>68.00%</td><td>73.78MB</td><td>2017年10月13日</td></tr><tr><td>网上购物-商城-团购-优惠</td><td>当当</td><td>134</td><td>1615.3万</td><td>61.00%</td><td>37.01MB</td><td>2017年10月17日</td></tr><tr><td>网上购物-商城-团购-优惠</td><td>当当</td><td>134</td><td>1615.3万</td><td>61.00%</td><td>37.01MB</td><td>2017年10月17日</td></tr><tr><td>网上购物-商城-团购-优惠</td><td>当当</td><td>134</td><td>1615.3万</td><td>61.00%</td><td>37.01MB</td><td>2017年10月17日</td></tr></tbody></table><p>这里很直观的看到有很多数据重复了。</p><p>方法：检查上述的数据集是否有重复，pandas中使用duplicated方法，该方法返回的是数据行每一行的检验结果，即每一行的返回一个bool值，使用drop_duplicates方法移除重复值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">a  = pd.read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例1.xlsx&#x27;</span>) <span class="comment">#读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;是否有重复观测：&#x27;</span>,<span class="built_in">any</span>(a.duplicated()))    <span class="comment"># 有重复的值，则输出True</span></span><br><span class="line">a.drop_duplicates(inplace=<span class="literal">True</span>)                <span class="comment"># inplace=True时，直接删除a中的重复数据</span></span><br><span class="line"></span><br><span class="line">f=pd.ExcelWriter(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例1_已删除重复.xlsx&#x27;</span>) <span class="comment"># 创建文件的对象</span></span><br><span class="line">a.to_excel(f)                                  <span class="comment"># 把a已筛选的数据写入Excel中</span></span><br><span class="line">f.save()                                       <span class="comment">#保存文件，数据才真正写入excel文件,查看所保存的路径下的文件夹，已有excel新文件</span></span><br></pre></td></tr></table></figure><h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>Pandas使用浮点值NaN表示浮点或浮点数组中的缺失数据，Python内置的None值也会被当作缺失值处理. Pandas使用方法isnull 检测是否为缺失值，检测对象的每个元素返回一个bool值.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检测是否有缺失值</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> NaN</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data=pd.Series([<span class="number">10.0</span>,<span class="literal">None</span>,NaN,<span class="number">30</span>])</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(data.isnull())        <span class="comment"># 输出每个元素的检测结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;是否存在缺失值：&#x27;</span>,<span class="built_in">any</span>(data.isnull()))    <span class="comment"># 输出True</span></span><br></pre></td></tr></table></figure><h4 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h4><h5 id="过滤法、删除法"><a href="#过滤法、删除法" class="headerlink" title="过滤法、删除法"></a>过滤法、删除法</h5><ul><li>dropna方法，适用于缺失值的观测对象所占比例非常低（如5%以内），直接删除缺失值所在的观测对象。因为对结果影响不大</li></ul><h5 id="填充法、替换法"><a href="#填充法、替换法" class="headerlink" title="填充法、替换法"></a>填充法、替换法</h5><ul><li>用某种常数值替换缺失值，使用fillna方法。例如对连续变量而言，用中位数或均值；对于离散变量，使用众数替换。</li></ul><h5 id="插值法"><a href="#插值法" class="headerlink" title="插值法"></a>插值法</h5><ul><li>根据其他非缺失的变量或观测来预测缺失值，常见有线性插值法、K近邻插值法、Lagrange插值法等</li></ul><h4 id="对Excel文件数据进行数据-删除-过滤"><a href="#对Excel文件数据进行数据-删除-过滤" class="headerlink" title="对Excel文件数据进行数据(删除)过滤"></a>对Excel文件数据进行数据(删除)过滤</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_excel</span><br><span class="line">a = read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例3.xlsx&#x27;</span>)</span><br><span class="line">b1 = a.dropna()     <span class="comment">#删除所有的缺失值,整行数据都删除</span></span><br><span class="line">b2 = a.dropna(axis=<span class="number">1</span>,thresh=<span class="number">9</span>)</span><br><span class="line"><span class="comment"># 删除一列的数据，这里的thresh就是数据集的个数为多少个，axis=0为行</span></span><br><span class="line">b3 = a.drop(<span class="string">&#x27;用户B&#x27;</span>,axis=<span class="number">1</span>) <span class="comment"># 删除用户B的数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;过滤后的数据：\n&#x27;</span>,b1,<span class="string">&#x27;\n-------------------\n&#x27;</span>,b2,<span class="string">&#x27;\n----------------\n&#x27;</span>,b3)</span><br></pre></td></tr></table></figure><h4 id="对excel表中的确实值进行数据填充"><a href="#对excel表中的确实值进行数据填充" class="headerlink" title="对excel表中的确实值进行数据填充"></a>对excel表中的确实值进行数据填充</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_excel</span><br><span class="line">a = read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例4.xlsx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a,<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用0补齐所有的值</span></span><br><span class="line">b1 = a.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用0填补:\n&#x27;</span>,b1,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用前一行的有的值补齐这一行缺失的值</span></span><br><span class="line">b2 = a.fillna(method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用前一行的值填补\n&#x27;</span>,b2,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用后一行向前一行缺失的值补齐</span></span><br><span class="line">b3 = a.fillna(method=<span class="string">&#x27;bfill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用后一行向前一行缺失的值补齐&#x27;</span>,b3,<span class="string">&#x27;\n-----&#x27;</span>)</span><br><span class="line"></span><br><span class="line">b4=a.fillna(value=&#123;<span class="string">&#x27;gender&#x27;</span>:a.gender.mode()[<span class="number">0</span>],   <span class="comment"># 性别使用总数替换</span></span><br><span class="line">                   <span class="string">&#x27;age&#x27;</span>:a.age.mean(),            <span class="comment"># 年龄使用均值替换</span></span><br><span class="line">                   <span class="string">&#x27;income&#x27;</span>:a.income.median       <span class="comment"># 收入使用中位数替换</span></span><br><span class="line">                     &#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;分变量替换:\n&#x27;</span>,b4)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数值型缺失数据利用插值法进行替换"><a href="#数值型缺失数据利用插值法进行替换" class="headerlink" title="数值型缺失数据利用插值法进行替换"></a>数值型缺失数据利用插值法进行替换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_excel</span><br><span class="line"></span><br><span class="line">a = read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例4.xlsx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b=a.fillna(value=&#123;<span class="string">&#x27;gender&#x27;</span>:a.gender.mode()[<span class="number">0</span>],    <span class="comment"># 性别使用总数替换</span></span><br><span class="line">               <span class="string">&#x27;age&#x27;</span>:a.age.interpolate(method=<span class="string">&#x27;polynomial&#x27;</span>,order=<span class="number">2</span>),</span><br><span class="line">                                            <span class="comment"># 年龄使用二次多项式插值替换</span></span><br><span class="line">               <span class="string">&#x27;income&#x27;</span>:a.income.interpolate() <span class="comment"># 收入使用线性插值替换</span></span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h3><p>异常值的检测一般采用两种方法：<strong>标准差法</strong>、<strong>箱线图法</strong></p><p>太阳黑子个数文件<code>sunspots.csv</code>数据用Excel软件打开后的格式如<code>C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例6_sunspots.csv</code>，共有289条记录，识别并处理其中的异常值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> read_csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">a  = read_csv(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡20_例6_sunspots.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)                  <span class="comment"># 查看数据的多少，此处显示289个记录;2种数据</span></span><br><span class="line"></span><br><span class="line">mu = a.counts.mean()            <span class="comment"># 计算黑子个数counts的年平均数</span></span><br><span class="line"><span class="built_in">print</span>(mu)</span><br><span class="line">s  = a.counts.std()             <span class="comment"># 计算黑子个数标准差</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准差法异常值上限检测：&#x27;</span>,<span class="built_in">any</span>(a.counts&gt;mu+<span class="number">2</span>*s))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标准差法异常值下限检测：&#x27;</span>,<span class="built_in">any</span>(a.counts&lt;mu+<span class="number">2</span>*s))</span><br><span class="line"></span><br><span class="line">Q1=a.counts.quantile(<span class="number">0.25</span>)      <span class="comment"># 计算下四分位数</span></span><br><span class="line"><span class="built_in">print</span>(Q1)</span><br><span class="line">Q3=a.counts.quantile(<span class="number">0.75</span>)      <span class="comment"># 计算上四分位数</span></span><br><span class="line"><span class="built_in">print</span>(Q3)</span><br><span class="line">IQR=Q3-Q1                       <span class="comment"># 计算四分位距</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;箱线法图异常值上限检测:&#x27;</span>,<span class="built_in">any</span>(a.counts&gt;Q3+<span class="number">1.5</span>*IQR))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;箱线法图异常值下限检测:&#x27;</span>,<span class="built_in">any</span>(a.counts&lt;Q1-<span class="number">1.5</span>*IQR))</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)         <span class="comment"># 设置绘线风格</span></span><br><span class="line">a.counts.plot(kind=<span class="string">&#x27;hist&#x27;</span>,bins=<span class="number">30</span>,density=<span class="literal">True</span>)</span><br><span class="line">a.counts.plot(kind=<span class="string">&#x27;kde&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;异常值替换前的数据统计特征:\n&#x27;</span>,a.counts.describe(),<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">UB = Q3+<span class="number">1.5</span>*IQR</span><br><span class="line">st=a.counts[a.counts&lt;UB].<span class="built_in">max</span>()   <span class="comment"># 找出低于判别上限的最大值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;判断异常值的上限临界值为：&#x27;</span>,UB)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;用以替换异常值的数据为：&#x27;</span>,st)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;异常值的位置：\n&#x27;</span>,a.loc[a.counts&gt;UB,<span class="string">&#x27;counts&#x27;</span>])  <span class="comment"># 观察后可以注释掉</span></span><br><span class="line">a.loc[a.counts&gt;UB, <span class="string">&#x27;counts&#x27;</span>]=st  <span class="comment"># 替换超过判别上限异常值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;异常值替换后的数据统计特征为：\n&#x27;</span>,a.counts.describe(),<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">a.to_csv(<span class="string">&#x27;暑假打卡20_例6_sunspots_已数据清洗.csv&#x27;</span>)</span><br><span class="line"> <span class="comment">#将清洗后的数据存入新的文件，此处可自行修改为想保存的文件路径</span></span><br></pre></td></tr></table></figure><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><p>如何利用现有资源来安排生产，以取得最大经济效益的问题。</p><p>例 1 某机床厂生产甲、 乙两种机床， 每台销售后的利润分别为 4000 元与 3000 元。生产甲机床需用 A、 B 机器加工，加工时间分别为每台 2 小时和 1 小时；生产乙机床需用 A、 B、 C 三种机器加工，加工时间为每台各一小时。若每天可用于加工的机器时数分别为 A 机器 10 小时、 B 机器 8 小时和C 机器 7 小时，问该厂应生产甲、乙机床各几台，才能使总利润最大？  </p><blockquote><p><strong>数学模型</strong></p></blockquote><table><thead><tr><th></th><th></th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>4000</td><td>甲</td><td>2</td><td>1</td><td></td></tr><tr><td>3000</td><td>乙</td><td>1</td><td>1</td><td>1</td></tr><tr><td></td><td></td><td>10</td><td>8</td><td>7</td></tr></tbody></table><p>设甲机床有x<sub>1</sub>个，乙机床有x<sub>2</sub>个        （0）x<sub>1</sub>, x<sub>2</sub> 称之为决策变量  </p><blockquote><blockquote><blockquote><blockquote><p>目标函数  max   z &#x3D; 4 x<sub>1</sub> + 3x<sub>2</sub>     （1）目标函数 </p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><p>约束条件：                                              （2）约束条件  </p><blockquote><p>2 x<sub>1</sub> + x<sub>2</sub> &amp;le; 10</p><p>x<sub>1</sub> + x<sub>2</sub> &amp;le; 8</p><p>x<sub>2</sub>  &amp;le; 7</p><p>x<sub>1</sub>,x<sub>2</sub> ≥ 0</p></blockquote></blockquote></blockquote><p>Matlab 中规定线性规划的标准形式为<br>$$<br>\min_{x} c^T x<br>$$</p><p>$$<br>s.t.\begin{cases} Ax\le b \ Aeq \cdot x &#x3D; beq \lb \le x\le ub\end{cases}<br>$$</p><p>其中 c 和 x 为 n 维列向量， A 、 Aeq 为适当维数的矩阵， b 、 beq 为适当维数的列向量。  </p><p>线性规划中<br>$$<br>\min_{x} c^T x  \qquad s.t.  \quad Ax \le b<br>$$<br>的Matlab标准型为<br>$$<br>\min_{x} -c^T x  \qquad s.t.  \quad -Ax \le -b<br>$$</p><p><strong>可行解</strong>：满足目标  s.t.      <em><strong>最优解</strong></em>：满足可行解的情况下，更加接近目标函数     <strong>可行域</strong>：满足所用的可行解</p><p>注：跟高中所学的线性规划的题目相似。平移z函数</p><p>（2，6）点处，可能为非空点（无最优解），或者是实数点（有最优解）。</p><hr><p><em><strong>特别解释及定义：</strong></em></p><p>多维空间中：R不再是二维平面了。我们成多维空间形成的可行域为多胞形。二维平面中最优点一般是顶点，多胞体我们称最优点为一下概念：</p><p>**定义一：称 n 维空间中的区域 R 为一凸集，若   ∀x<sub>1</sub>, x<sub>2</sub> &amp;isin; R 及 ∀&amp;lambda; ∈(0,1) ，有   &amp;lambda;x<sub>1</sub> + (1- &amp;lambda;)x<sub>2</sub> ∈R   **</p><p>**定义二:  设 R 为 n 维空间中的一个凸集， R 中的点 x 被称为 R 的一个极点，若不存在 x<sub>1</sub>、 x<sub>2</sub> ∈ R 及λ ∈(0,1) ,使得 x &#x3D; &amp;lambda;x<sub>1</sub> + (1- &amp;lambda;)x<sub>2</sub>  **</p><p>解释：</p><p>[1].  定义1 说明凸集中<em><strong>任意两点的连线必在此凸集中</strong></em>；  </p><p>[2]. 定义 2 说明，若 x 是凸集 R的一个<strong>极点</strong>，则 <em><strong>x 不能位于 R 中任意两点的连线上</strong></em>。  </p><hr><h3 id="一：单纯形法-—遍历法"><a href="#一：单纯形法-—遍历法" class="headerlink" title="一：单纯形法  —遍历法"></a>一：单纯形法  —遍历法</h3><p>一般<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/1661606">线性规划</a>问题中当线性方程组的变量数大于方程个数，这时会有不定数量的解，而单纯形法是求解线性规划问题的通用方法。</p><p><strong>具体步骤</strong>，从线性方程组找出一个个的单纯形，每一个单纯形可以求得一组解，然后再判断该解使目标函数值是增大还是变小了，决定下一步选择的单纯形。通过优化迭代，直到目标函数实现最大或最小值。</p><p>等我稍加学习后，在拿出来更新分享。</p><h3 id="二：Matlab解法"><a href="#二：Matlab解法" class="headerlink" title="二：Matlab解法"></a>二：Matlab解法</h3><p><em><strong>重点：</strong></em></p><p>Matlab 中规定线性规划的标准形式为<br>$$<br>\min_{x} c^T x<br>$$</p><p>$$<br>s.t.\begin{cases} Ax\le b \ Aeq \cdot x &#x3D; beq \lb \le x\le ub\end{cases}<br>$$</p><p>其中 c 和 x 为 n 维列向量， A 、 Aeq 为适当维数的矩阵， b 、 beq 为适当维数的列向量。  </p><p>**[x,fval]&#x3D;linprog(c,A,b,Aeq,beq,LB,UB,X0,OPTIONS)  **</p><p>LB 和 UB 分别是变量 x 的下界和上界    x0 是 x 的初始值       OPTIONS 是控制参数  </p><p> c 和 x 为 n 维列向量           A 、 Aeq 为适当维数的矩阵 b 、 beq 为适当维数的列向量。 </p><p>$$<br>\min_{z} &#x3D; 2x_1+3x_2-5x_3<br>\s.t.\begin{cases}<br>            x_1+x_2+x_3&#x3D;7\2x_1-5x_2+x_3 \ge 12 \x_1,x_2,x_3 \ge 0<br>        \end{cases}<br>$$<br>Matlab编写：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = [<span class="number">2</span>;<span class="number">3</span>;<span class="number">-5</span>];</span><br><span class="line">a = [<span class="number">-2</span>,<span class="number">5</span>,<span class="number">-1</span>;<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">b = [<span class="number">-10</span>,<span class="number">12</span>];</span><br><span class="line">aeq = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">beq = <span class="number">7</span>;</span><br><span class="line">x = linprog(-c,a,b,aeq,beq,<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">value = c&#x27;*x</span><br></pre></td></tr></table></figure><h3 id="三、python求解"><a href="#三、python求解" class="headerlink" title="三、python求解"></a>三、python求解</h3><h5 id="scipy-optimize模块求解"><a href="#scipy-optimize模块求解" class="headerlink" title="scipy.optimize模块求解"></a>scipy.optimize模块求解</h5><p>scipy.optimize提供了一个线性求解线性规划的函数linprog</p><p>scipy中线性规划的标准形为：<br>$$<br>\min_{x}z&#x3D; c^T x\<br>s.t.\begin{cases} Ax\le b, \<br>Aeq \cdot x &#x3D; beq, \<br>Lb \le x\le Ub\end{cases}<br>$$<br>lingrop的基本调用格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"><span class="comment">### 注：这里的c,A,b,Aeq,beq都要求出来才行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认每个决策变量下界为0，上界为无穷大</span></span><br><span class="line">res=linprog(c, A, b, Aeq, beq) </span><br><span class="line">res=linprog(c,A=<span class="literal">None</span>,b=<span class="literal">None</span>,Aeq=<span class="literal">None</span>,beq=<span class="literal">None</span>,</span><br><span class="line">            bounds=<span class="literal">None</span>,method=’simplex’)</span><br><span class="line"><span class="built_in">print</span>(res.fun)<span class="comment"># 显示目标函数最小值</span></span><br><span class="line"><span class="built_in">print</span>(res.x)<span class="comment"># 显示最优解</span></span><br></pre></td></tr></table></figure><ul><li><p>c 和 x 为 n 维列向量，c 对应目标函数的系数变量</p></li><li><p>A  为适当维数的矩阵， b为适当维数的列向量；A,b分别对应<strong>不等式约束</strong>的系数向量和常数项</p></li><li><p>Aeq 为适当维数的矩阵，beq 为适当维数的列向量；Aeq，beq分别对应<strong>等式约束</strong>的系数向量和常数项</p></li></ul><h6 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h6><hr><p>$$<br>\min_{x}z&#x3D; -x_1+4x_2\<br>s.t.<br>\begin{cases}<br>-3x_1+\ \ x_2\leqslant\ \ \ \  6\<br>\ \ \ \ \ x_1+2x_2 \leqslant\ \ \ \  4 \<br> \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ x_2  \geqslant  -3<br>\end{cases}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c=[-<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">A=[[-<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">b=[<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">bounds=((<span class="literal">None</span>,<span class="literal">None</span>),(-<span class="number">3</span>,<span class="literal">None</span>))</span><br><span class="line"><span class="comment">#      x1的取值无穷  x2的取值&gt;=2</span></span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解：&#x27;</span>,res.x)</span><br></pre></td></tr></table></figure><p>目标函数的最小值： -21.99999984082497<br>最优解： [ 9.99999989 -2.99999999]</p><p>所以最优解为$x_1&#x3D;10,x_2&#x3D;-3$,目标 函数的最优值为 -22.</p><hr><p>$$<br>\min z&#x3D; x_1-2x_2-3x_3\<br>s.t.<br>\begin{cases}<br>-2x_1+x_2+\ \  x_3\leqslant \ \ \ 9\<br>-3x_1+x_2+2x_3 \geqslant \ \ \ 4 \<br>\ \ \ 4x_1-2x_2-x_3 &#x3D;  -6 \<br>x_1\geqslant -10, x_2\geqslant 0,x_3取值无约束<br>\end{cases}<br>$$</p><p>化成标准型：<br>$$<br>\min w&#x3D; -x_1+2x_2+3x_3\<br>s.t.<br>\begin{cases}<br>-2x_1+x_2+\ \  x_3\leqslant \ \ \ 9\<br>\ \ \ 3x_1-x_2-2x_3 \leqslant  -4 \<br>\ \ \ 4x_1-2x_2-x_3 &#x3D;  -6 \<br>x_1\geqslant -10, x_2\geqslant 0,x_3取值无约束<br>\end{cases}<br>$$<br>也就是说将所有都化为$ax_1+bx_2\leqslant c$的形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c=[-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">A=[[-<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">2</span>]]</span><br><span class="line">b=[<span class="number">9</span>,-<span class="number">4</span>]</span><br><span class="line">Aeq=[[<span class="number">4</span>,-<span class="number">2</span>,-<span class="number">1</span>]]</span><br><span class="line">beq=[-<span class="number">6</span>]</span><br><span class="line">LB=[-<span class="number">10</span>,<span class="number">0</span>,<span class="literal">None</span>]</span><br><span class="line">UB=[<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>]</span><br><span class="line"><span class="comment">#bounds=((-10,None,),(0,None),(None,None))</span></span><br><span class="line">bounds=<span class="built_in">tuple</span>(<span class="built_in">zip</span>(LB,UB))</span><br><span class="line">res=linprog(c,A,b,Aeq,beq,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解：&#x27;</span>,res.x)</span><br><span class="line"></span><br><span class="line"><span class="comment">################ or #####################</span></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line">c=[-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">A=[[-<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">2</span>]]</span><br><span class="line">b=[<span class="number">9</span>,-<span class="number">4</span>]</span><br><span class="line">Aeq=[[<span class="number">4</span>,-<span class="number">2</span>,-<span class="number">1</span>]]</span><br><span class="line">beq=[-<span class="number">6</span>]</span><br><span class="line">bounds=((-<span class="number">10</span>,<span class="literal">None</span>,),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="literal">None</span>,<span class="literal">None</span>))</span><br><span class="line">res=linprog(c,A,b,Aeq,beq,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解：&#x27;</span>,res.x)</span><br></pre></td></tr></table></figure><p>即所求问题的最优解为</p><p>目标函数的最小值： 0.4000000006525579<br>最优解： [-1.60000000e+00  8.29738643e-11 -4.00000000e-01]</p><p>（注意x2的解为8.29674988x10<sup>-11</sup> ，写成解的时候保留一位小数就是0.0，即0)</p><hr><p>例题：</p><p>加工一种食用油需要精炼若干种原料油并把它们混合起来、原料油的来源有两类共5种：植物油VEG1、植物油VEG2、非植物油OIL1、非植物油OIL2、非植物油OIL3. 购买每种原料油的价格（英镑&#x2F;吨）如下表1，最终产品以<em><strong>150英镑&#x2F;吨的价格出售</strong></em>. 植物油和非植物油需要在<strong>不同的生成线</strong>上进行精炼. <strong>每月能够精炼的植物油不超过200吨，非植物油不超过250吨</strong>；在精炼过程中，重量没有损失，精炼费用可忽略不计. 最终产品要符合硬度的技术条件. 按照硬度计量单位，它必须为<strong>3~6</strong>. 假定<strong>硬度的混合是线性</strong>的，而原材料的硬度如表2所示.</p><p>求：为使利润最大，应该怎样指定它的月采购和加工计划</p><center>表一  原料油价格</center><table><thead><tr><th>原料油</th><th>VEG1</th><th>VEG2</th><th>OIL1</th><th>OIL2</th><th>OIL3</th></tr></thead><tbody><tr><td>价格</td><td>110</td><td>120</td><td>130</td><td>110</td><td>115</td></tr></tbody></table><center>表2 原料油硬度表</center><table><thead><tr><th>原料油</th><th>VEG1</th><th>VEG2</th><th>OIL1</th><th>OIL2</th><th>OIL3</th></tr></thead><tbody><tr><td>硬度值</td><td>8.8</td><td>6.1</td><td>2.0</td><td>4.2</td><td>5.0</td></tr></tbody></table><p>解：设$x_1,x_2,…,x_5$分别对应了5种原料油吨数，$x_6$为每月加工的成品油吨数</p><ol><li><p>目标函数是要让净利润达到最大：即<br>$$<br>z&#x3D;-100x_1-120x_2-130x_3-110x_4-115x_5+150x_6<br>$$</p></li><li><p>约束条件为以下四类：</p><p>i.精炼能力的限制</p><p>​植物油精炼能力的限制：$x_1+x_2\leqslant 200$</p><p>​非植物油精炼能力的限制：$x_3+x_4+x_5\leqslant 250$ </p><p>ii.硬度的限制</p><p>​硬度上限：$8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\leqslant 6x_6$</p><p>​硬度下限：$8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\geqslant3x_6$</p><p>iii.守恒性质限制（重量没有损失）</p><p>​$x_1+x_1+x_3+x_4+x_5&#x3D;x_6$</p><p>iiii.非负性限制</p><p>​$x_i\geqslant0,i&#x3D;0,1,…,6$</p></li></ol><p>所以建立如下的线性规划<br>$$<br>max\ z&#x3D;-100x_1-120x_2-130x_3-110x_4-115x_5+150x_6\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 200\<br>x_3+x_4+x_5\leqslant 250\<br>8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\leqslant 6x_6\<br>8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5\geqslant3x_6\<br>x_1+x_1+x_3+x_4+x_5&#x3D;x_6\<br>x_i\geqslant0,i&#x3D;0,1,…,6 .<br>\end{cases}<br>$$<br>要先转变成标准型即：<br>$$<br>这种函数\<br>\min_{x}z&#x3D; c^T x\<br>s.t.\begin{cases} Ax\le b, \<br>Aeq \cdot x &#x3D; beq, \<br>Lb \le x\le Ub\end{cases}<br>$$<br>所以得到为：<br>$$<br>max\ z&#x3D;-100x_1-120x_2-130x_3-110x_4-115x_5+150x_6\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 200\<br>x_3+x_4+x_5\leqslant 250\<br>8.8x_1+6.1x_1+2.0x_3+4.2x_4+5.0x_5-6x_6\leqslant 0\<br>-8.8x_1-6.1x_1-2.0x_3-4.2x_4-5.0x_5+3x_6\leqslant0\<br>x_1+x_1+x_3+x_4+x_5-x_6&#x3D;0\<br>x_i\geqslant0,i&#x3D;0,1,…,6 .<br>\end{cases}<br>$$<br>程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">100</span>,-<span class="number">120</span>,-<span class="number">130</span>,-<span class="number">110</span>,-<span class="number">115</span>,<span class="number">150</span>]</span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">8.8</span>,<span class="number">6.1</span>,<span class="number">2.0</span>,<span class="number">4.2</span>,<span class="number">5.0</span>,-<span class="number">6.0</span>],[-<span class="number">8.8</span>,-<span class="number">6.1</span>,-<span class="number">2.0</span>,-<span class="number">4.2</span>,-<span class="number">5.0</span>,<span class="number">3.0</span>]]</span><br><span class="line"><span class="comment">#b=[200,250,0,0]</span></span><br><span class="line">b=[[<span class="number">200</span>],[<span class="number">250</span>],[<span class="number">0</span>],[<span class="number">0</span>]]</span><br><span class="line">Aeq=[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>]]</span><br><span class="line">beq=[<span class="number">0</span>]</span><br><span class="line">bounds=((<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line">res=linprog(c,A,b,Aeq,beq,bounds)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;目标函数的最小值：&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：&#x27;</span>,res.x)</span><br></pre></td></tr></table></figure><p>目标函数的最小值： -4.1769028848418895e-13<br>最优解为： [1.16766018e-16 2.24124639e-15 3.48701448e-16 1.33739624e-15<br> 2.13371900e-15 2.00505560e-15]</p><hr><p>已知某种商品6个仓库的存活量，8个客户对该商品的需求量，单位商品运价如下表3所示. 试确定6个仓库到8个客户的商品调运数量，使总的运输费用最小.</p><table><thead><tr><th>仓库W|单价运价右下\客户V</th><th>V1</th><th>V2</th><th>V3</th><th>V4</th><th>V5</th><th>V6</th><th>V7</th><th>V8</th><th>存货量</th></tr></thead><tbody><tr><td>$W_1$</td><td>6</td><td>2</td><td>6</td><td>7</td><td>4</td><td>2</td><td>5</td><td>9</td><td>60</td></tr><tr><td>$W_2$</td><td>4</td><td>9</td><td>5</td><td>3</td><td>8</td><td>5</td><td>8</td><td>2</td><td>55</td></tr><tr><td>$W_3$</td><td>5</td><td>2</td><td>1</td><td>9</td><td>7</td><td>4</td><td>3</td><td>3</td><td>51</td></tr><tr><td>$W_4$</td><td>7</td><td>6</td><td>7</td><td>3</td><td>9</td><td>2</td><td>7</td><td>1</td><td>43</td></tr><tr><td>$W_5$</td><td>2</td><td>3</td><td>9</td><td>5</td><td>7</td><td>2</td><td>6</td><td>5</td><td>41</td></tr><tr><td>$W_6$</td><td>5</td><td>5</td><td>2</td><td>2</td><td>8</td><td>1</td><td>4</td><td>3</td><td>52</td></tr><tr><td>需求量</td><td>35</td><td>37</td><td>22</td><td>32</td><td>41</td><td>32</td><td>43</td><td>38</td><td></td></tr></tbody></table><p>解：设</p><p>$x_{ij}(i&#x3D;1,2,…,6;j&#x3D;1,2,…,8)$表示第i个仓库到第j个客户的商品数量，</p><p>$c_{ij}(i&#x3D;1,2,…,6;j&#x3D;1,2,…,8)$表示第i个仓库运到第j个客户的单位运价，</p><p>$d_{j}$表示第j个客户的需求量</p><p>$e_i$表示第i个仓库的库存量</p><p>建立线性规划模型：<br>$$<br>min \sum_{i&#x3D;1}^{6}\sum_{j&#x3D;1}^{8}c_{ij}x_{ij},\<br>s.t.<br>\begin{cases}<br>\sum_{j&#x3D;1}^{8}x_{ij}\leqslant e_i,i&#x3D;1,2,…,6\<br>\sum_{i&#x3D;1}^{6}x_{ij}\leqslant d_j,j&#x3D;1,2,…,6\<br>x_{ij}\geqslant0,i&#x3D;1,2,…,6;j&#x3D;1,2,…,8. \<br>\end{cases}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">import cvxpy as cp</span></span><br><span class="line"><span class="string">import numpy as np</span></span><br><span class="line"><span class="string">import pandas as pd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d1=pd.read_excel(r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡21_例4.xlsx&#x27;,header=None)</span></span><br><span class="line"><span class="string"># 这里的header=None是告诉程序没有表头，不然会导致得到的结果的第一行被当作表头使用了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d2=d1.values    # 将值转变为数组</span></span><br><span class="line"><span class="string">c=d2[:-1,:-1]    #读取d2中除最后一行一列的数据</span></span><br><span class="line"><span class="string">e=d2[:-1,-1].reshape(-1,1)#数据表中的最后一列（不包括该列的最后一个元素）,reshape(-1,1)表示生成1列</span></span><br><span class="line"><span class="string">d=d2[-1,:-1].reshape(1,-1)#数据表中的最后一行（不包括该行的最后一个元素），reshape（1，-1）表示生成1行</span></span><br><span class="line"><span class="string">x=cp.Variable((6,8))      #用凸优化的cvxpy库</span></span><br><span class="line"><span class="string">obj=cp.Minimize(cp.sum(cp.multiply(c,x)))   #构造目标函数  即将数据带入x6*8矩阵</span></span><br><span class="line"><span class="string">con=[cp.sum(x,axis=1,keepdims=True)&lt;=e,     #构造约束条件1，axis=1表示按行计算</span></span><br><span class="line"><span class="string">     cp.sum(x,axis=0,keepdims=True)==d,     #构造约束条件2，axis=0表示按列计算</span></span><br><span class="line"><span class="string">     x&gt;=0]</span></span><br><span class="line"><span class="string">prob=cp.Problem(obj,con)    # 构造模型</span></span><br><span class="line"><span class="string">prob.solve(solver=&#x27;SCS&#x27;,verbose=True) #求解模型</span></span><br><span class="line"><span class="string">print(&#x27;最优值为：&#x27;,prob.value)</span></span><br><span class="line"><span class="string">print(&#x27;最优解为：&#x27;,x.value)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d1=pd.read_excel(<span class="string">r&#x27;C:\Users\墨羽辰\Documents\QQ\暑假打卡21_例4.xlsx&#x27;</span>,header=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#如果excel的数据没有表头的变量，则用header=None后会分配索引，否则会吃掉第一行</span></span><br><span class="line"><span class="comment">#print(d1)</span></span><br><span class="line"></span><br><span class="line">d2=d1.values</span><br><span class="line"><span class="comment">#print(&#x27;d2=:\n&#x27;,d2)</span></span><br><span class="line">c=d2[:-<span class="number">1</span>,:-<span class="number">1</span>] <span class="comment">#读取d2中除最后一行一列的数据</span></span><br><span class="line"><span class="comment">#print(&#x27;c= \n&#x27;,c)</span></span><br><span class="line"></span><br><span class="line">e=d2[:-<span class="number">1</span>,-<span class="number">1</span>].reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"> <span class="comment">#数据表中的最后一列（不包括该列的最后一个元素）,reshape(-1,1)表示生成1列</span></span><br><span class="line">d=d2[-<span class="number">1</span>,:-<span class="number">1</span>].reshape(<span class="number">1</span>,-<span class="number">1</span>) </span><br><span class="line"> <span class="comment">#数据表中的最后一行（不包括该行的最后一个元素），reshape（1，-1）表示生成1行</span></span><br><span class="line"></span><br><span class="line">x=cp.Variable((<span class="number">6</span>,<span class="number">8</span>))</span><br><span class="line">obj=cp.Minimize(cp.<span class="built_in">sum</span>(cp.multiply(c,x))) <span class="comment">#构造目标函数</span></span><br><span class="line"></span><br><span class="line">con=[cp.<span class="built_in">sum</span>(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)&lt;=e,  <span class="comment">#构造约束条件，axis=1表示按行计算</span></span><br><span class="line">    cp.<span class="built_in">sum</span>(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)==d,   <span class="comment">#axis=0表示按列计算</span></span><br><span class="line">     x&gt;=<span class="number">0</span>]</span><br><span class="line">prob=cp.Problem(obj,con) <span class="comment"># 构造模型</span></span><br><span class="line">prob.solve(solver=<span class="string">&#x27;SCS&#x27;</span>,verbose=<span class="literal">True</span>) <span class="comment">#求解模型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优值为：&#x27;</span>,prob.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：&#x27;</span>,x.value)</span><br><span class="line"></span><br><span class="line"><span class="comment">######################这里我出错了，可能没有scs库#######################</span></span><br></pre></td></tr></table></figure><h2 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h2><p>灵敏度分析是指对系统因周围条件变化显示出来的敏感程度的分析.</p><p>在上一个例题中，都设定了$c_{ij},d_j,e_i$等为常数，但实际问题中，这些系数往往是估计值，或者预测值，经常有少许的变动。</p><p>所以提出几点问题</p><ul><li>如果参数$c_{ij},d_j,e_i$中的一个或几个发生变化，现行最优方案会有什么变化？</li><li>将这些参数的变化限制在什么范围下，原最优解任然是最优解？</li></ul><p>实际上，给定参数量一个步长使其重复求解线性规划问题，以观察最优解的变化情况，这是一个可用的数值方法，特别是计算机求解时。</p><h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><p>一家奶制品加工厂用牛奶生成A、B两种奶制品，1桶牛奶可以在<strong>甲类</strong>设备上用<strong>12 h</strong>加工成<strong>3kg A</strong>，或者在<strong>乙类</strong>设备上用<strong>8h <strong>加工成</strong>4kg B.</strong> 假定根据市场需求，生成的A，B全部能售出，且<strong>每千克A 获利24元</strong>，<strong>每千克B 获利16 元</strong>. 现在加工厂<strong>每天能得到50 桶牛奶</strong>的供应，<strong>每天正式工人总的劳动时间为480 h</strong>，并且<strong>甲类设备每天至多能加工100kg A</strong>，<strong>乙类设备的加工能力没有限制</strong>. 试为该厂指定一个生产计划，使每天<strong>获利最大</strong>，并进一步讨论以下两个附加问题：</p><p>(1)  若可以聘用临时工人以增加劳动时间，是否聘用临时工人.</p><p>(2)  假设由于市场需求变化，每千克A 的获利增加到30元，是否改变生成计划.</p><p>解：设$x_1$桶牛奶生成A，$x_2$桶牛奶生成B，每天获利z元</p><p>建立方程有：<br>$$<br>min\ z&#x3D;3<em>24x_1+4</em>16x_2&#x3D;72x_1+64x_2\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 50\<br>12x_1+8x_2\leqslant 480\<br>3x_1\leqslant 100\<br>x_1&gt;0,x_2&gt;0<br>\end{cases}<br>$$<br>求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##我的</span></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">72</span>,-<span class="number">64</span>]<span class="comment">#注意此处是目标系数的相反数</span></span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">12</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">0</span>]]</span><br><span class="line">b=[[<span class="number">50</span>],[<span class="number">480</span>],[<span class="number">100</span>]]</span><br><span class="line">bounds=((<span class="number">0</span>,<span class="literal">None</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bounds)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;求解结果为：\n&#x27;</span>,res.fun)</span><br><span class="line"><span class="built_in">print</span>(res.x)</span><br><span class="line"></span><br><span class="line"><span class="comment">##老师的</span></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">72</span>,-<span class="number">64</span>] <span class="comment">#注意此处是目标系数的相反数</span></span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">12</span>,<span class="number">8</span>]]</span><br><span class="line">b=[[<span class="number">50</span>],[<span class="number">480</span>]]</span><br><span class="line">bound=((<span class="number">0</span>,<span class="number">100</span>/<span class="number">3.0</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bound,method=<span class="string">&#x27;simplex&#x27;</span>,options=&#123;<span class="string">&#x27;disp&#x27;</span>:<span class="literal">True</span>&#125;) <span class="comment">#simplex表示单纯形法，</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;求解结果为：\n&#x27;</span>,res)</span><br></pre></td></tr></table></figure><p>为什么c&#x3D;[-72,-64]呢？</p><ul><li>是因为本来这个函数求解的就是最小值，那么要求解最小值的话，变为负数就成为了最大值，但是符号相反。</li></ul><p>所以最优解为：$x_1&#x3D;20;x_2&#x3D;30$，收益最大化为3360元。</p><p>松弛问题slack</p><ul><li>经过求解可知（slack的两个分量都是0），两个约束条件都是“紧约束”，即最优解是不等式的约束条件达到了边界，约束条件此时实际上是等式约束，（1）所以增加劳动时间，会提高收益，因而附加问题（1）应该聘用临时工人.</li></ul><p>问题二：</p><p>当每千克A 的获利增加到30元<br>$$<br>min\ z&#x3D;3<em>30x_1+4</em>16x_2&#x3D;90x_1+64x_2\<br>s.t.<br>\begin{cases}<br>x_1+x_2\leqslant 50\<br>12x_1+8x_2\leqslant 480\<br>3x_1\leqslant 100\<br>x_1&gt;0,x_2&gt;0<br>\end{cases}<br>$$<br>方程几乎不变，只是改变了最优函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> linprog</span><br><span class="line"></span><br><span class="line">c=[-<span class="number">90</span>,-<span class="number">64</span>] <span class="comment">#注意此处是目标系数的相反数</span></span><br><span class="line">A=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">12</span>,<span class="number">8</span>]]</span><br><span class="line">b=[[<span class="number">50</span>],[<span class="number">480</span>]]</span><br><span class="line">bound=((<span class="number">0</span>,<span class="number">100</span>/<span class="number">3.0</span>),(<span class="number">0</span>,<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">res=linprog(c,A,b,<span class="literal">None</span>,<span class="literal">None</span>,bound,method=<span class="string">&#x27;simplex&#x27;</span>,options=&#123;<span class="string">&#x27;disp&#x27;</span>:<span class="literal">True</span>&#125;) <span class="comment">#simplex表示单纯形法，</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;求解结果为：\n&#x27;</span>,res)</span><br></pre></td></tr></table></figure><p>最优解不变，但是获得的价为3720.0。所以生产计划不变。</p><h2 id="整数规划与非线性规划"><a href="#整数规划与非线性规划" class="headerlink" title="整数规划与非线性规划"></a>整数规划与非线性规划</h2><h3 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h3><p>线性规划的变量是连续型的，但如果变量是离散的非负整数值才有意义，就是整数线性规划，简称整数规划（问题依旧不变，但是物品类似不可分，导致得到的解只有整数解）</p><p>求解下列整数线性规划问题<br>$$<br>min\ z&#x3D;40x_1+90x_2\<br>s.t.<br>\begin{cases}<br>9x_1+7x_2\leqslant 56\<br>-7x_1+-20x_2\leqslant -70\<br>x_1&gt;0,x_2&gt;0且为整数<br>\end{cases}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">c=np.array([<span class="number">40</span>,<span class="number">90</span>])</span><br><span class="line">A=np.array([[<span class="number">9</span>,<span class="number">7</span>],[-<span class="number">7</span>,-<span class="number">20</span>]])</span><br><span class="line">b=np.array([<span class="number">56</span>,-<span class="number">70</span>])</span><br><span class="line">x=cp.Variable(<span class="number">2</span>,integer=<span class="literal">True</span>)  <span class="comment">#定义两个整数决策变量</span></span><br><span class="line"></span><br><span class="line">obj=cp.Minimize(c@x)           <span class="comment">#构造函数</span></span><br><span class="line">cons=[A@x&lt;=b,x&gt;=<span class="number">0</span>]             <span class="comment">#构造约束条件，此处 @表示矩阵与矩阵的乘法</span></span><br><span class="line">prob=cp.Problem(obj,cons)      <span class="comment">#构建问题模型</span></span><br><span class="line">prob.solve(solve=<span class="string">&#x27;GLPK_MI&#x27;</span>,verbose=<span class="literal">True</span>) <span class="comment">#求解问题，GLPK_MI表示单纯性法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优值为：\n&#x27;</span>,prob.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：\n&#x27;</span>,x.value)</span><br></pre></td></tr></table></figure><p>最优值为： 350.0                      最优解为： [2. 3.]</p><h3 id="指派问题及求解"><a href="#指派问题及求解" class="headerlink" title="指派问题及求解"></a>指派问题及求解</h3><h4 id="标准指派模型"><a href="#标准指派模型" class="headerlink" title="标准指派模型"></a>标准指派模型</h4><p>标准指派问题的数学模型表现为0-1整数规划的形式，当然可以通过整数规划的算法求最优解，但是标准指派问题的数学具有独特的结构，可采用著名的<strong>匈牙利算法</strong>求标准指派问题的最优解。</p><hr><p>某商业公司计划开办5家新商店，决定由5家建筑公司分别承建. 已知建筑公司$A_i(i&#x3D;1,..,5)$,对新商店$B_j(j&#x3D;1,..,5)$的建造费用的报价（万元）为$c_{ij}(i,j&#x3D;1,..,5)$,如下。为了节省费用，商业公司应当对5家建筑公司怎样分配建造任务，才能使总的建造费最少？</p><table><thead><tr><th></th><th>$B_1$</th><th>$B_2$</th><th>$B_3$</th><th>$B_4$</th><th>$B_5$</th></tr></thead><tbody><tr><td>$A_1$</td><td>4</td><td>8</td><td>7</td><td>15</td><td>12</td></tr><tr><td>$A_2$</td><td>7</td><td>9</td><td>17</td><td>14</td><td>10</td></tr><tr><td>$A_3$</td><td>6</td><td>9</td><td>12</td><td>8</td><td>7</td></tr><tr><td>$A_4$</td><td>6</td><td>7</td><td>14</td><td>6</td><td>10</td></tr><tr><td>$A_5$</td><td>6</td><td>9</td><td>12</td><td>10</td><td>6</td></tr></tbody></table><p>解：这是一个标准的指派问题. 引进0-1变量<br>$$<br>x_{ij}<br>\begin{cases}<br>1,A_i承建B_j;\<br>0,A_i不承建B_j;\<br>\end{cases}<br>\ \ \ (i,j&#x3D;1,2,3,4,5)<br>$$<br>建立数学模型：<br>$$<br>min\ z&#x3D;\sum_{i&#x3D;1}^{5}\sum_{j&#x3D;1}^{5}c_{ij}+x_{ij}\<br>s.t.<br>\begin{cases}<br>\sum_{j&#x3D;1}^{5}x_{ij}&#x3D;1,i&#x3D;1,2,…,5\<br>\sum_{i&#x3D;1}^{5}x_{ij}&#x3D;1,i&#x3D;1,2,…,5\<br>x_{ij}&#x3D;0\ or\ 1,(i,j&#x3D;1,2,…,5)<br>\end{cases}<br>(意思是每个房子都要建且只能是一个建筑队去建且要不不建要不建)<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"></span><br><span class="line">c=np.array([</span><br><span class="line">    [<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">12</span>],</span><br><span class="line">    [<span class="number">7</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">14</span>,<span class="number">10</span>],</span><br><span class="line">    [<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">7</span> ],</span><br><span class="line">    [<span class="number">6</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">10</span>],</span><br><span class="line">    [<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">6</span> ] ])</span><br><span class="line">x=cp.Variable((<span class="number">5</span>,<span class="number">5</span>),integer=<span class="literal">True</span>) <span class="comment">#定义5*5的整型变量</span></span><br><span class="line"></span><br><span class="line">obj=cp.Minimize(cp.<span class="built_in">sum</span>(cp.multiply(c,x)))   <span class="comment">#构造函数</span></span><br><span class="line">con=[<span class="number">0</span>&lt;=x,x&lt;=<span class="number">1</span>,cp.<span class="built_in">sum</span>(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)==<span class="number">1</span>,</span><br><span class="line">     cp.<span class="built_in">sum</span>(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)==<span class="number">1</span>]</span><br><span class="line"><span class="comment"># axis=0表示按列相加，keepdims=True指保持其二维特性</span></span><br><span class="line">prob=cp.Problem(obj,con)</span><br><span class="line">prob.solve(solver=<span class="string">&#x27;GLPK_MI&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优值为：&#x27;</span>,prob.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最优解为：\n&#x27;</span>,x.value)</span><br></pre></td></tr></table></figure><h4 id="广义指派模型"><a href="#广义指派模型" class="headerlink" title="广义指派模型"></a>广义指派模型</h4><h5 id="最大化指派模型"><a href="#最大化指派模型" class="headerlink" title="最大化指派模型"></a>最大化指派模型</h5><p>在实际应用中，常会遇到各种非标准形式的指派问题—广义指派问题，通常的处理方法是<strong>先讲它们转化为标准形式，然后再用匈牙利算法求解</strong><strong>.</strong></p><p>一些指派问题中，每人完成各项工作的<strong>效率</strong>可能是诸如<strong>利润、业绩</strong>等(效益型指标&#x2F;指标体现)，此时则以总的工作效率最大为目标函数，即<br>$$<br>max\ z&#x3D;\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij}<br>$$<br>对于最大化指派问题，若令：<br>$$<br>M&#x3D;\max_{i\leqslant n,j\leqslant n} {c_{ij} }<br>$$<br>再由于约束函数条件的限制<br>$$<br>\sum^{n}<em>{i&#x3D;1}\sum</em>{j&#x3D;1}^{n}x_{ij}&#x3D;n<br>$$<br>则有：<br>$$<br>min\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}(M-c_{ij})x_{ij}\<br>&#x3D;min(\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}Mx_{ij}-\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij})\<br>&#x3D;nM-max\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \<br>$$<br>即<br>$$<br>max\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij}&#x3D;<br>nM-min\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}(M-c_{ij})x_{ij}<br>$$<br>于是，使得$C&#x3D;(c_{ij})<em>{n\times n}$为效率矩阵的最大化指派问题，就转化为求以$(M-c</em>{ij})_{n\times n}$为效率矩阵的标准指派问题。</p><h5 id="人数和任务数不等的指派问题"><a href="#人数和任务数不等的指派问题" class="headerlink" title="人数和任务数不等的指派问题"></a>人数和任务数不等的指派问题</h5><ul><li>若人数少于任务数，添加虚拟的“人”，对应的效率取为0</li><li>若人数多于任务数，添加虚拟的“任务”，对应的效率取为0</li></ul><h5 id="一个人可完成多项任务的指派问题"><a href="#一个人可完成多项任务的指派问题" class="headerlink" title="一个人可完成多项任务的指派问题"></a>一个人可完成多项任务的指派问题</h5><ul><li>可将该人看作相同的几个人来接受指派，只需令其完成同一项任务的效率都一样即可</li></ul><h5 id="某项任务一定不能由某人完成的指派问题"><a href="#某项任务一定不能由某人完成的指派问题" class="headerlink" title="某项任务一定不能由某人完成的指派问题"></a>某项任务一定不能由某人完成的指派问题</h5><ul><li>对于这样的指派问题，只需将相应的效率值取成足够大的数即可.</li></ul><p>注意：上述是理论推导，在实际使用软件求解广义指派问题时，也可直接建立0-1整数规划模型，不需要把广义指派问题化成标准的指派问题.</p>]]></content>
    
    
    <summary type="html">数学建模的建模方法</summary>
    
    
    
    
  </entry>
  
</feed>
